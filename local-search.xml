<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ACM/ICPC 竞赛笔记</title>
    <link href="/2023/Note_Of_ACM_ICPC_Contest/"/>
    <url>/2023/Note_Of_ACM_ICPC_Contest/</url>
    
    <content type="html"><![CDATA[<h1 id="acmicpc-概览">ACM/ICPC 概览</h1><h2 id="online-judge-oj">Online Judge (OJ)</h2><table><thead><tr class="header"><th style="text-align: left;">返回结果</th><th style="text-align: center;">含义</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">Accept (AC)</td><td style="text-align: center;">答案正确，被系统接受</td></tr><tr class="even"><td style="text-align: left;">Wrong Answer (WA)</td><td style="text-align: center;">答案错误</td></tr><tr class="odd"><td style="text-align: left;">Runtime Error (RE)</td><td style="text-align: center;">运行时错误</td></tr><tr class="even"><td style="text-align: left;">Compile Error (CE)</td><td style="text-align: center;">编译错误</td></tr><tr class="odd"><td style="text-align: left;">Presentation Error (PE)</td><td style="text-align: center;">答案格式错误</td></tr><tr class="even"><td style="text-align: left;">Time Limit Exceeded (TLE)</td><td style="text-align: center;">超时</td></tr><tr class="odd"><td style="text-align: left;">Memory Limit Exceeded (MLE)</td><td style="text-align: center;">超内存</td></tr><tr class="even"><td style="text-align: left;">Output Limit Exceeded (OLE)</td><td style="text-align: center;">超输出</td></tr><tr class="odd"><td style="text-align: left;">Restrict Function Call (RFC)</td><td style="text-align: center;">使用不允许的API</td></tr><tr class="even"><td style="text-align: left;">System Error</td><td style="text-align: center;">系统错误</td></tr><tr class="odd"><td style="text-align: left;">Queuing</td><td style="text-align: center;">排队等待系统测评</td></tr><tr class="even"><td style="text-align: left;">Judging</td><td style="text-align: center;">评测中</td></tr></tbody></table><h2 id="基本输入">基本输入</h2><ol type="1"><li><p>输入不说明有多少个 Input Block, 以 EOF 为结束标志。</p><ul><li><p>C 版本</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;a, &amp;b) != EOF) {<br>   <span class="hljs-comment">// 在这处理数据</span><br>}<br></code></pre></td></tr></tbody></table></figure></li><li><p>C++ 版本</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(cin &gt;&gt; a &gt;&gt; b) {<br>   <span class="hljs-comment">// 在这处理数据</span><br>} <br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p>输入说明了有多少个</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">while</span>(--n) {<br>   <span class="hljs-comment">// 在这处理数据</span><br>}<br></code></pre></td></tr></tbody></table></figure></li></ol><h2 id="确保代码效率">确保代码效率</h2><ol type="1"><li><p>除了循环控制变量以外，变量全部和标准 C一样先声明好再使用，能赋初值的赋初值初始化</p></li><li><p>数组不要反复开，用的时候直接用<code>memset(array_pointer, 0, sizeof(array_pointer));</code>清空数组</p></li><li><p>不混用 C 和 C++ 的输入输出流时，直接禁用运行时流同步</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br></code></pre></td></tr></tbody></table></figure></li><li><p>禁用流绑定</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br></code></pre></td></tr></tbody></table></figure></li></ol><h1 id="基本算法">基本算法</h1><h2 id="字符串">字符串</h2><h3 id="c-标准库函数">C 标准库函数</h3><p>头文件：<code>#include &lt;string.h&gt;</code> 或<code>#include &lt;cstring&gt;</code></p><h4 id="赋值">赋值</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 函数原型 strcpy(destination, str);</span><br><span class="hljs-type">char</span> str[<span class="hljs-number">40</span>];<br><span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">"C Programming Language"</span>);<br><span class="hljs-comment">// 把字符串赋给 str 字符数组</span><br></code></pre></td></tr></tbody></table></figure><p>将字符串复制到字符数组中。如果字符串的长度小于数组的长度，其余部分用<code>'\0'</code> 填补。返回处理完成的字符串。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 函数原型 strncpy(destination, str, length);</span><br><span class="hljs-type">char</span> str[<span class="hljs-number">20</span>]; <br><span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">"C Programming Language"</span>, <span class="hljs-number">13</span>);<br><span class="hljs-comment">// 把字符串至多前 n 个字符的子串赋给 str 字符数组</span><br></code></pre></td></tr></tbody></table></figure><p>将字符串中至多前 <em>n</em>个字符，复制到字符数组中。如果字符串的长度小于数组的长度，其余部分用<code>'\0'</code> 填补。返回处理完成的字符串。（有点类似于 Python 中对<code>str</code> 类型取 slice：<code>str = string[:n]</code>）</p><h4 id="长度">长度</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 函数原型 strlen(str);</span><br><span class="hljs-built_in">strlen</span>(<span class="hljs-string">"Hello"</span>); <span class="hljs-comment">// 结果是 5（不是 6）</span><br></code></pre></td></tr></tbody></table></figure><p>返回字符串的有效字符数（除空字符以外的的字符个数）。</p><p><span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>注意</strong></p><p><code>strlen()</code> 和 <code>sizeof()</code>是有区别的，<code>sizeof("Hello")</code> 的值是 6。</p><h3 id="c-标准库函数-1">C++ 标准库函数</h3><p>头文件：<code>#include &lt;string&gt;</code></p><h3 id="子串匹配">子串匹配</h3><h2 id="高精度">高精度</h2><h3 id="高精度加法">高精度加法</h3><pre><code class=" mermaid">flowchart TB;input(输入字符串)--&gt;reverse(倒序字符串, 使得个位对齐方便计算)--&gt;add(逐位相加)--&gt;carry(逐位处理进位问题)--&gt;highest(根据最高位处理前导 0 问题)</code></pre><h3 id="高精度减法">高精度减法</h3><h3 id="高精度乘法">高精度乘法</h3><h3 id="高精度除法">高精度除法</h3>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>程序设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>概率论笔记</title>
    <link href="/2023/Note_Of_Probability_And_Statistics/"/>
    <url>/2023/Note_Of_Probability_And_Statistics/</url>
    
    <content type="html"><![CDATA[<h1 id="概率论的基本概念">概率论的基本概念</h1><pre><code class=" mermaid">flowchart LR;  cf(条件概率公式)--&gt;|变形|mf(乘法公式)--&gt;|相加|tf(全概率公式)  bf(Bayes 公式)  tf--&gt;bf  cf--&gt;bf  mf--&gt;bf  click cf href "https://devexzh.github.io/2023/Note_Of_Probability_And_Statistics/#条件概率公式"  click mf href "https://devexzh.github.io/2023/Note_Of_Probability_And_Statistics/#乘法公式"  click tf href "https://devexzh.github.io/2023/Note_Of_Probability_And_Statistics/#全概率公式"</code></pre><h2 id="随机试验">随机试验</h2><table><thead><tr class="header"><th style="text-align: center;">名词</th><th style="text-align: left;">释义</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">确定性现象</td><td style="text-align: left;">结果呈确定性的现象</td></tr><tr class="even"><td style="text-align: center;">随机现象</td><td style="text-align: left;">在个别试验中呈现不确定性，在大量重复实验中表现出统计规律性的现象</td></tr><tr class="odd"><td style="text-align: center;">随机试验</td><td style="text-align: left;">对随机现象的实现或对其观察 (e.g.投币观察向上的面)</td></tr></tbody></table><p>随机试验的特点</p><ol type="1"><li>相同条件下<strong>可重复</strong></li><li>试验<strong>结果明确可知</strong>，且一般不止一个</li><li>试验前<strong>不能确定</strong>哪个结果出现</li></ol><h2 id="样本空间与随机事件">样本空间与随机事件</h2><table><thead><tr class="header"><th style="text-align: center;">名词</th><th style="text-align: left;">释义</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">样本空间</td><td style="text-align: left;">将随机试验 <span class="math inline">\(E\)</span> 所有可能的结果组成的集合称为 <span class="math inline">\(E\)</span> 的样本空间 (Sample Space)</td></tr><tr class="even"><td style="text-align: center;">样本点</td><td style="text-align: left;">样本空间的元素即为样本点</td></tr><tr class="odd"><td style="text-align: center;">随机事件</td><td style="text-align: left;"><span class="math inline">\(E\)</span>的样本空间的子集为 <span class="math inline">\(E\)</span>的随机事件</td></tr></tbody></table><h2 id="频率与概率">频率与概率</h2><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">频率</th><th style="text-align: center;">概率</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">定义</td><td style="text-align: center;">事件发生的频数与试验总数之间的比值</td><td style="text-align: center;">事件发生的可能性大小</td></tr></tbody></table><p>概率的基本性质：</p><ol type="1"><li>非负性：任一事件 <span class="math inline">\(A\)</span>，<span class="math inline">\(P(A)\geq 0\)</span></li><li>规范性：必然事件 <span class="math inline">\(S\RightarrowP(S)=1\)</span>（反之不对）</li><li>可列可加性：设 <span class="math inline">\(A_1,\,A_2,\,\cdots,\,A_n\)</span>两两互不相容，则必有 <span class="math inline">\(P\left(A_1\cupA_2\cup\cdots \cup A_n\right)=P(A_1)+P(A_2)+\cdots+P(A_n)\)</span></li></ol><p>重要性质：</p><ol type="1"><li><span class="math inline">\(P(\emptyset)=0\)</span>：不可能事件的概率为0，反之不对</li><li>若 <span class="math inline">\(A\subset B\)</span>，则 <span class="math inline">\(P(A)\leq P(B)\)</span>（当且仅当 <span class="math inline">\(A=B\)</span> 时等号成立）<ul><li>特别地，<span class="math inline">\(ABC\subset AB\)</span></li></ul></li><li><span class="math inline">\(P\left(A\cupB\right)=P(A)+P(B)-P(AB)\)</span><ul><li>推广：<span class="math inline">\(P\left(A\cup B\cupC\right)=P(A)+P(B)+P(C)-P(AB)-P(BC)-P(AC)+P(ABC)\)</span></li><li>容斥原理：所有奇数个事件积的概率减去所有偶数个事件积的概率</li></ul></li></ol><h2 id="条件概率公式">条件概率公式</h2><p>【例】将一枚硬币抛掷两次，观察其出现正反面的情况。设事件 <span class="math inline">\(A\)</span> 为 “至少有一次是 <span class="math inline">\(H\)</span>”，事件 <span class="math inline">\(B\)</span> 为 “两次掷出同一面”，求事件 <span class="math inline">\(A\)</span> 已经发生的条件下事件 <span class="math inline">\(B\)</span> 发生的概率。<br>【解】<span class="math inline">\(\begin{array}{l}S=\left\{HH,\,HT,\,TH,\,TT\right\}\\A=\left\{HH,\,HT,\,TH\right\}\\B=\left\{HH,\,TT\right\}\\AB=\left\{HH\right\}\end{array}\Rightarrow\begin{array}{l}P(A)=\frac34\\P(B)=\frac24\\P(AB)=\frac14\end{array}\)</span>，事件<span class="math inline">\(A\)</span> 发生且 <span class="math inline">\(B\)</span> 发生，只有 <span class="math inline">\(HH\)</span> 符合要求；而由于是 <span class="math inline">\(A\)</span> 已经发生，故事件 <span class="math inline">\(A\)</span> 已经发生的条件下事件 <span class="math inline">\(B\)</span> 发生的概率就是集合 <span class="math inline">\(A\)</span> 中 <span class="math inline">\(HH\)</span> 发生的概率，即 <span class="math inline">\(\frac13\)</span>。易发现 <span class="math inline">\(P(B|A)=\frac{P(BA)}{P(A)}\)</span>。</p><blockquote><p>设事件 <span class="math inline">\(A\)</span> 的概率 <span class="math inline">\(P(A)\gt 0\)</span>，则在事件 <span class="math inline">\(A\)</span> 发生的情况下，事件 <span class="math inline">\(B\)</span> 发生的条件概率 (<em>ConditionalProbability</em>) 记为 <span class="math inline">\(P(B|A)\)</span>，且<span class="math inline">\(\displaystyleP(B|A)=\frac{P(BA)}{P(A)}\)</span></p></blockquote><h2 id="乘法公式">乘法公式</h2><p>根据条件概率公式即可推得乘法公式 (<em>The Multiplication Rule forConditional Probabilities</em>)：<span class="math inline">\(P(AB)=P(A)\cdot P(B|A)\)</span></p><p>推广：<span class="math inline">\(P(ABCD)=P(A)\cdot P(B|A)\cdotP(C|AB)\cdot P(D|ABC)\)</span></p><h2 id="全概率公式">全概率公式</h2><p>样本空间的划分：设样本空间 <span class="math inline">\(S\)</span>，<span class="math inline">\(B_1,\,B_2,\,\cdots,\,B_n\)</span>是一组事件，若：</p><ol type="1"><li><span class="math inline">\(B_iB_j=\emptyset\quad(i\neqj,\;i,\,j\in[1,\,n])\)</span></li><li><span class="math inline">\(\displaystyle\bigcup^n_{i=1}B_i=S\)</span></li></ol><p>则 <span class="math inline">\(B_1,\,B_2,\,\cdots,\,B_n\)</span> 为<span class="math inline">\(S\)</span> 的一个<strong>划分</strong>(<em>partition</em>)。</p><blockquote><p>设 <span class="math inline">\(E\)</span> 的样本空间为 <span class="math inline">\(S\)</span>，<span class="math inline">\(A\)</span>是 <span class="math inline">\(E\)</span> 的一个事件，<span class="math inline">\(B_1,\,B_2,\,\cdots,\,B_n\)</span> 为 <span class="math inline">\(S\)</span> 的一个划分，且 <span class="math inline">\(P(B_i)\gt 0\quad(i=1,\,2,\,\cdots,\,n)\)</span>，则： <span class="math display">\[P(A)=P(B_1)P(A|B_1)+P(B_2)P(A|B_2)+\cdots+P(B_n)P(A|B_n)\]</span></p></blockquote><p>【证明】<span class="math inline">\(A=A\cap S=A\cap\left(B_1\cupB_2\cup\cdots\cup B_n\right)=AB_1\cup AB_2\cup\cdots\cupAB_n\)</span>，因为 <span class="math inline">\(B_i\)</span> 和 <span class="math inline">\(B_j\)</span> 互不相容，故 <span class="math inline">\(AB_i\)</span> 和 <span class="math inline">\(AB_j\)</span> 也互不相容（<span class="math inline">\(AB_i\subsetB_i\)</span>）。根据互斥事件的可列可加性，故 <span class="math inline">\(\newcommand\b[1]{\left(#1\right)}P\b{A}=P\b{AB_1\cupAB_2\cup\cdots\cup AB_n}=\)</span> <span class="math inline">\(\newcommand\b[1]{\left(#1\right)}P\b{AB_1}+P\b{AB_2}+\cdots+P\b{AB_n}\)</span><span class="math inline">\(=\newcommand\b[1]{\left(#1\right)}P\b{B_1}P\b{A|B_1}+P\b{B_2}P\b{A|B_2}+\cdots+P\b{B_n}P\b{A|B_n}\)</span>。</p><h2 id="bayes-公式"><span class="math inline">\(Bayes\)</span> 公式</h2><blockquote><p>设试验 <span class="math inline">\(E\)</span> 的样本空间 <span class="math inline">\(S\)</span>，<span class="math inline">\(A\)</span>是 <span class="math inline">\(E\)</span> 的一个事件，<span class="math inline">\(B_1,\,B_2,\,\cdots,\,B_n\)</span> 为 <span class="math inline">\(S\)</span> 的一个划分，且 <span class="math inline">\(P(A)\gt 0\)</span>，<span class="math inline">\(P(B_i)\gt 0\quad(i=1,\,2,\,\cdots,\,n)\)</span>，则： <span class="math display">\[P\left(B_i|A\right)=\frac{P\left(B_i\right)\cdotP\left(A|B_i\right)}{\displaystyle\sum^n_{j=1}P\left(B_j\right)\cdotP\left(A|B_j\right)}\]</span></p></blockquote><p>【推导】<span class="math inline">\(P\left(B_i|A\right)\xlongequal{条件概率公式}\frac{P\left(B_iA\right)}{P\left(A\right)}\xlongequal[全概率公式]{乘法公式}\frac{P\left(B_i\right)\cdotP\left(A|B_i\right)}{\sum^n_{j=1}P\left(B_j\right)\cdotP\left(A|B_j\right)}\)</span></p><h2 id="事件的关系">事件的关系</h2><h3 id="事件的独立性">事件的独立性</h3><p><strong>〔定义〕</strong> 设 <span class="math inline">\(A,\,B\)</span> 为两事件，若满足 <span class="math inline">\(P(AB)=P(A)\cdot P(B)\)</span>，则称 <span class="math inline">\(A,\,B\)</span> 相互独立。</p><hr><h1 id="随机变量及其分布">随机变量及其分布</h1><pre><code class=" mermaid">flowchart TB;title(随机变量及其分布) --- rv(随机变量) &amp; drv(离散型随机变量及其分布律) &amp; pf(随机变量的分布函数) &amp; crv(连续型随机变量及其概率密度) &amp; dist(随机变量的函数的分布)</code></pre><p>随机变量 (Random Variable, <em>r.v.</em>)：随机试验 <span class="math inline">\(E\)</span> 的样本空间 <span class="math inline">\(S={e},\,X=X(e)\)</span> （<span class="math inline">\(e\)</span> 为样本点）是定义在 <span class="math inline">\(S\)</span> 上的<strong>实值单值</strong>函数，则称<span class="math inline">\(X=X(e)\)</span> 是随机变量（每个样本点 <span class="math inline">\(e\)</span> 都对应了一个实数 <span class="math inline">\(X\)</span>）</p><h2 id="离散型随机变量及其分布">离散型随机变量及其分布</h2><p>离散型随机变量的取值是有限多个或者可列无穷多个的随机变量</p><table><thead><tr class="header"><th style="text-align: center;">分布</th><th style="text-align: center;">背景</th><th style="text-align: center;">分布律</th><th style="text-align: center;">记号</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0-1 Distribution</td><td style="text-align: center;">描述一次 Bernoulli 试验中发生的概率</td><td style="text-align: center;"><span class="math inline">\(P\left\{X=1\right\}=p\)</span><span class="math inline">\(P\left\{X=0\right\}=1-p\)</span></td><td style="text-align: center;"><span class="math inline">\(X\simB(1,\,p)\)</span></td></tr><tr class="even"><td style="text-align: center;">Binomial Distribution</td><td style="text-align: center;">描述 <span class="math inline">\(n\)</span> 重 Bernoulli 试验中发生 <span class="math inline">\(k\)</span> 次的概率</td><td style="text-align: center;"><span class="math inline">\(P\left\{X=k\right\}=C^k_np^k\left(1-p\right)^{n-k}\)</span></td><td style="text-align: center;"><span class="math inline">\(X\simB(n,\,p)\)</span></td></tr><tr class="odd"><td style="text-align: center;">Geometric Distribution</td><td style="text-align: center;">Bernoulli 试验第 <span class="math inline">\(k\)</span> 次才发生</td><td style="text-align: center;"><span class="math inline">\(P\left\{X=k\right\}=\left(1-p\right)^{k-1}p\)</span></td><td style="text-align: center;"><span class="math inline">\(X\simG(p)\)</span></td></tr><tr class="even"><td style="text-align: center;">Poisson Distribution</td><td style="text-align: center;">近似求解二项分布</td><td style="text-align: center;"><span class="math inline">\(P\left\{X=k\right\}=\frac{\lambda^k}{k!}e^{-\lambda}\)</span></td><td style="text-align: center;"><span class="math inline">\(X\simP(\lambda)\)</span></td></tr><tr class="odd"><td style="text-align: center;">Hypergeometric Distribution</td><td style="text-align: center;"><span class="math inline">\(N\)</span>件产品中有 <span class="math inline">\(M\)</span> 件不合格品，从中随机抽<span class="math inline">\(n\)</span> 件，其中有 <span class="math inline">\(k\)</span> 件不合格的概率</td><td style="text-align: center;"><span class="math inline">\(P\left\{X=k\right\}=\displaystyle\frac{C_M^kC_{N-M}^{n-k}}{C_N^n}\)</span></td><td style="text-align: center;"><span class="math inline">\(X\simH(N,\,M,\,n)\)</span></td></tr></tbody></table><h3 id="随机变量的分布函数">随机变量的分布函数</h3><p><strong>〔定义〕</strong> 设 <span class="math inline">\(X\)</span>是随机变量，<span class="math inline">\(x\)</span> 是任意实数，则 <span class="math display">\[F\left(x\right)=P\left\{X\leq x\right\},\quad-\infty\lt x\lt +\infty\]</span> 是 <span class="math inline">\(X\)</span> 的分布函数。</p><p><strong>性质</strong></p><ol type="1"><li><span class="math inline">\(0\leq F\left(x\right)\leq1\)</span></li><li>单调不减性：对于 <span class="math inline">\(\forall x_1\ltx_2\)</span>，有 <span class="math inline">\(F\left(x_1\right)\leqF\left(x_2\right)\)</span></li><li>规范性：<span class="math inline">\(F\left(-\infty\right)=0,\quadF\left(+\infty\right)=1\)</span></li><li>右连续性：<span class="math inline">\(\displaystyle\lim_{x\tox_0^+}F\left(x\right)=F\left(x_0\right)\)</span></li></ol><h2 id="连续型随机变量及其分布">连续型随机变量及其分布</h2><pre><code class=" mermaid">flowchart LR;  pdf(概率密度函数&lt;br/&gt;&lt;i&gt;p.d.f&lt;/i&gt;)--&gt;|变上限积分|cdf(分布函数&lt;br/&gt;&lt;i&gt;c.d.f&lt;/i&gt;)</code></pre><p><strong>〔定义〕</strong> 设随机变量 <span class="math inline">\(X\)</span> 的累积分布函数 (Cumulative DistributionFunction, <em>c.d.f</em>) 为 <span class="math inline">\(F(x)\)</span>，若存在连续、可积的函数 <span class="math inline">\(f(x)\)</span> 使得任意 <span class="math inline">\(x\)</span> 都有 <span class="math display">\[P\left\{X\leqx\right\}=F\left(x\right)=\int_{-\infty}^x{f\left(t\right)dt}\]</span>则 <span class="math inline">\(f(x)\)</span> 为随机变量 <span class="math inline">\(X\)</span> 的概率密度函数 (Probability DensityFunction, <em>p.d.f</em>)。</p><h3 id="分布">分布</h3><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">均匀分布</th><th style="text-align: center;">指数分布</th><th style="text-align: center;">正态分布</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">英文</td><td style="text-align: center;">Uniform Distribution</td><td style="text-align: center;">Exponential Distribution</td><td style="text-align: center;">Normal Distribution</td></tr><tr class="even"><td style="text-align: center;">概率密度函数 <span class="math inline">\(f\left(x\right)\)</span></td><td style="text-align: center;"><span class="math inline">\(\left\{\begin{array}{cl}\dfrac{1}{b-a}&amp;a\ltx\lt b\\0&amp;\mathrm{otherwise}\end{array}\right.\)</span></td><td style="text-align: center;"><span class="math inline">\(\left\{\begin{array}{cl}\lambda e^{-\lambdax}&amp;x\gt 0\\0&amp;x\leq 0\end{array}\right.\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{\left(x-\mu\right)^2}{2\sigma^2}}\)</span></td></tr><tr class="odd"><td style="text-align: center;">记号</td><td style="text-align: center;"><span class="math inline">\(X\simU(a,\,b)\)</span></td><td style="text-align: center;"><span class="math inline">\(X\simE(\lambda)\)</span></td><td style="text-align: center;"><span class="math inline">\(X\simN\left(\mu,\,\sigma^2\right)\)</span></td></tr></tbody></table><h4 id="正态分布的性质">正态分布的性质</h4><p><span class="github-emoji"><span>📓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4d3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 当 <span class="math inline">\(\mu=0,\,\sigma=1\)</span>时，为标准正态分布 <span class="math inline">\(\varphi\left(x\right)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}\)</span></p><ol type="1"><li>在 <span class="math inline">\(x=\mu\)</span>时，正态分布的概率密度函数取到最大值：<span class="math inline">\(f\left(x\right)_{\mathrm{max}}=f\left(\mu\right)=\frac{1}{\sqrt{2\pi}\sigma}\)</span></li><li>标准正态分布函数的对称性：<span class="math inline">\(\Phi\left(x\right)+\Phi\left(-x\right)=1\)</span></li><li>在计算中常常可以通过凑正态分布计算 <span class="math inline">\(\displaystyle\int_{-\infty}^{+\infty}e^{-\frac{t^2}{2}}dt=\sqrt{\pi}\)</span></li></ol><hr><h1 id="多维随机变量及其分布">多维随机变量及其分布</h1><pre><code class=" mermaid">flowchart TB;title(多维随机变量及其分布) --- trv(二维随机变量) &amp; mdist(边缘分布) &amp; cdist(条件分布) &amp; indeptrv(相互独立的随机变量) &amp; trvdist(两个随机变量的函数的分布)</code></pre><h2 id="边缘分布">边缘分布</h2><p>边缘密度函数 <span class="math display">\[\begin{array}{}\displaystylef_X(x)=\int_{-\infty}^{+\infty}f(x,\,y)dy\\[12pt] \displaystylef_Y(y)=\int_{-\infty}^{+\infty}f(x,\,y)dx\end{array}\]</span></p><p>条件密度函数：联合密度函数比边缘密度函数 <span class="math display">\[f_{Y|X}\left(y|x\right)=\dfrac{f(x,\,y)}{f_X(x)}\]</span></p><p>二维随机变量 <span class="math inline">\((X,\,Y)\)</span>的联合概率密度函数 <span class="math inline">\(f(x,\,y)\)</span>、联合分布函数 <span class="math inline">\(F(x,\,y)\)</span>。则边缘分布函数为： <span class="math display">\[F_X(x)=F(x,\,+\infty)=\int_{-\infty}^{x}f_X(x)dx=\int_{-\infty}^{x}\int_{-\infty}^{+\infty}{f(x,\,y)dy}dx\]</span><span class="math display">\[F_Y(y)=F(+\infty,\,y)=\int_{-\infty}^{y}f_Y(y)dy=\int_{-\infty}^{y}\int_{-\infty}^{+\infty}{f(x,\,y)dx}dy\]</span></p><p>判断两个随机变量是否独立：两个边缘概率密度相乘是否等于联合概率密度</p><h1 id="随机变量的数字特征">随机变量的数字特征</h1><h2 id="数学期望">数学期望</h2><p><span class="math display">\[E(X)=\int_{-\infty}^{+\infty}xf(x)dx\]</span></p><h2 id="方差">方差</h2><p><span class="math display">\[D(X)=E(X^2)-E^2(X)\]</span></p><h2 id="常见分布的期望与方差">常见分布的期望与方差</h2><table><thead><tr class="header"><th style="text-align: center;">分布</th><th style="text-align: center;">期望</th><th style="text-align: center;">方差</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Binomial Distribution <br>二项分布</td><td style="text-align: center;"><span class="math inline">\(np\)</span></td><td style="text-align: center;"><span class="math inline">\(np(1-p)\)</span></td></tr><tr class="even"><td style="text-align: center;">Poisson Distribution <br> 泊松分布</td><td style="text-align: center;"><span class="math inline">\(\lambda\)</span></td><td style="text-align: center;"><span class="math inline">\(\lambda\)</span></td></tr><tr class="odd"><td style="text-align: center;">Geometric Distribution <br>几何分布</td><td style="text-align: center;"><span class="math inline">\(\dfrac{1}{p}\)</span></td><td style="text-align: center;"><span class="math inline">\(\dfrac{1-p}{p^2}\)</span></td></tr><tr class="even"><td style="text-align: center;">Hypergeometric Distribution <br>超几何分布</td><td style="text-align: center;"><span class="math inline">\(n\cdot\dfrac{M}{N}\)</span></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">Uniform Distribution <br> 均匀分布</td><td style="text-align: center;"><span class="math inline">\(\dfrac{a+b}{2}\)</span></td><td style="text-align: center;"><span class="math inline">\(\dfrac{(b-a)^2}{12}\)</span></td></tr><tr class="even"><td style="text-align: center;">Exponential Distribution <br>指数分布</td><td style="text-align: center;"><span class="math inline">\(\dfrac{1}{\lambda}\)</span></td><td style="text-align: center;"><span class="math inline">\(\dfrac{1}{\lambda^2}\)</span></td></tr><tr class="odd"><td style="text-align: center;">Normal Distribution <br> 正态分布</td><td style="text-align: center;"><span class="math inline">\(\mu\)</span></td><td style="text-align: center;"><span class="math inline">\(\sigma^2\)</span></td></tr></tbody></table><h1 id="大数定律与中心极限定理">大数定律与中心极限定理</h1><p><strong>依概率收敛</strong>  设 <span class="math inline">\(X_1,\,X_2,\,\cdots,\,X_n,\,\cdots\)</span>是相互独立的一列随机变量，<span class="math inline">\(X\)</span>是一个随机变量，若对任意正数 <span class="math inline">\(\varepsilon\)</span>，有 <span class="math inline">\(\displaystyle\lim_{n\to\infty}P\left(\left|X_n-X\right|\lt\varepsilon\right)=1\)</span>，则称<span class="math inline">\(X_1,\,X_2,\,\cdots,\,X_n,\,\cdots\)</span>依概率收敛于<span class="math inline">\(X\)</span>，通常记作 <span class="math inline">\(X_n\xrightarrow{P}X\)</span>。</p><p><span class="github-emoji"><span>📓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4d3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 人话：做的次数足够大的时候，<span class="math inline">\(X_n\)</span> 和 <span class="math inline">\(X\)</span> 无限接近</p><h2 id="大数定律">大数定律</h2><p>本质：算术平均依概率收敛于统计平均 <span class="math inline">\(\frac{1}{n}\sum_{i=1}^{n}X_i\xrightarrow{P}E\left(\frac{1}{n}\sum_{i=1}^{n}X_i\right)\)</span></p><h2 id="中心极限定理">中心极限定理</h2><p>本质：<span class="math inline">\(n\)</span>个独立同分布的随机变量之和近似服从正态分布。</p><p><strong>Chebyshev 不等式</strong> <span class="math display">\[P\left\{\left|X-E(X)\right|\geq\varepsilon\right\}\leq\frac{D(X)}{\varepsilon^2}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Remarques pour le français</title>
    <link href="/2023/Remarques_Pour_Le_Francais/"/>
    <url>/2023/Remarques_Pour_Le_Francais/</url>
    
    <content type="html"><![CDATA[<h1 id="冠词">冠词</h1><h2 id="不定冠词">不定冠词</h2><table><thead><tr class="header"><th style="text-align: center;">阴性</th><th style="text-align: center;">阳性</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">une</td><td style="text-align: center;">un</td></tr></tbody></table><h2 id="定冠词">定冠词</h2><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">阴性</th><th style="text-align: center;">阳性</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">单数</td><td style="text-align: center;">la</td><td style="text-align: center;">le</td></tr><tr class="even"><td style="text-align: center;">复数</td><td style="text-align: center;">les</td><td style="text-align: center;">les</td></tr></tbody></table><h1 id="疑问句">疑问句</h1><h2 id="一般疑问句">一般疑问句</h2><p><strong>格式</strong>：Est-ce que + (主语) + (谓语) ?</p><h2 id="特殊疑问句">特殊疑问句</h2><p><strong>格式</strong> - Que/Quel + (谓语) + (主语) ? - (主语) +(谓语) + quoi ?</p><p>Que 和 Quel 的区别</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">que</th><th style="text-align: center;">quel</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">词性</td><td style="text-align: center;">疑问代词，从不跟名词</td><td style="text-align: center;">疑问形容词，跟名词（当动词是être的时候除外，隐含从有限个东西里选择的意思）</td></tr><tr class="even"><td style="text-align: center;">提问对象</td><td style="text-align: center;">主谓宾结构</td><td style="text-align: center;">主系表结构</td></tr><tr class="odd"><td style="text-align: center;">例文</td><td style="text-align: center;">Que fait Marie?</td><td style="text-align: center;">Quel est ton nom?</td></tr></tbody></table><p>Que 和 Qu'est-ce que 的区别</p><table><caption>notebook: Qu'est-ce que 主要用于口语中</caption><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">Que</th><th style="text-align: center;">Qu'est-ce que</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">是否倒装</td><td style="text-align: center;">倒装</td><td style="text-align: center;">不倒装</td></tr><tr class="even"><td style="text-align: center;">例文</td><td style="text-align: center;">Que fais-tu ici?</td><td style="text-align: center;">Qu'est-ce que tu fais ici?</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语言学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTeX 常用符号速查手册</title>
    <link href="/2023/LaTeX_Reference_Manual/"/>
    <url>/2023/LaTeX_Reference_Manual/</url>
    
    <content type="html"><![CDATA[<h1 id="希腊字母">希腊字母</h1><p>大写的希腊字母一般是正体，带有 \var命令的则是斜体样式，即下表中标注蓝色的字母，需要在导言区加载 amsmath宏包。</p><p>小写的直立希腊字母，需要 upgreek 或类似字体包，然后前缀加上 “up”即可，如 , 即小写的直立希腊字母。</p><table style="width:100%;"><thead><tr class="header"><th style="text-align: center;">符号</th><th style="text-align: center;"><span class="math inline">\(\LaTeX\)</span></th><th style="text-align: center;">符号</th><th style="text-align: center;"><span class="math inline">\(\LaTeX\)</span></th><th style="text-align: center;">符号</th><th style="text-align: center;"><span class="math inline">\(\LaTeX\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\alpha\)</span></td><td style="text-align: center;">\alpha</td><td style="text-align: center;"><span class="math inline">\(\theta\)</span></td><td style="text-align: center;">\theta</td><td style="text-align: center;"><span class="math inline">\(\omicron\)</span></td><td style="text-align: center;">o</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\beta\)</span></td><td style="text-align: center;">\beta</td><td style="text-align: center;"><span class="math inline">\(\vartheta\)</span></td><td style="text-align: center;">\artheta</td><td style="text-align: center;"><span class="math inline">\(\pi\)</span></td><td style="text-align: center;">\pi</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\gamma\)</span></td><td style="text-align: center;">\gamma</td><td style="text-align: center;"><span class="math inline">\(\iota\)</span></td><td style="text-align: center;">\iota</td><td style="text-align: center;"><span class="math inline">\(\varpi\)</span></td><td style="text-align: center;">\varpi</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\delta\)</span></td><td style="text-align: center;">\delta</td><td style="text-align: center;"><span class="math inline">\(\kappa\)</span></td><td style="text-align: center;">\kappa</td><td style="text-align: center;"><span class="math inline">\(\rho\)</span></td><td style="text-align: center;">\rho</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\epsilon\)</span></td><td style="text-align: center;">\epsilon</td><td style="text-align: center;"><span class="math inline">\(\lambda\)</span></td><td style="text-align: center;">\lambda</td><td style="text-align: center;"><span class="math inline">\(\varrho\)</span></td><td style="text-align: center;">\varrho</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\varepsilon\)</span></td><td style="text-align: center;">\varepsilon</td><td style="text-align: center;"><span class="math inline">\(\mu\)</span></td><td style="text-align: center;">\mu</td><td style="text-align: center;"><span class="math inline">\(\sigma\)</span></td><td style="text-align: center;">\sigma</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\zeta\)</span></td><td style="text-align: center;">\zeta</td><td style="text-align: center;"><span class="math inline">\(\nu\)</span></td><td style="text-align: center;">\nu</td><td style="text-align: center;"><span class="math inline">\(\varsigma\)</span></td><td style="text-align: center;">\varsigma</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\eta\)</span></td><td style="text-align: center;">\eta</td><td style="text-align: center;"><span class="math inline">\(\xi\)</span></td><td style="text-align: center;">\xi</td><td style="text-align: center;"><span class="math inline">\(\tau\)</span></td><td style="text-align: center;">\tau</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\Delta\)</span></td><td style="text-align: center;">\Delta</td><td style="text-align: center;"><span class="math inline">\(\Xi\)</span></td><td style="text-align: center;">\Xi</td><td style="text-align: center;"><span class="math inline">\(\Upsilon\)</span></td><td style="text-align: center;">\Upsilon</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\Theta\)</span></td><td style="text-align: center;">\Theta</td><td style="text-align: center;"><span class="math inline">\(\Pi\)</span></td><td style="text-align: center;">\Pi</td><td style="text-align: center;"><span class="math inline">\(\Phi\)</span></td><td style="text-align: center;">\Phi</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\varGamma\)</span></td><td style="text-align: center;">\varGamma</td><td style="text-align: center;"><span class="math inline">\(\varLambda\)</span></td><td style="text-align: center;">\varLambda</td><td style="text-align: center;"><span class="math inline">\(\varSigma\)</span></td><td style="text-align: center;">\varSigma</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\varDelta\)</span></td><td style="text-align: center;">\varDelta</td><td style="text-align: center;"><span class="math inline">\(\varXi\)</span></td><td style="text-align: center;">\varXi</td><td style="text-align: center;"><span class="math inline">\(\varUpsilon\)</span></td><td style="text-align: center;">\varUpsilon</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\varTheta\)</span></td><td style="text-align: center;">\varTheta</td><td style="text-align: center;"><span class="math inline">\(\varPi\)</span></td><td style="text-align: center;">\varPi</td><td style="text-align: center;"><span class="math inline">\(\varPhi\)</span></td><td style="text-align: center;">\varPhi</td></tr></tbody></table><h1 id="二元关系符">二元关系符</h1><p>所有的二元关系符都可以加 \not 前缀得到相反意义的关系符，例如 \not=就得到不等号（同 \ne）</p><table style="width:100%;"><thead><tr class="header"><th style="text-align: center;">符号</th><th style="text-align: center;"><span class="math inline">\(\LaTeX\)</span></th><th style="text-align: center;">符号</th><th style="text-align: center;"><span class="math inline">\(\LaTeX\)</span></th><th style="text-align: center;">符号</th><th style="text-align: center;"><span class="math inline">\(\LaTeX\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\lt\)</span></td><td style="text-align: center;">\lt</td><td style="text-align: center;"><span class="math inline">\(\gt\)</span></td><td style="text-align: center;">\gt</td><td style="text-align: center;"><span class="math inline">\(=\)</span></td><td style="text-align: center;">=</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\le\)</span></td><td style="text-align: center;">\le or \lep</td><td style="text-align: center;"><span class="math inline">\(\ge\)</span></td><td style="text-align: center;">\ge or \geq</td><td style="text-align: center;"><span class="math inline">\(\equiv\)</span></td><td style="text-align: center;">\equiv</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\ll\)</span></td><td style="text-align: center;">\ll</td><td style="text-align: center;"><span class="math inline">\(\gg\)</span></td><td style="text-align: center;">\gg</td><td style="text-align: center;"><span class="math inline">\(\doteq\)</span></td><td style="text-align: center;">\doteq</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\prec\)</span></td><td style="text-align: center;">\prec</td><td style="text-align: center;"><span class="math inline">\(\succ\)</span></td><td style="text-align: center;">\succ</td><td style="text-align: center;"><span class="math inline">\(\sim\)</span></td><td style="text-align: center;">\sim</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\preceq\)</span></td><td style="text-align: center;">\preceq</td><td style="text-align: center;"><span class="math inline">\(\succeq\)</span></td><td style="text-align: center;">\succeq</td><td style="text-align: center;"><span class="math inline">\(\simeq\)</span></td><td style="text-align: center;">\simeq</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\subset\)</span></td><td style="text-align: center;">\subset</td><td style="text-align: center;"><span class="math inline">\(\supset\)</span></td><td style="text-align: center;">\supset</td><td style="text-align: center;"><span class="math inline">\(\approx\)</span></td><td style="text-align: center;">\approx</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\subseteq\)</span></td><td style="text-align: center;">\subseteq</td><td style="text-align: center;"><span class="math inline">\(\supseteq\)</span></td><td style="text-align: center;">\supseteq</td><td style="text-align: center;"><span class="math inline">\(\cong\)</span></td><td style="text-align: center;">\cong</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\sqsubset\)</span></td><td style="text-align: center;">\sqsubset</td><td style="text-align: center;"><span class="math inline">\(\sqsupset\)</span></td><td style="text-align: center;">\sqsupset</td><td style="text-align: center;"><span class="math inline">\(\Join\)</span></td><td style="text-align: center;">\Join</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\sqsubseteq\)</span></td><td style="text-align: center;">\sqsubseteq</td><td style="text-align: center;"><span class="math inline">\(\sqsupseteq\)</span></td><td style="text-align: center;">\sqsupseteq</td><td style="text-align: center;"><span class="math inline">\(\bowtie\)</span></td><td style="text-align: center;">\bowtie</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\in\)</span></td><td style="text-align: center;">\in</td><td style="text-align: center;"><span class="math inline">\(\ni\)</span></td><td style="text-align: center;">\ni, \owns</td><td style="text-align: center;"><span class="math inline">\(\propto\)</span></td><td style="text-align: center;">\propto</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\vdash\)</span></td><td style="text-align: center;">\vdash</td><td style="text-align: center;"><span class="math inline">\(\dashv\)</span></td><td style="text-align: center;">\dashv</td><td style="text-align: center;"><span class="math inline">\(\models\)</span></td><td style="text-align: center;">\models</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\mid\)</span></td><td style="text-align: center;">\mid</td><td style="text-align: center;"><span class="math inline">\(\parallel\)</span></td><td style="text-align: center;">\parallel</td><td style="text-align: center;"><span class="math inline">\(\perp\)</span></td><td style="text-align: center;">\perp</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\smile\)</span></td><td style="text-align: center;">\smile</td><td style="text-align: center;"><span class="math inline">\(\frown\)</span></td><td style="text-align: center;">\frown</td><td style="text-align: center;"><span class="math inline">\(\asymp\)</span></td><td style="text-align: center;">\asymp</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(:\)</span></td><td style="text-align: center;">:</td><td style="text-align: center;"><span class="math inline">\(\notin\)</span></td><td style="text-align: center;">\notin</td><td style="text-align: center;"><span class="math inline">\(\ne\)</span></td><td style="text-align: center;">\ne or \neq</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>参考手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>参考手册</tag>
      
      <tag>LaTeX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Electric Circuits</title>
    <link href="/2023/Note_Of_Electric_Circuits/"/>
    <url>/2023/Note_Of_Electric_Circuits/</url>
    
    <content type="html"><![CDATA[<h1 id="preface">Preface</h1><p>The post is the note based on the textbook <em>Fundamentals ofElectric Circuits</em> written Charles K. Alexander and Matthew N. O.Sadiku (ISBN: 978-1-260-57079-3)</p><p>Some particular symbols are introduced to describe some properties,as listed below.</p><p><strong>Symbol Table</strong></p><table><thead><tr class="header"><th style="text-align: center;">Symbol</th><th style="text-align: center;">Meaning</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="github-emoji"><span>🎒</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f392.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td style="text-align: center;">Already learned in middle school</td></tr><tr class="even"><td style="text-align: center;"><span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td style="text-align: center;">Key point of some contents</td></tr></tbody></table><p>The post is done individually by <em>Ryker Zhu</em> from <em>NanjingUniversity of Information Science and Technology</em>, published underthe license <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CCBY-NC-SA</a>.<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="CC BY-NC-SA" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"></a></p><h1 id="dc-circuits">DC Circuits</h1><h2 id="basic-concepts">Basic Concepts</h2><h3 id="charge-current">Charge &amp; Current</h3><p><strong><em>Electric Charge</em></strong>: an electrical property ofthe atomic particles of which matter consists, measured in coulombs(<span class="math inline">\(C\)</span>).</p><ul><li>The charge <span class="math inline">\(e\)</span> on an electron isnegative and equal in magnitude to <span class="math inline">\(1.602\times 10^{−19}C\)</span>, while a protoncarries a positive charge of the same magnitude as the electron.</li><li>The only charges that occur in nature are integral multiples of theelectronic charge <span class="math inline">\(e=1.602\times10^{−19}C\)</span></li><li><strong><em>Law of conservation of charge</em></strong> states thatcharge can neither be created nor destroyed, only transferred. Thus, thealgebraic sum of the electric charges in a system does not change.</li></ul><p><strong><em>Electric current</em></strong>: the time rate of changeof charge, measured in amperes (<span class="math inline">\(A\)</span>).The relationship between current <span class="math inline">\(i\)</span>,charge <span class="math inline">\(q\)</span>, and time <span class="math inline">\(t\)</span>&nbsp;is: <span class="math display">\[i\triangleq\frac{dq}{dt}\]</span> The chargetransferred between time <span class="math inline">\(t_0\)</span> and<span class="math inline">\(t\)</span> is obtained by integrating bothsides: <span class="math display">\[Q\triangleq\int^t_{t_0}i\,dt\]</span></p><p>Classification:</p><ul><li><strong><em>Direct Current</em></strong>: a current that flows onlyin one direction and can be constant or time varying. (e.g. <span class="math inline">\(i\left(t\right)=\left|5\sin\left(377t\right)\right|\)</span>whereas <span class="math inline">\(i\left(t\right)\)</span> keepspositive all the time)</li><li><strong><em>Alternating Current</em></strong>: a current thatchanges direction with respect to time. (e.g. <span class="math inline">\(i\left(t\right)=5\sin\left(377t\right)\)</span>)</li></ul><p>Convention:</p><ul><li><span class="math inline">\(I\)</span> - Constant current</li><li><span class="math inline">\(i\)</span> - Current varies with respectto time</li></ul><h3 id="voltage">Voltage</h3><p><strong><em>Voltage</em></strong> (or <strong><em>potentialdifference</em></strong>): the energy required to move a unit&nbsp;chargefrom a reference point (<span class="math inline">\(−\)</span>) toanother point (<span class="math inline">\(+\)</span>), measured&nbsp;in<strong>volts</strong> (<span class="math inline">\(V\)</span>).</p><p><strong><em>Power</em></strong> is the time rate of expending orabsorbing energy, measured in <strong>watts</strong> (<span class="math inline">\(W\)</span>). <span class="math display">\[p\triangleq\frac{dw}{dt}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IELTS Notes</title>
    <link href="/2023/IELTS_Learning/"/>
    <url>/2023/IELTS_Learning/</url>
    
    <content type="html"><![CDATA[<table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">纸笔</th><th style="text-align: center;">机考</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">听力</td><td style="text-align: center;">有10分钟填答题卡</td><td style="text-align: center;">只有2分钟检查答案</td></tr><tr class="even"><td style="text-align: center;">阅读</td><td style="text-align: center;">传统阅读做题方法</td><td style="text-align: center;">机考左半边屏幕是文章，右半边是题目，要用鼠标上下滑动</td></tr><tr class="odd"><td style="text-align: center;">口语</td><td style="text-align: center;">和考官面对面（疫情期间也是和机考一样视频通话）</td><td style="text-align: center;">视频通话，和听力/阅读/写作是同一天</td></tr><tr class="even"><td style="text-align: center;">写作</td><td style="text-align: center;"></td><td style="text-align: center;">字丑的可以机考；打字速度快的同学可以省更多的时间；机考实时显示字数</td></tr><tr class="odd"><td style="text-align: center;">出分时间</td><td style="text-align: center;">13 天后出成绩（周六笔试，下下周周五中午12 点出）</td><td style="text-align: center;">考后第三天下午 14:00 出成绩</td></tr></tbody></table><h1 id="listening">Listening</h1><h2 id="part-1">Part 1</h2><h2 id="part-2">Part 2</h2><h3 id="diagram-labeling">Diagram Labeling</h3><table><thead><tr class="header"><th style="text-align: center;">Element</th><th style="text-align: center;">Level</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>Frequency</em></td><td style="text-align: center;"><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td></tr><tr class="even"><td style="text-align: center;"><em>Difficulty</em></td><td style="text-align: center;"><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td></tr></tbody></table><h1 id="speaking">Speaking</h1><h2 id="part-1-1">Part 1</h2><h2 id="part-2-1">Part 2</h2><h2 id="part-3">Part 3</h2><p><em>Method</em>: Combination of functions listed below.</p><h3 id="functions">Functions</h3><pre><code class=" mermaid">flowchart TB  Functions --- Comparison &amp; Assessment &amp; Explanation &amp; Prediction &amp; Suggestion  Comparison --- Length &amp; Depth &amp; Grammar</code></pre><h4 id="comparison">Comparison</h4><ul><li>Past versus Now<ul><li>used to be... (more/-er), rather than...</li></ul></li><li>Universal<ul><li>There's a big difference...</li></ul></li></ul><h4 id="assessment">Assessment</h4><h4 id="explanation">Explanation</h4><h4 id="prediction">Prediction</h4><ul><li>We will see normal people like you and me / ... becoming</li><li>The chance of ... is slim</li><li>There's every/no possibility that... in xxx years' time.</li></ul><h4 id="suggestion">Suggestion</h4><ul><li>.... seems like it could be a good idea</li><li>it would be great if they/we could...</li></ul><h3 id="steps">Steps</h3><ol type="1"><li>Comment on the question<ul><li>Well, it's a tough question. I've never thought about it.</li></ul></li><li>Locate the keywords (nouns)</li><li>Add more functions (especially<strong><em>Comparison</em></strong>)</li><li>Refer back to the question</li></ol><h2 id="topics">Topics</h2><h3 id="food">Food</h3><pre><code class=" mermaid">classDiagram   class Food{    Color appearance    Taste how    Flavor specified    void cook(methodType)    bool isAffordable()    bool isEasyAccess()    int timeCanBeStored()   }</code></pre><h2 id="practical-sentences">Practical Sentences</h2><table><thead><tr class="header"><th style="text-align: center;">Issue</th><th style="text-align: center;">Answer</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">听不懂</td><td style="text-align: center;">Sorry, could you please rephrase that/say that in other words?</td></tr><tr class="even"><td style="text-align: center;">反应不过来/没听清</td><td style="text-align: center;">I'm sorry, I didn't get/ catch that.Could you say that again/ repeat it?</td></tr><tr class="odd"><td style="text-align: center;">单词不认识</td><td style="text-align: center;">What do you mean by...?</td></tr><tr class="even"><td style="text-align: center;">懂了但是不是很确定</td><td style="text-align: center;">Excuse me, I just want to make sure Iunderstand you fully, do you mean....?</td></tr><tr class="odd"><td style="text-align: center;">听懂</td><td style="text-align: center;">Well, It's a tough question... Let mesee...</td></tr></tbody></table><p>|Agree|Disagree| |||</p><h1 id="reading">Reading</h1><h2 id="fill-in-the-blanks">Fill in the Blanks</h2><h2 id="true-or-false">True or False</h2><h2 id="choice">Choice</h2><p><em>Features</em></p><ol type="1"><li>Sequential</li><li>Details orientated</li></ol><p><em>Testing Points</em></p><ol type="1"><li>Quantity - abstract / concrete</li><li>Time - before, after, today</li><li>Absolute words - all, must, only, every</li><li>Relationship<ul><li>Comparison</li><li>Reasons &amp; Results</li><li>Tendency</li></ul></li></ol><h2 id="matching">Matching</h2><p><em>Categories</em></p><ul><li>Proper noun (Name, Theory)</li><li>Normal noun</li></ul><h3 id="list-of-heading">List of Heading</h3><table><caption>warning: <em>Features</em> 1. 题目顺序</caption><thead><tr class="header"><th style="text-align: center;">Symbol</th><th style="text-align: center;"></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Roman number</td><td style="text-align: center;">Summary of paragraphs/sections</td></tr><tr class="even"><td style="text-align: center;">Matching options</td><td style="text-align: center;">1.5x ~ 2x summaries</td></tr></tbody></table><table><thead><tr class="header"><th style="text-align: center;">纸笔考试</th><th style="text-align: center;">机考</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">题在文<strong>前</strong></td><td style="text-align: center;">左文章右题目</td></tr></tbody></table><ol start="2" type="1"><li>分为 Section 或 Paragraph</li><li>不<strong>复选</strong></li><li>题目可能从<strong>任意段</strong>开始</li></ol><h4 id="steps-1">Steps</h4><ol type="1"><li><em>审题</em>：注意段落<strong>序号</strong>和是否<strong>有例子</strong>（划去）</li><li><em>配对</em><ul><li>关键词对应，通常是出现频率较高的词（可能同义复现或者同义替换）</li><li>主题句对应，前两句 + 末尾句</li><li><span class="github-emoji"><span>💡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 如果看不出，需要阅读全段</li></ul></li></ol><h1 id="writing">Writing</h1><h2 id="format">Format</h2><h2 id="task-1">Task 1</h2><table><thead><tr class="header"><th style="text-align: center;">Item</th><th style="text-align: center;">Requirement</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>Time Limit</em></td><td style="text-align: center;">20 min</td></tr><tr class="even"><td style="text-align: center;"><em>Word Count</em></td><td style="text-align: center;">150 ~ 200 words</td></tr><tr class="odd"><td style="text-align: center;"><em>Score</em></td><td style="text-align: center;">1/3</td></tr></tbody></table><h3 id="dynamic-charts">Dynamic Charts</h3><ol type="1"><li><p>上升</p><ul><li><strong><em>Verb</em></strong>: go up / rise (rose) / increase /grow / climb / ascend</li><li><strong><em>Noun</em></strong>: rise / increase / growth / climb /ascent</li></ul></li><li><p>下降</p><ul><li><strong><em>Verb</em></strong>: go down/ drop (dropped)/ decrease/decline/ fall (fell)/ descend</li><li><strong><em>Noun</em></strong>: drop/ decrease/ decline/ fall/descent</li></ul></li><li><p>急剧地</p><ul><li><strong><em>Adverb</em></strong>: rapidly / sharply / significantly/ dramatically / drastically</li><li><strong><em>Adjective</em></strong>: dramatic/ drastic</li></ul></li><li><p>平缓地</p><ul><li><strong><em>Adverb</em></strong>: insignificantly / slightly /smoothly / modestly</li></ul></li><li><p>急剧地上升</p><p><strong><em>Comparison</em></strong>: soar &amp; surge|Word|Meaning|中文| |:---:|:----:|:---:| |soar|If the amount, value,level, or volume of something soars, it quickly increases by a greatdeal.|急剧增加| |surge|If something surges, it increases suddenly andgreatly, after being steady or developing only slowly|剧增|</p></li><li><p>趋势</p><ul><li><strong><em>Noun</em></strong>: trend/ tendency<ul><li>上升的趋势: an increasing / upward trend</li><li>下降的趋势: a decreasing / downward trend</li></ul></li></ul></li><li><p>稳定</p><ul><li><strong><em>Adjective</em></strong>: stable / steady /unchanged</li><li><strong><em>Verb</em></strong>: stabilize<br></li><li><strong><em>level off / level out</em></strong>: If a changingnumber or amount levels off or levels out, it stops increasing ordecreasing at such a fast speed. 趋向稳定</li></ul></li><li><p>顶点（最大值）</p><ul><li><strong><em>Noun</em></strong>: top / peak / the highest point /maximum<ul><li>达到顶点 reach the peak at + 数据</li></ul></li><li><strong><em>Verb</em></strong>: peak at + 数据</li></ul></li><li><p>底部（最小值）</p></li></ol><ul><li><strong><em>Noun</em></strong>: bottom / minimum / the lowest point<ul><li>达到底部 reach the bottom at + 数据</li></ul></li><li><strong><em>Verb</em></strong>: bottom out (at + 数据)<ul><li>to reach the lowest point and level out 达到最低点并持平</li></ul></li></ul><ol start="11" type="1"><li>超过</li></ol><ul><li><strong><em>Verb</em></strong>: overtake (overtook) / exceed</li></ul><h4 id="line-graphs">Line Graphs</h4><h3 id="static-charts">Static Charts</h3><p>静态图数据描述原则</p><ul><li>从大到小</li><li>相同相近</li><li>倍数关系</li></ul><h4 id="pie-charts">Pie Charts</h4><h3 id="maps-flow-charts">Maps &amp; Flow Charts</h3><h2 id="task-2">Task 2</h2><table><thead><tr class="header"><th style="text-align: center;">Item</th><th style="text-align: center;">Requirement</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>Time Limit</em></td><td style="text-align: center;">40 min</td></tr><tr class="even"><td style="text-align: center;"><em>Word Count</em></td><td style="text-align: center;">250+ words</td></tr><tr class="odd"><td style="text-align: center;"><em>Score</em></td><td style="text-align: center;">2/3</td></tr></tbody></table><h3 id="criteria">Criteria</h3><table><thead><tr class="header"><th style="text-align: center;">Abbr.</th><th style="text-align: center;">Perspective</th><th style="text-align: center;"></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>TR</em></td><td style="text-align: center;">Task Response</td><td style="text-align: center;">切题</td></tr><tr class="even"><td style="text-align: center;"><em>CC</em></td><td style="text-align: center;">Coherence and Cohesion</td><td style="text-align: center;">逻辑</td></tr><tr class="odd"><td style="text-align: center;"><em>LR</em></td><td style="text-align: center;">Lexical Resource</td><td style="text-align: center;">词汇</td></tr><tr class="even"><td style="text-align: center;"><em>GRA</em></td><td style="text-align: center;">Grammatical Range and Accuracy</td><td style="text-align: center;">语法</td></tr></tbody></table><h4 id="lr">LR</h4><ul><li>Sophistication</li><li>Variation - Employ more paraphrasing</li></ul><h4 id="gra">GRA</h4><ul><li>Less grammatical errors</li><li>A variety of complex structures</li></ul><h3 id="argument">Argument</h3><h4 id="agree-or-disagree">Agree or Disagree</h4><table><thead><tr class="header"><th style="text-align: center;">观点 A 与 B 的合理性</th><th style="text-align: center;">我的观点选择</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">矛盾且都合理</td><td style="text-align: center;">A 或 B</td></tr><tr class="even"><td style="text-align: center;">不矛盾且都合理</td><td style="text-align: center;">A 和 B</td></tr><tr class="odd"><td style="text-align: center;">都不合理</td><td style="text-align: center;">C</td></tr><tr class="even"><td style="text-align: center;">只有一方合理</td><td style="text-align: center;">合理的一方</td></tr></tbody></table><h4 id="both-views">Both Views</h4><h4 id="mixed">Mixed</h4>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>英语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物理笔记</title>
    <link href="/2023/Note_Of_Physics/"/>
    <url>/2023/Note_Of_Physics/</url>
    
    <content type="html"><![CDATA[<h1 id="preface">Preface</h1><p>The post is the note based on the textbook <em>Fundamentals ofPhysics</em> written by David Halliday, Robert Resnick and Jearl Walker(ISBN: 978-1-118-23072-5)</p><p>Some particular symbols are introduced to describe some properties,as listed below.</p><p><strong>Symbol Table</strong></p><table><thead><tr class="header"><th style="text-align: center;">Symbol</th><th style="text-align: center;">Meaning</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="github-emoji"><span>🎒</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f392.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td style="text-align: center;">Already learned in middle school</td></tr><tr class="even"><td style="text-align: center;"><span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td style="text-align: center;">Key point of some contents</td></tr></tbody></table><p>The post is done individually by <em>Ryker Zhu</em> from <em>NanjingUniversity of Information Science and Technology</em>, published underthe license <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CCBY-NC-SA</a>.<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="CC BY-NC-SA" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"></a></p><h1 id="measurement">Measurement</h1><table><caption>school_satchel: <strong>International System of Units</strong>(Français: Système international d'unités) (Abbr. <strong>SI</strong>),i.e. <strong>metric system</strong>.</caption><thead><tr class="header"><th style="text-align: center;">Symbol</th><th style="text-align: center;">Name</th><th style="text-align: center;">Quantity</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(s\)</span></td><td style="text-align: center;">second</td><td style="text-align: center;">time</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(m\)</span></td><td style="text-align: center;">meter</td><td style="text-align: center;">length</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(kg\)</span></td><td style="text-align: center;">kilogram</td><td style="text-align: center;">mass</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(A\)</span></td><td style="text-align: center;">ampere</td><td style="text-align: center;">electric current</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(K\)</span></td><td style="text-align: center;">kelvin</td><td style="text-align: center;">thermodynamic temperature</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(mol\)</span></td><td style="text-align: center;">mole</td><td style="text-align: center;">amount of substance</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(cd\)</span></td><td style="text-align: center;">candela</td><td style="text-align: center;">luminous intensity</td></tr></tbody></table><h1 id="motion">Motion</h1><h2 id="vector-scalar">Vector &amp; Scalar</h2><pre><code class=" mermaid">flowchart LR  A(Physical Quantities) --- B(Vector Quantities) &amp; C(Scalars)  B --- D(Magnitude) &amp; E(Direction)</code></pre><p><span class="github-emoji"><span>🎒</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f392.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong><em>Component</em></strong>: Projection ofthe vector on an axis.</p><ul><li>Vector component : <span class="math inline">\(a_x\hat{i},\,a_y\hat{j}\)</span></li><li>(Scalar) component : <span class="math inline">\(a_x,\,a_y\)</span></li></ul><p><span class="github-emoji"><span>🎒</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f392.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong><em>Scalar Product</em></strong> or<strong><em>Dot Product</em></strong>: spoken as "a dot b" <span class="math display">\[\vec{a}\cdot\vec{b}=a\cdot b \cos\phi\]</span><span class="math inline">\(a\)</span> - magnitude of the vector <span class="math inline">\(\vec{a}\)</span>;<br><span class="math inline">\(\phi\)</span> - angle between <span class="math inline">\(\vec{a}\)</span> and <span class="math inline">\(\vec{b}\)</span>.</p><p><strong><em>Vector Product</em></strong> or <strong><em>CrossProduct</em></strong>: spoken as "a cross b"</p><ul><li><p>Magnitude</p><p><span class="math display">\[c=a\cdot b \sin\phi\]</span> <span class="math inline">\(c\)</span> - magnitude of the vector <span class="math inline">\(\vec{c}\)</span>;<br><span class="math inline">\(\phi\)</span> - <em>smaller</em> of the twoangles between <span class="math inline">\(\vec{a}\)</span> and <span class="math inline">\(\vec{b}\)</span>.</p></li><li><p>Direction</p><p>Perpendicular to the plane containing <span class="math inline">\(\vec{a}\)</span> and <span class="math inline">\(\vec{b}\)</span>.<br>Determine with <strong>right-hand rule</strong>, right-hand fingers swap<span class="math inline">\(\vec{a}\)</span> into <span class="math inline">\(\vec{b}\)</span>.</p></li></ul><h2 id="position-and-displacement">Position and Displacement</h2><p><span class="github-emoji"><span>🎒</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f392.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong><em>Kinematics</em></strong>:(<em>/,kɪnɪ'mætɪks/</em> or <em>/kaɪnə'mætɪks]/</em>) Classification andcomparison of motions.</p><p><span class="github-emoji"><span>🎒</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f392.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong><em>Particle</em></strong>: Point-likeobject</p><h3 id="projectile-motion">Projectile Motion</h3><blockquote><p>A particle moves in a vertical plane with some initial velocity, butits acceleration is always the free-fall acceleration, which isdownward.</p><p>Such a particle is called <strong><em>projectile</em></strong><em>/prəˈdʒektaɪl/</em> and its motion is called <strong><em>projectilemotion</em></strong>.</p></blockquote><p>Horizontal Motion: <span class="math display">\[x-x_0=v_{0x}t=\left(v_0\cos\theta_0\right)t\]</span>Vertical Motion: <span class="math display">\[y-y_0=v_{0y}-\frac{1}{2}gt^2\]</span></p><p>The Equation of the Path (<strong><em>Trajectory</em></strong><em>/trəˈdʒektəri/</em>): <span class="math display">\[y=\left(\tan\theta_0\right)x-\frac{g}{2\left(v_0\cos\theta_0\right)^2}x^2\]</span>The equation is also the one of <strong><em>parabola</em></strong><em>/pəˈræbələ/</em> so the path is parabolic.</p><h1 id="force">Force</h1><blockquote><p><strong><em>Newtonian Mechanics</em></strong>: The relation between aforce and the acceleration it causes</p></blockquote><h2 id="school_satchel-newtons-three-primary-laws-of-motion"><span class="github-emoji"><span>🎒</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f392.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>Newton's three primary laws of motion</h2><p><strong><em>Net Force</em></strong> or <strong><em>ResultantForce</em></strong>: Adding all forces acted on the same body</p><p><strong><em>Principle of superposition for forces</em></strong>: Asingle force that has the same magnitude and direction as the calculatednet force would then have the same effect as all the individualforces.</p><p><span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> Newton's laws is not always true unless in<strong><em>inertial</em></strong> <em>/ɪˈnɜːʃl/</em><strong><em>reference frames</em></strong>.</p><h3 id="newtons-first-law">Newton’s First Law</h3><blockquote><p>If no net force acts on a body (<span class="math inline">\(\overrightarrow{F_\mathrm{net}}=0\)</span>), thebody’s velocity cannot change; that is, the body cannot accelerate.</p></blockquote><h3 id="newtons-second-law">Newton’s Second Law</h3><blockquote><p>The net force on a body is equal to the product of the body’s massand its acceleration.</p><p><span class="math display">\[\overrightarrow{F_\mathrm{net}}=m\vec{a}\]</span></p></blockquote><p><span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> The acceleration component along a given axis is causedonly by the sum of the force components along that same axis, and not byforce components along any other axis.</p><p><strong><em>Forces in Equilibrium</em></strong>: Any forces on thebody balance one another, and both the forces and the body are said tobe in <strong><em>equilibrium</em></strong> (<em>/ˌiːkwɪˈlɪbriəm/</em>or <em>/ˌekwɪˈlɪbriəm/</em>).</p><h3 id="newtons-third-law">Newton’s Third Law</h3><blockquote><p>When two bodies interact, the forces on the bodies from each otherare always equal in magnitude and opposite in direction.</p></blockquote><h3 id="particular-forces">Particular Forces</h3><h4 id="school_satchel-normal-force"><span class="github-emoji"><span>🎒</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f392.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong><em>NormalForce</em></strong></h4><p>When a body presses against a surface, the surface (even a seeminglyrigid one) deforms and pushes on the body with a normal force <span class="math inline">\(\overrightarrow{F_N}\)</span> that isperpendicular to the surface.</p><h4 id="school_satchel-frictional-force"><span class="github-emoji"><span>🎒</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f392.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong><em>Frictional force</em></strong></h4><p>The force on a body when the body slides or attempts to slide along asurface. The force is always parallel to the surface and directed so asto oppose the sliding. On a frictionless surface, the frictional forceis negligible.</p><ul><li>If the body does not slide, the frictional force <span class="math inline">\(f_s\)</span> is a <strong><em>static frictionalforce</em></strong>.<ul><li>The magnitude of <span class="math inline">\(f_s\)</span> has amaximum value <span class="math inline">\(f_{s,max}\)</span> given by<span class="math display">\[f_{s,max}=\mu_sF_N\]</span><ul><li><span class="math inline">\(\mu_s\)</span> - <strong><em>coefficientof static friction</em></strong></li><li><span class="math inline">\(F_N\)</span> - magnitude of the normalforce.</li></ul></li></ul></li><li>If there is sliding, the frictional force is a <strong><em>kineticfrictional force</em></strong>.<ul><li>The magnitude of the frictional force rapidly decreases to aconstant value <span class="math inline">\(f_k\)</span> given by <span class="math display">\[f_k=\mu_kF_N\]</span><ul><li><span class="math inline">\(\mu_k\)</span> - <strong><em>coefficientof kinetic friction</em></strong></li></ul></li></ul></li></ul><h4 id="drag-force"><strong><em>Drag Force</em></strong></h4><p>When there is relative motion between air (or some other fluid) and abody, the body experiences a drag force <span class="math inline">\(\vec{D}\)</span> that opposes the relative motionand points in the direction in which the fluid flows relative to thebody.</p><p>The magnitude of D: <span class="math display">\[D=\frac{1}{2}C\rhoAv^2\]</span> - <span class="math inline">\(C\)</span> - anexperimentally determined drag coefficient - <span class="math inline">\(\rho\)</span> - the fluid density (mass per unitvolume) - <span class="math inline">\(A\)</span> - the effectivecross-sectional area of the body (the area of a cross section takenperpendicular to the relative velocity <span class="math inline">\(\vec{v}\)</span>).</p><h1 id="energy-work">Energy &amp; Work</h1><h1 id="center-of-mass-linear-momentum">Center of Mass &amp; LinearMomentum</h1><h1 id="rotation-angular-momentum">Rotation &amp; Angular Momentum</h1><h1 id="gravitation">Gravitation</h1><h1 id="oscillations">Oscillations</h1><h1 id="waves">Waves</h1><h1 id="the-kinetic-theory-of-gases">The Kinetic Theory of Gases</h1><h1 id="the-law-of-thermodynamics">The Law of Thermodynamics</h1><h1 id="electricity">Electricity</h1><h1 id="gausss-law">Gauss's Law</h1><h1 id="dc-circuits">DC Circuits</h1><h1 id="magnetic-fields">Magnetic Fields</h1><h1 id="magnetic-fields-due-to-currents">Magnetic Fields Due toCurrents</h1><h1 id="induction-inductance">Induction &amp; Inductance</h1><h1 id="electromagnetic-oscillations-alternating-current">ElectromagneticOscillations &amp; Alternating Current</h1><h1 id="maxwells-equations-magnetism-of-matter">Maxwell's Equations;Magnetism of Matter</h1><h1 id="electromagnetic-waves">Electromagnetic Waves</h1><h1 id="optics">Optics</h1><h1 id="relativity">Relativity</h1><h1 id="quantum-physics">Quantum Physics</h1><h1 id="conduction-of-electricity-in-solids">Conduction of Electricityin Solids</h1>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>物理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高等数学笔记</title>
    <link href="/2023/Note_Of_Advanced_Mathematics/"/>
    <url>/2023/Note_Of_Advanced_Mathematics/</url>
    
    <content type="html"><![CDATA[<p>对于考研数学（数学一）而言，高等数学约占60%，考研数学整张卷子一共10个选择题、6个填空题、6个解答题。</p><h1 id="极限">极限</h1><p>极限（Limit）研究函数在 <strong>某一个小区间</strong>上的各种性质。</p><blockquote><p>趋向常数时的函数极限：<span class="math inline">\(\forall\varepsilon&gt;0,\,\exists\delta&gt;0,\,0&lt;\left|x-x_0\right|&lt;\delta,\,\left|f\left(x\right)-A\right|&lt;\varepsilon\Rightarrow\displaystyle\lim_{x\to{x_0}}{f\left(x\right)}=A\)</span></p></blockquote><blockquote><p>趋向无穷时的函数极限：<span class="math inline">\(\forall\varepsilon&gt;0,\,\exists{X}&gt;0,\,\left|x\right|&gt;X,\,\left|f\left(x\right)-A\right|&lt;\varepsilon\Rightarrow\displaystyle\lim_{x\to{\infty}}{f\left(x\right)}=A\)</span></p></blockquote><p><span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>注意</strong></p><ul><li><p><span class="math inline">\(\displaystyle\lim_{x\to{x_0}}{f\left(x\right)}\)</span>是否存在与<span class="math inline">\(f\left(x_0\right)\)</span>无关</p></li><li><p>充要条件：左右极限相等时，函数极限存在；反之亦然</p><p><span class="math inline">\(\displaystyle\lim_{x\to{x_0^+}}{f\left(x\right)}=\lim_{x\to{x_0^-}}{f\left(x\right)}=A\Leftrightarrow\lim_{x\to{x_0}}{f\left(x\right)}=A\)</span></p><p><span class="math inline">\(\displaystyle\lim_{x\to{+\infty}}{f\left(x\right)}=\lim_{x\to{-\infty}}{f\left(x\right)}=A\Leftrightarrow\lim_{x\to{\infty}}{f\left(x\right)}=A\)</span></p></li><li><p>极限定义的变体</p><ul><li>更改极限定义中的小于号为小于等于号 <strong>不影响</strong>最终极限的表达，即以下两种是可以相互替换的：<ul><li><span class="math inline">\(0&lt;\left|x-x_0\right|&lt;\delta\Leftrightarrow0&lt;\left|x-x_0\right|\leq\delta\)</span></li><li><span class="math inline">\(\left|f\left(x\right)-A\right|&lt;\varepsilon\Leftrightarrow\left|f\left(x\right)-A\right|\leq\varepsilon\)</span></li></ul></li><li>极限定义中的<span class="math inline">\(\varepsilon\)</span>可以换成任意表达式，只要<ol type="1"><li>表达式 <strong>结果为正</strong>（例如： <span class="math inline">\(\forall{\gamma&gt;0},\,\left|f\left(x\right)-A\right|&lt;\frac1{\gamma}\)</span>）</li><li>表达式可以 <strong>取到任意小的正数</strong></li></ol></li></ul></li></ul><h2 id="极限的性质">极限的性质</h2><ol type="1"><li><p>唯一性 （常常用来证明）</p><p>函数极限存在，则只能存在唯一的值，否则就是不存在。</p></li><li><p>局部有界性</p><p>在某个小区域内，函数有界。</p><blockquote><p><span class="math inline">\(\displaystyle\lim_{x\to{x_0}}{f\left(x\right)}=A\Rightarrow\exists{\delta,M&gt;0},\,0&lt;\left|x-x_0\right|&lt;\delta,\,\left|f\left(x\right)\right|\leq{M}\)</span></p></blockquote></li><li><p>局部保号性（可以用来证明 <span class="math inline">\(Fermat\)</span> 引理，经常与极值、拐点结合）</p><p>在某个小区域内，函数值的符号与极限值的符号一致。</p><blockquote><p><span class="math inline">\(\displaystyle\lim_{x\to{x_0}}{f\left(x\right)}=A\Rightarrow\exists{\delta&gt;0},\,0&lt;\left|x-x_0\right|&lt;\delta,\)</span><span class="math inline">\(\left \{\begin{array}{l}A&gt;0\Rightarrow{f\left(x\right)&gt;0}\\f\left(x\right)\geq0\Rightarrow{A\geq0}\end{array}\right.\)</span></p></blockquote></li></ol><h2 id="极限的求法">极限的求法</h2><h3 id="夹逼准则">夹逼准则</h3><blockquote><p>设函数 <span class="math inline">\(f\left(x\right),\,g\left(x\right),\,h\left(x\right)\)</span>满足：</p><ol type="1"><li><span class="math inline">\(\exists{\mathring{U}\left(x_0,\delta\right)}\)</span>，有<span class="math inline">\(g\left(x\right)\leq f\left(x\right)\leqh\left(x\right)\)</span></li><li><span class="math inline">\(\displaystyle\lim_{x\tox_0}g\left(x\right)=\lim_{x\to x_0}h\left(x\right)=A\)</span></li></ol><p>则 <span class="math inline">\(\displaystyle\lim_{x\tox_0}f\left(x\right)=A\)</span></p></blockquote><p>特点：不好求极限但是好放缩（如 <span class="math inline">\(x^2+y^2\geq2xy\)</span>）<br>当式子放大之后为0，则要想到给式子加绝对值</p><h3 id="单调有界收敛准则">单调有界收敛准则</h3><p>单调有界数列必有极限（单调增数列有上界必收敛）</p><p>证明数列单调的常用方法：</p><ul><li><p><span class="math inline">\(x_{n+1}-x_n\geq 0\;\left(\leq0\right)\)</span></p></li><li><p><span class="math inline">\(\displaystyle\frac{x_{n+1}}{x_n}\geq1\;\left(\leq 1\right)\)</span></p></li><li><p>数学归纳法</p></li><li><p><span class="math inline">\(x_{n+1}=f\left(x_n\right)\)</span></p><pre><code class=" mermaid">flowchart TB  函数可导 ---|导函数| 恒大于零 &amp; 恒小于零  恒小于零 --- 数列不具有单调性   恒大于零 ---|前两个元素| 单调增 &amp; 单调减</code></pre></li></ul><h2 id="无穷小">无穷小</h2><h3 id="无穷小的运算性质">无穷小的运算性质</h3><ol type="1"><li>有限个无穷小的乘积仍为无穷小</li><li>有限个无穷小的和仍为无穷小</li><li>有界函数与无穷小的乘积仍为无穷小</li></ol><h3 id="等价无穷小">等价无穷小</h3><p><span class="math inline">\(\begin{array}{l}\sin{x} \sim x&amp;\tan{x} \sim x \\[0.5em] \arcsin{x} \sim x &amp;\arctan{x} \sim x\\[0.5em] \ln{\left(x+\sqrt{1+x^2}\right)} \sim x&amp;\ln{\left(1+x\right)} \sim x &amp;e^x-1 \sim x \\[0.5em] \\\left(1+x\right)^\alpha \sim \alpha x+1 &amp;\log_a{(1+x)} \sim\frac{x}{\ln{a}} \\[0.5em] \\ x-\ln{\left(1+x\right)} \sim\frac{1}{2}x^2 &amp;1-\cos{x} \sim \frac{1}{2}x^2 \\[0.5em] \\\tan{x}-\sin{x} \sim \frac{1}{2}x^3 \\[0.5em] \tan{x}-x \sim\frac{1}{3}x^3 &amp; x-\arctan{x} \sim \frac{1}{3}x^3 \\[0.5em]x-\sin{x} \sim \frac{1}{6}x^3 &amp;\arcsin{x}-x \sim\frac{1}{6}x^3\end{array}\)</span></p><h2 id="极限的运算">极限的运算</h2><h3 id="无穷小的运算性质-1">无穷小的运算性质</h3><ol type="1"><li>有限个无穷小之和/积仍为无穷小</li><li>有界函数与无穷小的积仍为无穷小</li></ol><h3 id="多项式比值的极限求法">多项式比值的极限求法</h3><blockquote><p><span class="math inline">\(\displaystyle\lim_{x\to\infty}{\frac{a_0x^m+a_1x^{m-1}+\cdots+a_{m-1}x+a_m}{b_0x^n+b_1x^{n-1}+\cdots+b_{n-1}x+b_n}}\left(a_0,b_0\neq0\right)=\lim_{x\to\infty}{\frac{a_0x^m}{b_0x^n}}\)</span><span class="math inline">\(=\left\{\begin{array}{ll}\frac{a_0}{b_0}&amp;m=n\\\infty&amp;m&gt;n\\0&amp;m&lt;n\end{array}\right.\)</span></p></blockquote><h3 id="未定式极限的求法">未定式极限的求法</h3><ul><li><p><span class="math inline">\(\frac{\infty}{\infty}\)</span>、<span class="math inline">\(\frac{0}{0}\)</span> 型 利用 <span class="math inline">\(L'H\hat{o}pital\)</span> 法则</p></li><li><p><span class="math inline">\(0\cdot\infty\)</span> 型</p></li><li><p><span class="math inline">\(\infty-\infty\)</span> 型</p></li><li><p><span class="math inline">\({f\left(x\right)}^{g\left(x\right)}\)</span>型（<span class="math inline">\(1^\infty\)</span>、<span class="math inline">\(0^0\)</span>、<span class="math inline">\(\infty^0\)</span>）</p><p>利用对数恒等式 <span class="math inline">\({f\left(x\right)}^{g\left(x\right)}=e^{g\left(x\right)\ln{f\left(x\right)}}\)</span> 转换表达式</p></li></ul><h2 id="连续">连续</h2><p>函数的连续性 (Continuity):</p><blockquote><p><span class="math inline">\(f\left(x\right)\)</span> 在 <span class="math inline">\(x_0\)</span> 处连续 <span class="math inline">\(\Leftrightarrow\displaystyle\lim_{\Delta x\to0}\Delta y=0\)</span> <span class="math inline">\(\displaystyle\Leftrightarrow\lim_{\Delta x\to0}f\left(x_0+\Delta x\right)-f\left(x_0\right)=0\)</span> <span class="math inline">\(\displaystyle\Leftrightarrow\lim_{x\to{x_0}}f\left(x\right)=f\left(x_0\right)\)</span></p></blockquote><h3 id="间断点">间断点</h3><ul><li>第 <span class="math inline">\(\mathrm{I}\)</span> 类间断点：<span class="math inline">\(\displaystyle\lim_{x\tox_0^+}f\left(x\right)\)</span> 与 <span class="math inline">\(\displaystyle\lim_{x\tox_0^-}f\left(x\right)\)</span> 均存在<ul><li><span class="math inline">\(\displaystyle\lim_{x\tox_0^+}f\left(x\right)=\lim_{x\to x_0^-}f\left(x\right)\neqf\left(x_0\right)\)</span>（或 <span class="math inline">\(f\left(x_0\right)\)</span> 不存在），则 <span class="math inline">\(x=x_0\)</span> 为<strong>可去间断点</strong></li><li><span class="math inline">\(\displaystyle\lim_{x\tox_0^+}f\left(x\right)\neq\lim_{x\to x_0^-}f\left(x\right)\)</span>，则<span class="math inline">\(x=x_0\)</span>为<strong>跳跃间断点</strong></li></ul></li><li>第 <span class="math inline">\(\mathrm{II}\)</span> 类间断点：<span class="math inline">\(\displaystyle\lim_{x\tox_0^+}f\left(x\right)\)</span> 与 <span class="math inline">\(\displaystyle\lim_{x\tox_0^-}f\left(x\right)\)</span> 至少有其中之一不存在</li></ul><h3 id="闭区间上连续函数的性质">闭区间上连续函数的性质</h3><h4 id="有界性与最值定理">有界性与最值定理</h4><p>设函数 <span class="math inline">\(f\left(x\right)\)</span> 在闭区间<span class="math inline">\(\left[a,\,b\right]\)</span> 上连续，则 <span class="math inline">\(f\left(x\right)\)</span>在该区间上有界，且必可取到最大值与最 小值。</p><h4 id="零点存在性定理">零点存在性定理</h4><p>设函数 <span class="math inline">\(f\left(x\right)\)</span> 在闭区间<span class="math inline">\(\left[a,\,b\right]\)</span> 上连续，且 <span class="math inline">\(f\left(a\right)\cdot f\left(b\right)\lt0\)</span>，则 <span class="math inline">\(\exists\xi\in\left[a,\,b\right]\)</span> 使得<span class="math inline">\(f\left(\xi\right)=0\)</span></p><h4 id="介值定理">介值定理</h4><p>设函数 <span class="math inline">\(f\left(x\right)\)</span> 在闭区间<span class="math inline">\(\left[a,\,b\right]\)</span> 上连续，<span class="math inline">\(f\left(x\right)_{\mathrm{min}}\leq\mu\leqf\left(x\right)_{\mathrm{max}}\)</span>，则 <span class="math inline">\(\exists\xi\in\left[a,\,b\right]\)</span> 使得<span class="math inline">\(f\left(\xi\right)=\mu\)</span></p><h2 id="两个重要极限">两个重要极限</h2><p><span class="math display">\[\lim_{x\to 0}\frac{\sinx}{x}=1\qquad\lim_{x\to\infty}\left(1+\frac{1}{x}\right)^{x}=e\]</span></p><h1 id="导数">导数</h1><p><span class="math display">\[\displaystylef^\prime\left(x_0\right)=\lim_{x\rightarrowx_0}{\frac{f\left(x\right)-f\left(x_0\right)}{x-x_0}}=\lim_{\Deltax\rightarrow0}{\frac{f\left(x_0+\Deltax\right)-f\left(x_0\right)}{\Delta x}}\]</span></p><p>Derivative</p><h2 id="高阶导数">高阶导数</h2><p><span class="math inline">\(Leibniz\)</span> 公式 <span class="math display">\[\left(uv\right)^{\left(n\right)}=\sum_{k=0}^{n}{C_n^ku^{\left(n-k\right)}v^{\left(k\right)}}\]</span></p><h2 id="参数方程求导">参数方程求导</h2><p><span class="math display">\[\frac{dy}{dx}=\frac{\frac{dy}{dt}}{\frac{dx}{dt}}\qquad\frac{d^2y}{dx^2}=\frac{d\left(\frac{dy}{dx}\right)}{dx}=\frac{\frac{d\left(\frac{dy}{dx}\right)}{dt}}{\frac{dx}{dt}}\]</span></p><h2 id="fermat-引理"><span class="math inline">\(Fermat\)</span>引理</h2><p>可导函数的每一个可导的极值点都是驻点</p><blockquote><p>设函数 <span class="math inline">\(f\left(x\right)\)</span> 在点<span class="math inline">\(x_0\)</span> 的某邻域 <span class="math inline">\(U\left(x_0\right)\)</span> 内有定义，并且在 <span class="math inline">\(x_0\)</span> 处可导，如果对<span class="math inline">\(\forall{x\in{U\left(x_0\right)}}\)</span>，有<span class="math inline">\(f\left(x\right)\leqf\left(x_0\right)\)</span>（或<span class="math inline">\(f\left(x\right)\geqf\left(x_0\right)\)</span>），那么<span class="math inline">\(f^\prime\left(x_0\right)=0\)</span></p></blockquote><h2 id="导数的应用">导数的应用</h2><h1 id="微分">微分</h1><p>Differential</p><h2 id="一元函数微分学">一元函数微分学</h2><h3 id="微分中值定理">微分中值定理</h3><h4 id="rolle-中值定理"><span class="math inline">\(Rolle\)</span>中值定理</h4><ul><li><p>条件</p><ul><li>函数 <span class="math inline">\(f\left(x\right)\)</span> 在 <span class="math inline">\(\left[a,\ b\right]\)</span> 上连续</li><li>函数 <span class="math inline">\(f\left(x\right)\)</span> 在 <span class="math inline">\(\left(a,\ b\right)\)</span> 上可导</li><li><span class="math inline">\(f\left(a\right)=f\left(b\right)\)</span></li></ul></li><li><p>结论</p><p><span class="math inline">\(\exists\xi\in\left(a,\,b\right)\)</span>，使得<span class="math inline">\(f^\prime\left(\xi\right)=0\)</span></p></li></ul><h5 id="bulb-题型一多次使用-rolle-中值定理以证明高阶导数为零"><span class="github-emoji"><span>💡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>题型一：多次使用 <span class="math inline">\(Rolle\)</span>中值定理以证明高阶导数为零</h5><p><strong>原理</strong>：证明 <span class="math inline">\(n\)</span>阶导为零需要 <span class="math inline">\(n+1\)</span>个函数值相等的点，使用 <span class="math inline">\(n\)</span> 次 <span class="math inline">\(Rolle\)</span> 中值定理。</p><h5 id="bulb-题型二找到辅助函数-fleftxright-以证明"><span class="github-emoji"><span>💡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>题型二：找到辅助函数 <span class="math inline">\(F\left(x\right)\)</span> 以证明</h5><p><strong>原理</strong>：还原题目所要证明的函数是找到辅助函数的关键。</p><p>常用的还原公式</p><table><thead><tr class="header"><th style="text-align: center;">形式</th><th style="text-align: center;">还原后</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(u^\prime\left(x\right)\pmv^\prime\left(x\right)\)</span></td><td style="text-align: center;"><span class="math inline">\(u\left(x\right)\pm v\left(x\right)\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(u^\prime\left(x\right) v\left(x\right)\pmu\left(x\right)v^\prime\left(x\right)\)</span></td><td style="text-align: center;"><span class="math inline">\(u\left(x\right)v\left(x\right)\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\displaystyle\frac{u^\prime\left(x\right)v\left(x\right)-u\left(x\right)v^\prime\left(x\right)}{v^2\left(x\right)}\)</span></td><td style="text-align: center;"><span class="math inline">\(\displaystyle\frac{u\left(x\right)}{v\left(x\right)}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\displaystyle\frac{u^\prime\left(x\right)}{u\left(x\right)}\)</span></td><td style="text-align: center;"><span class="math inline">\(\lnu\left(x\right)\)</span></td></tr></tbody></table><p>通常题干中要求证明的式子会约去一个因子，利用还原公式和适当地添加公因子就能得到最终的辅助函数。</p><h4 id="lagrange-中值定理"><span class="math inline">\(Lagrange\)</span>中值定理</h4><ul><li><p>条件</p><ul><li>函数 <span class="math inline">\(f\left(x\right)\)</span> 在 <span class="math inline">\(\left[a,\ b\right]\)</span> 上连续</li><li>函数 <span class="math inline">\(f\left(x\right)\)</span> 在 <span class="math inline">\(\left(a,\ b\right)\)</span> 上可导</li></ul></li><li><p>结论</p><p><span class="math inline">\(\exists\xi\in\left(a,\,b\right)\)</span>，使得<span class="math inline">\(\displaystylef^\prime\left(\xi\right)=\frac{f\left(b\right)-f\left(a\right)}{b-a}\)</span>（或 <span class="math inline">\(f\left(b\right)-f\left(a\right)=\left(b-a\right)f^\prime\left(a+\theta\left(b-a\right)\right)\;\left(0\lt\theta\lt1\right)\)</span>）</p></li><li><p>推论</p><p><span class="math display">\[f\left(x\right)\equiv C\Rightarrowf^\prime\left(x\right)\equiv 0\]</span></p></li><li><p>证明</p><p>利用 <span class="math inline">\(Rolle\)</span>中值定理证明。首先应当找到辅助函数，易得 <span class="math inline">\(F\left(x\right)=\left(f\left(b\right)-f\left(a\right)\right)x-\left(b-a\right)f\left(x\right)\)</span>，并有：<span class="math display">\[\left\{\begin{array}{l}F\left(a\right)=af\left(b\right)-bf\left(a\right)\\F\left(b\right)=af\left(b\right)-bf\left(a\right)\end{array}\right.\RightarrowF\left(a\right)=F\left(b\right)\]</span> 又 <span class="math inline">\(\because F\left(x\right)\inC\left[a,\,b\right]\)</span> 且 <span class="math inline">\(F\left(x\right)\)</span> 在 <span class="math inline">\(\left(a,\,b\right)\)</span> 上可导，<span class="math inline">\(\therefore\exists\xi\in\left(a,\ b\right)\)</span>使得 <span class="math inline">\(F^\prime\left(\xi\right)=0\)</span> 即<span class="math inline">\(f\left(b\right)-f\left(a\right)-\left(b-a\right)f^\prime\left(\xi\right)=0\)</span>，移项后得<span class="math inline">\(\displaystylef^\prime\left(\xi\right)=\frac{f\left(b\right)-f\left(a\right)}{b-a}\)</span>，得证。</p></li><li><p>作用</p><ul><li>升高导数的阶数</li><li>化简求极限的过程<ul><li>例：<span class="math inline">\(\displaystyle\lim_{x\to\infty}n^2\left(\arctan\frac\pin-\arctan\frac\pi{n+1}\right)\)</span> = <span class="math inline">\(\displaystyle\lim_{x\to\infty}\frac{\pin^2}{n\left(n+1\right)}\cdot\frac{1}{1+\xi^2}=\pi\lim_{\xi\to0}\frac{1}{1+\xi^2}=\pi\)</span></li></ul></li><li>证明不等式<ul><li>例：证明 <span class="math inline">\(\displaystyle\forall n\in\mathrm{N^+},\,\frac{1}{n+1}\lt\ln{\left(1+\frac{1}{n}\right)}\lt\frac{1}{n}\)</span><br><span class="math inline">\(\displaystyle\ln{1+\frac{1}{n}}=\ln{\frac{n+1}{n}}=\ln{\left(n+1\right)}-\ln{n}\)</span>。令<span class="math inline">\(f\left(x\right)=\ln{x}\)</span>，在 <span class="math inline">\(\left[n,\,n+1\right]\)</span> 上连续，在 <span class="math inline">\(\left(n,\,n+1\right)\)</span> 上可导。故 <span class="math inline">\(\displaystyle\ln{\left(1+\frac{1}{n}\right)}=\left(n+1-n\right)\cdot\frac{1}{\xi}=\frac{1}{\xi},\;\xi\in\left(n,\,n+1\right)\)</span>，从而<span class="math inline">\(\displaystyle\frac{1}{n+1}\lt\frac{1}{\xi}\lt\frac{1}{n}\)</span></li></ul></li></ul></li></ul><h4 id="cauchy-中值定理"><span class="math inline">\(Cauchy\)</span>中值定理</h4><ul><li><p>条件</p><ul><li>函数 <span class="math inline">\(f\left(x\right),\,g\left(x\right)\)</span> 在<span class="math inline">\(\left[a,\ b\right]\)</span> 上连续</li><li>函数 <span class="math inline">\(f\left(x\right),\,g\left(x\right)\)</span> 在<span class="math inline">\(\left[a,\ b\right]\)</span> 在 <span class="math inline">\(\left(a,\ b\right)\)</span> 上可导</li><li><span class="math inline">\(g^\prime\left(x\right)\neq0\)</span></li></ul></li><li><p>结论</p><p><span class="math inline">\(\exists\xi\in\left(a,\,b\right)\)</span>，使得<span class="math inline">\(\displaystyle\frac{f^\prime\left(\xi\right)}{g^\prime\left(\xi\right)}=\frac{f\left(b\right)-f\left(a\right)}{g\left(b\right)-g\left(a\right)}\)</span></p></li><li><p>作用</p><ul><li>证明多中值问题<ol type="1"><li>分离中值</li><li>分别使用 <span class="math inline">\(Lagrange\)</span> 和 <span class="math inline">\(Cauchy\)</span> 中值定理</li></ol>例：函数 <span class="math inline">\(f\left(x\right)\)</span> 在 <span class="math inline">\(\left[a,\,b\right]\)</span> 上连续、在 <span class="math inline">\(\left(a,\,b\right)\)</span> 上可导，且 <span class="math inline">\(f\left(x\right)\neq 0\)</span>，证明 <span class="math inline">\(\exists\xi,\,\eta\in\left(a,\,b\right)\)</span>使得 <span class="math inline">\(\displaystyle\frac{f^\prime\left(\xi\right)}{f^\prime\left(\eta\right)}=\frac{e^b-e^a}{b-a}e^{\eta}\)</span><br>解：[分离中值] <span class="math inline">\(\displaystyle\begin{array}{c}\underbrace{f^\prime\left(\xi\right)}\\{Lagrange}\end{array}=\frac{e^b-e^a}{b-a}\cdot\begin{array}{c}\underbrace{\frac{f^\prime\left(\eta\right)}{e^\eta}}\\{Cauchy}\end{array}\)</span><br>[使用中值定理] 令 <span class="math inline">\(g\left(x\right)=e^x\)</span>，使用 <span class="math inline">\(Cauchy\)</span> 中值定理：<span class="math inline">\(\displaystyle\frac{f\left(b\right)-f\left(a\right)}{g\left(b\right)-g\left(a\right)}=\frac{f^\prime\left(\eta\right)}{e^\eta}\)</span>；使用<span class="math inline">\(Lagrange\)</span> 中值定理：<span class="math inline">\(\displaystylef^\prime\left(\xi\right)=\frac{f\left(b\right)-f\left(a\right)}{b-a}\)</span>。等式右边<span class="math inline">\(=\displaystyle\frac{e^b-e^a}{b-a}\cdot\frac{f\left(b\right)-f\left(a\right)}{e^b-e^a}=\)</span>等式左边，得证。</li></ul></li></ul><h3 id="taylor-公式"><span class="math inline">\(Taylor\)</span>公式</h3><blockquote><p>设函数 <span class="math inline">\(f\left(x\right)\)</span> 在 <span class="math inline">\(\mathring{U}\left(x_0\right)\)</span> 内具有 <span class="math inline">\(n+1\)</span> 阶导数，则：</p><p><span class="math display">\[\begin{array}{c}\displaystylef\left(x\right)=\sum_{i=0}^{n}\frac{f^{\left(i\right)}\left(x_0\right)}{i!}\left(x-x_0\right)^i+R_n\left(x\right)\\=f\left(x_0\right)+f^\prime\left(x_0\right)\left(x-x_0\right)+\frac{f^{\prime\prime}\left(x_0\right)}{2!}\left(x-x_0\right)^2+\cdots+\frac{f^{\left(n\right)}\left(x_0\right)}{n!}\left(x-x_0\right)^n+R_n\left(x\right)\end{array}\]</span></p><p>其中 <span class="math inline">\(R_n\left(x\right)\)</span>称为余项。<span class="math inline">\(R_n\left(x\right)=\left\{\begin{array}{ll}\frac{f^{\left(n+1\right)}\left(\xi\right)}{\left(n+1\right)!}\left(x-x_0\right)^{n+1}&amp;Lagrange\ 余项\\[0.8em] o\left(\left(x-x_0\right)^n\right)&amp;Peano\余项\end{array}\right.\)</span></p></blockquote><p>若 <span class="math inline">\(x_0=0\)</span>，则称该公式为 <span class="math inline">\(Maclaurin\)</span> 公式。</p><p>常用的 <span class="math inline">\(Maclaurin\)</span> 展开式： -<span class="math inline">\(e^x=1+x+\frac{x^2}{2!}+\cdots+\frac{x^n}{n!}+o\left(x^n\right)\)</span></p><h2 id="多元函数微分学">多元函数微分学</h2><h3 id="多元隐函数求偏导">多元隐函数求偏导</h3><p><span class="math display">\[\frac{\partial z}{\partialx}=-\frac{F_x}{F_z}\]</span></p><h3 id="方向导数与梯度">方向导数与梯度</h3><p><span class="math display">\[\nabla=\left(\frac{\partial f}{\partialx},\,\frac{\partial f}{\partial y},\,\frac{\partial f}{\partialz}\right)\]</span></p><h3 id="应用">应用</h3><h4 id="利用判别式法求解无条件极值">利用判别式法求解无条件极值</h4><h4 id="利用-lagrange-乘数法求解条件极值">利用 <span class="math inline">\(Lagrange\)</span> 乘数法求解条件极值</h4><h1 id="积分">积分</h1><h2 id="定积分">定积分</h2><p>设函数 <span class="math inline">\(f\left(x\right)\)</span> 在 <span class="math inline">\(\left[a,b\right]\)</span> 上有界。</p><ol type="1"><li><p>取 <span class="math inline">\(a=x_0&lt;x_1&lt;\cdots&lt;x_n=b\)</span></p><ul><li><span class="math inline">\(\left[a,b\right]=\left[x_0,x_1\right]\cup\left[x_1,x_2\right]\cup\cdots\cup\left[x_{n-1},x_n\right]\)</span></li><li><span class="math inline">\(\Delta x_i=x_i-x_{i-1}\\left(i\in\left[1,n\right]\right)\)</span></li></ul></li><li><p>任取 <span class="math inline">\(\xi_i\in\left[x_{i-1},x_i\right]\)</span>，求和<span class="math inline">\(\sum_{i=1}^{n}{f\left(\xi_i\right)\Deltax_i}\)</span></p></li><li><p>取 <span class="math inline">\(\displaystyle\lambda=\max_{1\lei\le n}{\left\{\Delta x_i\right\}}\)</span></p></li><li><p>若 <span class="math inline">\(\displaystyle\lim_{\lambda\rightarrow0}{\sum_{i=1}^{n}{f\left(\xi_i\right)\Deltax_i}}\)</span> 存在，则其为 <span class="math inline">\(f\left(x\right)\)</span> 在 <span class="math inline">\(\left[a,b\right]\)</span>上的定积分（Integral），即： <span class="math display">\[\int_{a}^{b}f\left(x\right)dx=\lim_{\lambda\rightarrow0}{\sum_{i=1}^{n}{f\left(\xi_i\right)\Deltax_i}}\]</span></p></li></ol><p>定积分的诸性质：</p><ul><li>若 <span class="math inline">\(f\left(x\right)\geq0\)</span>（<span class="math inline">\(a\le x\le b\)</span>），则 <span class="math inline">\(\displaystyle\int_{a}^{b}f\left(x\right)dx\geq0\)</span></li><li>若 <span class="math inline">\(f\left(x\right)\geqg\left(x\right)\)</span>（<span class="math inline">\(a\le x\leb\)</span>），则 <span class="math inline">\(\displaystyle\int_{a}^{b}f\left(x\right)dx\geq\int_{a}^{b}g\left(x\right)dx\)</span></li><li>若 <span class="math inline">\(f\left(x\right)\)</span>、<span class="math inline">\(\left|f\left(x\right)\right|\)</span> 在 <span class="math inline">\(\left[a,\ \ b\right]\)</span> 上可积，则 <span class="math inline">\(\displaystyle\left|\int_{a}^{b}f\left(x\right)dx\right|\le\int_{a}^{b}\left|f\left(x\right)\right|dx\)</span></li></ul><h3 id="积分中值定理">积分中值定理</h3><blockquote><p>设 <span class="math inline">\(f\left(x\right)\in{C\left[a,\,b\right]}\)</span>，则<span class="math inline">\(\exists\xi\in\left[a,\,b\right]\)</span>，使得<span class="math inline">\(\displaystyle\int_{a}^{b}f\left(x\right)dx=f\left(\xi\right)\left(b-a\right)\)</span></p></blockquote><ul><li><p><em>证明</em></p><p><span class="math inline">\(\becausef\left(x\right)\in{C\left[a,\,b\right]},\,\therefore\exists{M=f(x)_{\max},\,m=f(x)_{\min}}\)</span>，使得<span class="math inline">\(m\leq f(x)\leq M\)</span>。<br>对等式两边取在 <span class="math inline">\(\left[a,\,b\right]\)</span>上的定积分：<span class="math inline">\(\displaystyle\int_{a}^{b}m\leq\int_{a}^{b}f\left(x\right)dx\leq\int_{a}^{b}M\Rightarrow\)</span><br><span class="math inline">\(\displaystylem\leq\frac{1}{b-a}\int_{a}^{b}f\left(x\right)dx\leq M\)</span>。<br>（介值定理）<span class="math inline">\(\therefore\exists\xi\in\left[a,\,b\right]\)</span>，使得<span class="math inline">\(\displaystyle\frac{1}{b-a}\int_{a}^{b}f\left(x\right)dx=f\left(\xi\right)\)</span></p></li><li><p>用途：在被积函数 <strong>连续</strong>的情况下，去掉积分号</p></li></ul><h3 id="积分上限函数">积分上限函数</h3><p>设 <span class="math inline">\(f\left(x\right)\inC\left[a,b\right]\)</span>，<span class="math inline">\(\Phi\left(x\right)=\int_{a}^{x}f\left(t\right)dt\)</span>，则<span class="math inline">\(\frac{d}{dx}\Phi\left(x\right)=f\left(x\right)\)</span>，即<span class="math inline">\(\Phi^\prime\left(x\right)=f\left(x\right)\)</span>。</p><p>积分上限函数的诸性质</p><ul><li><span class="math inline">\(\displaystyle\frac{d}{dx}\int_{a}^{x}{f(t)dt}=f\left(x\right)\)</span></li><li><span class="math inline">\(\displaystyle\frac{d}{dx}\int_{a}^{\varphi\left(x\right)}f\left(t\right)dt=f\left(\varphi\left(x\right)\right)\cdot\varphi^\prime\left(x\right)\)</span></li><li><span class="math inline">\(\displaystyle\frac{d}{dx}\int_{\varphi_1\left(x\right)}^{\varphi_2\left(x\right)}{f(t)dt}=f\left(\varphi_2\left(x\right)\right)\varphi_2^\prime\left(x\right)-f\left(\varphi_1\left(x\right)\right)\varphi_1^\prime\left(x\right)\)</span></li></ul><h3 id="函数的定积分性质">函数的定积分性质</h3><h4 id="周期函数">周期函数</h4><h4 id="三角函数">三角函数</h4><p><span class="math display">\[\int_0^{\frac\pi2}f\left(\sin x,\,\cosx\right)=\int_0^{\frac\pi2}f\left(\cos x,\,\sin x\right)\]</span></p><h5 id="wallis-公式"><span class="math inline">\(Wallis\)</span>公式</h5><p><span class="math display">\[\int_0^{\frac\pi2}\sin^nx=\int_0^{\frac\pi2}\cos^nx=\begin{cases}\frac{n-1}{n}\cdot\frac{n-3}{n-2}\cdots\frac23\cdot1&amp;n\,为奇数\\\frac{n-1}{n}\cdot\frac{n-3}{n-2}\cdots\frac12\cdot\frac\pi2&amp;n\,为偶数\end{cases}\]</span></p><h3 id="定积分的应用">定积分的应用</h3><p>利用微元法求解面积、体积的步骤：</p><ol type="1"><li>确定积分变量及其取值区间</li><li>任取区间 <span class="math inline">\(\left[x,\,x+dx\right]\)</span>，求出该区间对应的微元表达式</li><li>求积分</li></ol><h2 id="多元函数积分学">多元函数积分学</h2><h3 id="二重积分">二重积分</h3><p><span class="math display">\[\iint\limits_{D}{f\left(x,\,y\right)d\sigma}=\lim_{\lambda\to0}{\sum_{i=1}^{n}f\left(\xi_i,\,\eta_i\right)\Delta\sigma_i}\]</span>其中 <span class="math inline">\(f\left(x,\,y\right)\)</span>是被积函数；<span class="math inline">\(f\left(x,\,y\right)d\sigma\)</span>是被积表达式；<span class="math inline">\(d\sigma\)</span>是面积元素；<span class="math inline">\(x,\,y\)</span> 是积分变量；<span class="math inline">\(D\)</span> 是积分区域；<span class="math inline">\(\displaystyle\sum_{i=1}^{n}f\left(\xi_i,\,\eta_i\right)\Delta\sigma_i\)</span>是积分和。</p><p>在直角坐标系下的面积元素 <span class="math inline">\(d\sigma\)</span>可写为 <span class="math inline">\(dxdy\)</span></p><h3 id="三重积分">三重积分</h3><p><span class="math display">\[\iiint\limits_{D}{f\left(x,\,y,\,z\right)dv}\]</span></p><h4 id="计算方法">计算方法</h4><ol type="1"><li><p>直角坐标</p><ol type="1"><li>切片法（先一后二）</li><li>投影法（先二后一）</li></ol></li><li><p>柱坐标</p></li><li><p>球坐标</p><p><span class="math display">\[\left\{\begin{align*}x&amp;=r\sin\varphi\cos\theta,&amp;0\leqr\lt+\infty\\y&amp;=r\sin\varphi\sin\theta,&amp;0\leq\varphi\leq2\pi\\z&amp;=r\cos\varphi,&amp;0\leq\theta\leq2\pi\end{align*}\right.\]</span></p><p><span class="math display">\[dv=r^2 \sin\varphi drd\varphid\theta\]</span></p></li></ol><h4 id="应用-1">应用</h4><ol type="1"><li><p>空间几何体的重心（质心）及形心 设空间几何体 <span class="math inline">\(\Omega\)</span> 体密度为 <span class="math inline">\(\rho(x,\,y,\,z)\)</span>，则其重心（质心）坐标公式为<span class="math display">\[\bar{x}=\dfrac{\iiint\limits_{\Omega}x\rho(x,\,y,\,z)dv}{\iiint\limits_{\Omega}\rho(x,\,y,\,z)dv},\;\bar{y}=\dfrac{\iiint\limits_{\Omega}y\rho(x,\,y,\,z)dv}{\iiint\limits_{\Omega}\rho(x,\,y,\,z)dv},\;\bar{z}=\dfrac{\iiint\limits_{\Omega}z\rho(x,\,y,\,z)dv}{\iiint\limits_{\Omega}\rho(x,\,y,\,z)dv}\]</span>当 <span class="math inline">\(\rho(x,\,y,\,z)\equiv 1\)</span> 时，得到<span class="math inline">\(\Omega\)</span> 的形心坐标公式为 <span class="math display">\[\bar{x}=\dfrac{\iiint\limits_{\Omega}xdv}{\iiint\limits_{\Omega}dv},\;\bar{y}=\dfrac{\iiint\limits_{\Omega}ydv}{\iiint\limits_{\Omega}dv},\;\bar{z}=\dfrac{\iiint\limits_{\Omega}zdv}{\iiint\limits_{\Omega}dv}\]</span></p></li><li><p>空间几何体 <span class="math inline">\(\Omega\)</span> 的转动惯量设空间几何体 <span class="math inline">\(\Omega\)</span> 体密度为 <span class="math inline">\(\rho(x,\,y,\,z)\)</span>，则其对于 <span class="math inline">\(x\)</span> 轴、<span class="math inline">\(y\)</span> 轴、<span class="math inline">\(z\)</span> 轴及原点 <span class="math inline">\(O\)</span> 的转动惯量分别为 <span class="math display">\[I_x=\iiint\limits_{\Omega}\left(y^2+z^2\right)\rho(x,\,y,\,z)dv\]</span></p><p><span class="math display">\[I_y=\iiint\limits_{\Omega}\left(x^2+z^2\right)\rho(x,\,y,\,z)dv\]</span><span class="math display">\[I_z=\iiint\limits_{\Omega}\left(x^2+y^2\right)\rho(x,\,y,\,z)dv\]</span><span class="math display">\[I_O=\iiint\limits_{\Omega}\left(x^2+y^2+z^2\right)\rho(x,\,y,\,z)dv\]</span></p></li></ol><h3 id="曲线积分">曲线积分</h3><p><span class="math display">\[\oint_L\]</span></p><h4 id="对弧长的曲线积分第一类">对弧长的曲线积分（第一类）</h4><h4 id="对坐标的曲线积分第二类">对坐标的曲线积分（第二类）</h4><h5 id="green-公式"><span class="math inline">\(Green\)</span> 公式</h5><p><span class="math display">\[\oint_LP(x,y)dx+Q(x,y)dy=\iint\limits_{D}\left(\frac{\partial Q}{\partialx}-\frac{\partial P}{\partial y}\right)d\sigma\]</span></p><h5 id="stokes-公式"><span class="math inline">\(Stokes\)</span>公式</h5><p><span class="math display">\[\oint_LPdx+Qdy+Rdz=\iint\limits_\Sigma\begin{vmatrix}\cos\alpha&amp;\cos\beta&amp;\cos\theta\\\frac{\partial}{\partialx}&amp;\frac{\partial}{\partial y}&amp;\frac{\partial}{\partialz}\\P&amp;Q&amp;R\end{vmatrix}dS\]</span></p><h3 id="曲面积分">曲面积分</h3><pre><code class=" mermaid">flowchart TB; l(曲线积分)---gr(Green 公式) &amp; st(Stokes 公式) p(曲面积分)---ga(Gauss 公式) st --&gt; |特例|ga st --&gt; |投影|gr</code></pre><h4 id="对面积的曲面积分第一类">对面积的曲面积分（第一类）</h4><h4 id="对坐标的曲面积分第二类">对坐标的曲面积分（第二类）</h4><h5 id="gauss-公式"><span class="math inline">\(Gauss\)</span> 公式</h5><p><span class="math display">\[\oiint_\SigmaPdydz+Qdzdx+Rdxdy=\iiint_\Omega\left(\frac{\partial P}{\partialx}+\frac{\partial Q}{\partial y}+\frac{\partial R}{\partialz}\right)dv\]</span></p><h1 id="无穷级数">无穷级数</h1><p>Infinite Series</p><h2 id="数项级数">数项级数</h2><h3 id="比较审敛法">比较审敛法</h3><h2 id="幂级数">幂级数</h2><h3 id="比值审敛法">比值审敛法</h3><h2 id="fourier-级数"><span class="math inline">\(Fourier\)</span>级数</h2><h1 id="向量代数与空间解析几何">向量代数与空间解析几何</h1><h2 id="向量及其线性运算">向量及其线性运算</h2><h3 id="方向角与方向余弦">方向角与方向余弦</h3><p>记向量 <span class="math inline">\(\vec{v}=\left(x,\,y,\,z\right)\)</span>，并记与<span class="math inline">\(x,\,y,\,z\)</span> 正半轴所形成的角分别为<span class="math inline">\(\alpha,\,\beta,\,\gamma\)</span>，则有：<span class="math display">\[\begin{array}{c}\cos\alpha=\displaystyle\frac{x}{\sqrt{x^2+y^2+z^2}} \\[1.5em]\cos\beta=\displaystyle\frac{y}{\sqrt{x^2+y^2+z^2}} \\[1.5em]\cos\gamma=\displaystyle\frac{z}{\sqrt{x^2+y^2+z^2}} \\\end{array}\]</span></p><p><span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 注意： - 若 <span class="math inline">\(\vec{v}\)</span>在第一卦限，则 <span class="math inline">\(\alpha,\,\beta,\,\gamma\)</span> 皆为锐角。 - 向量<span class="math inline">\(\left(\cos\alpha,\,\cos\beta,\,\cos\gamma\right)\)</span>是与向量 <span class="math inline">\(\vec{v}\)</span> 同向的单位向量。 -如果求得单位向量更方便，则可以利用单位向量与方向余弦向量的关系直接求解方向余弦。</p><h3 id="向量在轴上的投影">向量在轴上的投影</h3><p>过 <span class="math inline">\(M\)</span> 点作与 <span class="math inline">\(u\)</span> 轴相垂直的平面 <span class="math inline">\(\pi\)</span>，<span class="math inline">\(\pi\)</span> 与 <span class="math inline">\(u\)</span> 轴交点记为 <span class="math inline">\(M^\prime\)</span>（点 <span class="math inline">\(M\)</span> 在 <span class="math inline">\(u\)</span> 轴上的投影）；<span class="math inline">\(\overrightarrow{OM^\prime}\)</span> 是 <span class="math inline">\(\overrightarrow{OM}\)</span> 在 <span class="math inline">\(u\)</span> 轴上的分向量。由于 <span class="math inline">\(\overrightarrow{OM^\prime}\)</span> 同 <span class="math inline">\(u\)</span> 轴的单位向量 <span class="math inline">\(\hat{e}\)</span> 平行，故 <span class="math inline">\(\overrightarrow{OM^\prime}=\lambda\hat{e}\)</span>，<span class="math inline">\(\lambda\)</span> 就是 <span class="math inline">\(\overrightarrow{OM}\)</span> 在 <span class="math inline">\(u\)</span>轴上的投影（<strong>是一个数而不是向量</strong>），记作： <span class="math display">\[\mathrm{prj}_{u}\overrightarrow{OM}\;或\;\left(\overrightarrow{OM}\right)_u\]</span></p><p>性质： 1. <span class="math inline">\(\mathrm{prj}_{u}\overrightarrow{OM}=\left|\overrightarrow{OM}\right|\cos\varphi\quad\left(\varphi\in\left[0,\,\pi\right]\right)\)</span>2. <span class="math inline">\(\mathrm{prj}_{u}\left(\vec{a}+\vec{b}\right)=\mathrm{prj}_{u}\vec{a}+\mathrm{prj}_{u}\vec{b}\)</span>3. <span class="math inline">\(\mathrm{prj}_{u}\lambda\vec{a}=\lambda\cdot\mathrm{prj}_{u}\vec{a}\)</span></p><h3 id="向量的积">向量的积</h3><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">数量积</th><th style="text-align: center;">向量积</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">定义</td><td style="text-align: center;"><span class="math inline">\(\vec{a}\cdot\vec{b}=\begin{vmatrix}\vec{a}\end{vmatrix}\begin{vmatrix}\vec{b}\end{vmatrix}\cos\theta\)</span></td><td style="text-align: center;"><span class="math inline">\(\vec{a}\times\vec{b}=\begin{vmatrix}\vec{a}\end{vmatrix}\begin{vmatrix}\vec{b}\end{vmatrix}\sin\theta\)</span></td></tr><tr class="even"><td style="text-align: center;">交换律</td><td style="text-align: center;"><span class="math inline">\(\vec{a}\cdot\vec{b}=\vec{b}\cdot\vec{a}\)</span></td><td style="text-align: center;"><span class="math inline">\(a\times\vec{b}=-\vec{b}\times\vec{a}\)</span></td></tr><tr class="odd"><td style="text-align: center;">分配律</td><td style="text-align: center;"><span class="math inline">\(\left(\vec{a}+\vec{b}\right)\cdot\vec{c}=\vec{a}\cdot\vec{c}+\vec{b}\cdot\vec{c}\)</span></td><td style="text-align: center;"><span class="math inline">\(\left(\vec{a}+\vec{b}\right)\times\vec{c}=\vec{a}\times\vec{c}+\vec{b}\times\vec{c}\)</span></td></tr><tr class="even"><td style="text-align: center;">自乘</td><td style="text-align: center;"><span class="math inline">\(\vec{a}\cdot\vec{a}=\begin{vmatrix}\vec{a}\end{vmatrix}^2\)</span></td><td style="text-align: center;"><span class="math inline">\(\vec{a}\times\vec{a}=\vec{0}\)</span></td></tr><tr class="odd"><td style="text-align: center;">零积</td><td style="text-align: center;"><span class="math inline">\(\vec{a}\cdot\vec{b}=0\Leftrightarrow\vec{a}\bot\vec{b}\)</span></td><td style="text-align: center;"><span class="math inline">\(\vec{a}\times\vec{b}=\vec{0}\Leftrightarrow\vec{a}\parallel\vec{b}\)</span></td></tr><tr class="even"><td style="text-align: center;">代数描述</td><td style="text-align: center;"><span class="math inline">\(\vec{a}^T\cdot\vec{b}\)</span></td><td style="text-align: center;"><span class="math inline">\(\begin{vmatrix}\hat{i}&amp;\hat{j}&amp;\hat{k}\\x_1&amp;y_1&amp;z_1\\x_2&amp;y_2&amp;z_2\end{vmatrix}\)</span></td></tr></tbody></table><h4 id="混合积">混合积</h4><p>先叉乘后点乘：<span class="math inline">\(\left(\vec{a}\times\vec{b}\right)\cdot\vec{c}\)</span>，记作 <span class="math inline">\(\begin{bmatrix}\vec{a}&amp;\vec{b}&amp;\vec{c}\end{bmatrix}\)</span>（<strong>最后的结果是一个数，不是向量</strong>）。</p><p>计算： <span class="math display">\[\begin{bmatrix}\vec{a}&amp;\vec{b}&amp;\vec{c}\end{bmatrix}=\begin{vmatrix}x_1&amp;y_1&amp;z_1\\x_2&amp;y_2&amp;z_2\\x_3&amp;y_3&amp;z_3\end{vmatrix}\]</span>几何意义：混合积的绝对值是以 <span class="math inline">\(\vec{a},\,\vec{b},\,\vec{c}\)</span>为邻边的平行六面体体积。</p><p><span class="math inline">\(\vec{a}\times\vec{b}\)</span> 与 <span class="math inline">\(\vec{c}\)</span> 之间的夹角 <span class="math inline">\(\theta\)</span> 与混合积之间的关系： - <span class="math inline">\(\displaystyle0\leq\theta\lt\frac{\pi}{2}\Leftrightarrow\begin{bmatrix}\vec{a}&amp;\vec{b}&amp;\vec{c}\end{bmatrix}\gt0\Leftrightarrow\vec{a}\times\vec{b},\,\vec{c}\)</span> 在 <span class="math inline">\(\vec{a},\,\vec{b}\)</span> 所确定平面的同侧； -<span class="math inline">\(\displaystyle\frac{\pi}{2}\lt\theta\leq\pi\Leftrightarrow\begin{bmatrix}\vec{a}&amp;\vec{b}&amp;\vec{c}\end{bmatrix}\lt0\Leftrightarrow\vec{a}\times\vec{b},\,\vec{c}\)</span> 在 <span class="math inline">\(\vec{a},\,\vec{b}\)</span> 所确定平面的异侧； -<span class="math inline">\(\displaystyle\theta=\frac{\pi}{2}\Leftrightarrow\begin{bmatrix}\vec{a}&amp;\vec{b}&amp;\vec{c}\end{bmatrix}=0\Leftrightarrow\vec{a},\,\vec{b},\,\vec{c}\)</span>共面。</p><p>交换律： <span class="math display">\[\begin{bmatrix}\vec{a}&amp;\vec{b}&amp;\vec{c}\end{bmatrix}=\begin{bmatrix}\vec{b}&amp;\vec{c}&amp;\vec{a}\end{bmatrix}=\begin{bmatrix}\vec{c}&amp;\vec{a}&amp;\vec{b}\end{bmatrix}\]</span></p><pre><code class=" mermaid">flowchart LR;  a --&gt; b --&gt; c --&gt; a</code></pre><h2 id="平面及其方程">平面及其方程</h2><h3 id="平面的点法向式方程">平面的点法向式方程</h3><p><span class="math display">\[A\left(x-x_0\right)+B\left(y-y_0\right)+C\left(z-z_0\right)=0\]</span>其中，该平面的法向量为 <span class="math inline">\(\begin{pmatrix}A&amp;B&amp;C\end{pmatrix}\)</span>，点<span class="math inline">\(P\left(x_0,\,y_0,\,z_0\right)\)</span>是该平面上的一点。</p><p>求法： 1. 找到垂直于平面的一个向量 <span class="math inline">\(\vec\tau\)</span>； 2. 在平面中找一个定点 <span class="math inline">\(P\left(x_0,\,y_0,\,z_0\right)\)</span>，与动点<span class="math inline">\(X\left(x,\,y,\,z\right)\)</span> 构成向量<span class="math inline">\(\overrightarrow{XP}\)</span>； 3. <span class="math inline">\(\overrightarrow{XP}\cdot\vec\tau=0\)</span></p><h3 id="平面的一般式方程">平面的一般式方程</h3><p><span class="math display">\[Ax+By+Cz+D=0\]</span></p><p>特点： - <span class="math inline">\(D=0\)</span> 则平面过坐标原点；- <span class="math inline">\(A=0\)</span> 则平面平行于 <span class="math inline">\(x\)</span> 轴 - <span class="math inline">\(A=B=0\)</span> 则平面平行于 <span class="math inline">\(xOy\)</span> 平面</p><h3 id="平面的截距式方程">平面的截距式方程</h3><p><span class="math display">\[\frac{x}{a}+\frac{y}{b}+\frac{z}{c}=1\]</span></p><h2 id="曲面及其方程">曲面及其方程</h2><h3 id="旋转曲面">旋转曲面</h3><blockquote><p>平面曲线（母线）绕该平面内的某直线（轴）旋转一周所得的曲面即旋转曲面。</p></blockquote><p>设 <span class="math inline">\(yOz\)</span> 平面内有一方程为 <span class="math inline">\(f\left(y,\,z\right)=0\)</span> 的曲线，绕着 <span class="math inline">\(z\)</span> 轴旋转，要求其旋转所得的曲线：</p><ol type="1"><li>设母线上任一点为 <span class="math inline">\(M_1\left(0,\,y_1,\,z_1\right)\)</span>，过该点作垂直于<span class="math inline">\(z\)</span>轴的平面，得到该平面与旋转曲面的截痕，并设截痕上另一点为 <span class="math inline">\(M\left(x,\,y,\,z\right)\)</span></li><li>因为 <span class="math inline">\(M_1\)</span> 在母线上，所以 <span class="math inline">\(f\left(y_1,\,z_1\right)=0\)</span></li><li>曲线围绕 <span class="math inline">\(z\)</span> 轴旋转一周，<span class="math inline">\(M_1\)</span> 到 <span class="math inline">\(z\)</span> 轴的距离并不发生变化，故 <span class="math inline">\(M\)</span>、<span class="math inline">\(M_1\)</span> 两点相对 <span class="math inline">\(z\)</span> 轴的距离相等：<span class="math inline">\(\sqrt{y_1^2+(z_1-z)^2}\)</span>（<span class="math inline">\(M_1\)</span> 到 <span class="math inline">\(z\)</span> 轴的距离）<span class="math inline">\(=\sqrt{x^2+y^2+(z-z)^2}\)</span>（<span class="math inline">\(M\)</span> 到 <span class="math inline">\(z\)</span> 轴的距离）</li><li>联立方程 <span class="math inline">\(\left\{\begin{array}{l}z=z_1\\\sqrt{y_1^2+(z_1-z)^2}=\sqrt{x^2+y^2+(z-z)^2}\\f\left(y_1,\,z_1\right)=0\end{array}\right.\)</span></li><li>得旋转曲面方程 <span class="math inline">\(f\left(\plusmn\sqrt{x^2+y^2},\,z\right)=0\)</span></li></ol><p><span class="github-emoji"><span>📓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4d3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 注意到 <span class="math inline">\(f\left(y,\,z\right)=0\)</span> 顺时针旋转 <span class="math inline">\(90\degree\)</span> 得到的 <span class="math inline">\(f\left(x,\,z\right)=0\)</span> 绕 <span class="math inline">\(z\)</span>轴所得的旋转曲面方程不变，故<strong><em>绕哪个轴，哪个轴不动</em></strong></p><h4 id="各类旋转曲面">各类旋转曲面</h4><ul><li><p>球面</p><p>方程：<span class="math inline">\(\displaystyle\frac{x^2}{r^2}+\frac{y^2}{r^2}+\frac{z^2}{r^2}=1\)</span>其中 <span class="math inline">\(r\)</span> 为球的半径</p></li><li><p>椭球面</p><p>方程：<span class="math inline">\(\displaystyle\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}=1\)</span>其中当 <span class="math inline">\(a,\,b,\,c\)</span>其中两个相等时，为旋转椭球面</p></li><li><p>圆锥面</p><p>方程：<span class="math inline">\(\displaystyle\frac{x^2}{a^2}+\frac{y^2}{a^2}=z^2\)</span></p></li></ul><h1 id="常微分方程">常微分方程</h1><h2 id="一阶微分方程">一阶微分方程</h2><h3 id="变量可分离的一阶方程">变量可分离的一阶方程</h3><p>形式：<span class="math inline">\(\dfrac{dy}{dx}=\varphi(x,\,y)=g(x)\cdoth(y)\)</span></p><p>解法：<span class="math inline">\(\displaystyle\dfrac{1}{h(y)}dy=g(x)dx\Rightarrow\int\dfrac{1}{h(y)}dy=\intg(x)dx\)</span></p><p>【例】求方程 <span class="math inline">\(x(1+y^2)dx+(1+x^2)ydy=0\)</span> 的通解<br>【解】关于 <span class="math inline">\(x,\,y\)</span>的式子分别移到等式两边： <span class="math inline">\(\dfrac{x}{1+x^2}dx=-\dfrac{y}{1+y^2}dy\)</span>；对等式两边积分：<span class="math inline">\(\displaystyle\int\dfrac{x}{1+x^2}dx=-\int\dfrac{y}{1+y^2}dy\)</span>得 <span class="math inline">\(\dfrac12\ln(1+x^2)=-\dfrac12\ln(1+y^2)+\dfrac12\lnC\)</span>；化简可得 <span class="math inline">\(1+y^2=\dfrac{C}{1+x^2}\)</span>。</p><h2 id="齐次方程">齐次方程</h2><p>形式：<span class="math inline">\(\dfrac{dy}{dx}=g\left(\dfrac{y}{x}\right)\)</span></p><p>解法：令 <span class="math inline">\(u=\dfrac{y}{x}\)</span> 则 <span class="math inline">\(y=x\cdot u\)</span>，两边对 <span class="math inline">\(x\)</span> 求导：<span class="math inline">\(\dfrac{dy}{dx}=u+x\cdot\dfrac{du}{dx}\)</span>。代入方程得<span class="math inline">\(u+x\cdot\dfrac{du}{dx}=g(u)\)</span>，分离变量可得<span class="math inline">\(\dfrac{u-g(u)}{du}=\dfrac{x}{dx}\)</span>。同时取倒数并积分：<span class="math inline">\(\displaystyle\int\dfrac1{u-g(u)}du=\int\dfrac{1}{x}dx\)</span>，最后把<span class="math inline">\(u=\dfrac{y}{x}\)</span>代回可得最终微分方程的解。</p><h2 id="一阶线性微分方程">一阶线性微分方程</h2><ol type="1"><li><p>齐次方程</p><p>标准形式：<span class="math inline">\(y^\prime+p(x)y=0\)</span></p><p>通解：<span class="math inline">\(y=C\cdot e^{-\intp(x)dx}\)</span></p></li><li><p>非齐次方程</p><p>标准形式：<span class="math inline">\(y^\prime+p(x)y=q(x)\)</span></p><p>通解：<span class="math inline">\(y=\left(\int q(x)\cdot e^{\intp(x)dx}dx+C\right)e^{-\int p(x)dx}\)</span></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数笔记</title>
    <link href="/2023/Note_Of_Linear_Algebra/"/>
    <url>/2023/Note_Of_Linear_Algebra/</url>
    
    <content type="html"><![CDATA[<h1 id="线性代数概览">线性代数概览</h1><h2 id="本质线性变换">本质——线性变换</h2><p><span class="math display">\[\begin{matrix}\underbrace{\begin{pmatrix}\alpha_1,\alpha_2,\cdots,\alpha_m\end{pmatrix}}\\A\end{matrix}\cdotK_{m\timesl}=\begin{matrix}\underbrace{\begin{pmatrix}b_1,b_2,\cdots,b_l\end{pmatrix}}\\B\end{matrix}\]</span></p><ul><li>矩阵视角：<span class="math inline">\(B\)</span> 是 <span class="math inline">\(A\)</span> 与 <span class="math inline">\(K\)</span> 的乘积</li><li>方程视角：<span class="math inline">\(K\)</span> 是方程 <span class="math inline">\(AX=B\)</span> 的解</li><li>向量视角：向量组 <span class="math inline">\(B\)</span> 能由向量组<span class="math inline">\(A\)</span> 线性表出</li></ul><p>两条主线：线性方程组、矩阵对角化</p><h2 id="计算矩阵的行变换">计算——矩阵的行变换</h2><ul><li>求逆矩阵：<span class="math inline">\(\displaystyle\begin{pmatrix}\begin{array}{c:c}A&amp;E\end{array}\end{pmatrix}\to\begin{pmatrix}\begin{array}{c:c}E&amp;A^{-1}\end{array}\end{pmatrix}\)</span></li><li>求解线性方程组 <span class="math inline">\(AX=B\)</span>：将伴随矩阵<span class="math inline">\(\displaystyle\begin{pmatrix}\begin{array}{c:c}A&amp;B\end{array}\end{pmatrix}\)</span> 化为行阶梯型</li></ul><h1 id="线性方程组">线性方程组</h1><pre><code class=" mermaid">flowchart LR  线性方程组 --&gt; 齐次 --&gt; 有零解  齐次 --&gt; 有非零解  线性方程组 --&gt; 非齐次 --&gt; 有解  有解 --&gt; 唯一解  有解 --&gt; 无穷多解  非齐次 --&gt; 无解</code></pre><h2 id="非齐次线性方程组">非齐次线性方程组</h2><p><span class="math display">\[\left\{\begin{array}{c}a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_{n}=b_1\\a_{21}x_1+a_{22}x_2+\cdots+a_{2n}x_{n}=b_2\\\vdots\\a_{n1}x_1+a_{n2}x_2+\cdots+a_{nn}x_{n}=b_n\end{array}\right.\]</span></p><h3 id="矩阵形式">矩阵形式</h3><p><span class="math display">\[\begin{matrix}\underbrace{\begin{pmatrix}a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1n}\\a_{21}&amp;a_{22}&amp;\cdots&amp;a_{2n}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_{n1}&amp;a_{n2}&amp;\cdots&amp;a_{nn}\\\end{pmatrix}}\\A\end{matrix}\begin{matrix}\underbrace{\begin{pmatrix}x_1\\x_2\\\vdots\\x_n\\\end{pmatrix}}\\X\end{matrix}=\begin{matrix}\underbrace{\begin{pmatrix}b_1\\b_2\\\vdots\\b_n\\\end{pmatrix}}\\B\end{matrix}\]</span><span class="math display">\[记\,\bar{A}=\begin{pmatrix}\begin{array}{cccc:c}a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1n}&amp;b_1\\a_{21}&amp;a_{22}&amp;\cdots&amp;a_{2n}&amp;b_2\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots\\a_{n1}&amp;a_{n2}&amp;\cdots&amp;a_{nn}&amp;b_n\end{array}\end{pmatrix}\]</span></p><h4 id="有解">有解</h4><p>矩阵与其伴随矩阵秩<strong>相等</strong>：<span class="math inline">\(r\left(A\right)=r\left(\bar{A}\right)\)</span></p><ul><li>唯一解：<span class="math inline">\(r\left(A\right)=r\left(\bar{A}\right)=n\)</span></li><li>无穷多解：<span class="math inline">\(r\left(A\right)=r\left(\bar{A}\right)\ltn\)</span></li></ul><h4 id="无解">无解</h4><p>矩阵与其伴随矩阵秩<strong>不等</strong>：<span class="math inline">\(r\left(A\right)\neqr\left(\bar{A}\right)\)</span></p><h3 id="向量形式">向量形式</h3><p><span class="math display">\[x_1\begin{matrix}\underbrace{\begin{pmatrix}a_{11}\\a_{21}\\\vdots\\a_{n1}\\\end{pmatrix}}\\\vec{\alpha_1}\end{matrix}+x_2\begin{matrix}\underbrace{\begin{pmatrix}a_{12}\\a_{22}\\\vdots\\a_{n2}\\\end{pmatrix}}\\\vec{\alpha_2}\end{matrix}+\cdots+x_n\begin{matrix}\underbrace{\begin{pmatrix}a_{1n}\\a_{2n}\\\vdots\\a_{nn}\\\end{pmatrix}}\\\vec{\alpha_n}\end{matrix}=\begin{matrix}\underbrace{\begin{pmatrix}b_1\\b_2\\\vdots\\b_n\\\end{pmatrix}}\\\vec{b}\end{matrix}\]</span></p><h4 id="有解-1">有解</h4><p><span class="math inline">\(\vec{b}\)</span> 能由<span class="math inline">\(\vec{\alpha_1},\,\vec{\alpha_2},\,\cdots,\,\vec{\alpha_n}\)</span>线性表示</p><h4 id="无解-1">无解</h4><p><span class="math inline">\(\vec{b}\)</span> 不能由<span class="math inline">\(\vec{\alpha_1},\,\vec{\alpha_2},\,\cdots,\,\vec{\alpha_n}\)</span>线性表示</p><h2 id="齐次线性方程组">齐次线性方程组</h2><p><span class="math display">\[\left\{\begin{array}{c}a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_{n}=0\\a_{21}x_1+a_{22}x_2+\cdots+a_{2n}x_{n}=0\\\vdots\\a_{n1}x_1+a_{n2}x_2+\cdots+a_{nn}x_{n}=0\end{array}\right.\]</span></p><h3 id="矩阵形式-1">矩阵形式</h3><p><span class="math display">\[\begin{matrix}\underbrace{\begin{pmatrix}a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1n}\\a_{21}&amp;a_{22}&amp;\cdots&amp;a_{2n}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_{n1}&amp;a_{n2}&amp;\cdots&amp;a_{nn}\\\end{pmatrix}}\\A\end{matrix}\begin{matrix}\underbrace{\begin{pmatrix}x_1\\x_2\\\vdots\\x_n\\\end{pmatrix}}\\X\end{matrix}=0\]</span></p><h4 id="只有零解">只有零解</h4><p>矩阵 <span class="math inline">\(A\)</span> 满秩：<span class="math inline">\(r\left(A\right)=n\)</span><br>行列式不等于零：<span class="math inline">\(\begin{vmatrix}A\end{vmatrix}\neq 0\)</span></p><h4 id="有非零解">有非零解</h4><p>矩阵 <span class="math inline">\(A\)</span> 降秩：<span class="math inline">\(r\left(A\right)&lt;n\)</span><br>行列式等于零：<span class="math inline">\(\begin{vmatrix}A\end{vmatrix}=0\)</span></p><h3 id="向量形式-1">向量形式</h3><p><span class="math display">\[x_1\begin{matrix}\underbrace{\begin{pmatrix}a_{11}\\a_{21}\\\vdots\\a_{n1}\\\end{pmatrix}}\\\vec{\alpha_1}\end{matrix}+x_2\begin{matrix}\underbrace{\begin{pmatrix}a_{12}\\a_{22}\\\vdots\\a_{n2}\\\end{pmatrix}}\\\vec{\alpha_2}\end{matrix}+\cdots+x_n\begin{matrix}\underbrace{\begin{pmatrix}a_{1n}\\a_{2n}\\\vdots\\a_{nn}\\\end{pmatrix}}\\\vec{\alpha_n}\end{matrix}=\vec0\]</span></p><h4 id="只有零解-1">只有零解</h4><p><span class="math inline">\(\vec{\alpha_1},\,\vec{\alpha_2},\,\cdots,\,\vec{\alpha_n}\)</span>线性无关</p><h4 id="有非零解-1">有非零解</h4><p><span class="math inline">\(\vec{\alpha_1},\,\vec{\alpha_2},\,\cdots,\,\vec{\alpha_n}\)</span>线性相关</p><h3 id="基础解系">基础解系</h3><blockquote><p>设矩阵 <span class="math inline">\(A_{m\timesn},\,r\left(A\right)=r\)</span>，对于齐次线性方程组 <span class="math inline">\(AX=0\)</span>：</p><p>若：</p><ol type="1"><li><span class="math inline">\(\xi_1,\,\xi_2,\,\cdots,\,\xi_s\)</span>为 <span class="math inline">\(AX=0\)</span> 的解；</li><li><span class="math inline">\(\xi_1,\,\xi_2,\,\cdots,\,\xi_s\)</span>线性无关；</li><li><span class="math inline">\(s=n-r\)</span></li></ol><p>称 <span class="math inline">\(\xi_1,\,\xi_2,\,\cdots,\,\xi_s\)</span> 为 <span class="math inline">\(AX=0\)</span>的基础解系（也是解向量组的极大无关组）。</p></blockquote><h4 id="找出方程组的通解">找出方程组的通解</h4><p>将矩阵化为行最简形，找到阶梯线后的列作为非自由变量，其它变量为自由变量（个数为变量个数减去矩阵的秩）</p><p>例：求出方程组 <span class="math inline">\(AX=0\)</span> 的通解（其中<span class="math inline">\(A=\left(\begin{smallmatrix}1&amp;2&amp;-1&amp;1\\1&amp;1&amp;3&amp;-1\\2&amp;5&amp;1&amp;1\\\end{smallmatrix}\right)\)</span>）</p><p>解： 1. 将矩阵化为行最简形： <span class="math display">\[A\rightarrow\begin{pmatrix}1&amp;0&amp;7&amp;-3\\0&amp;1&amp;-4&amp;2\\0&amp;0&amp;0&amp;0\end{pmatrix}\]</span></p><p>其表达的意思等同于下列方程组： <span class="math inline">\(\left\{\begin{array}{ll}x_1=-7x_3+3x_4\\x_2=4x_3-2x_4\end{array}\right.\)</span></p><ol start="2" type="1"><li><p>求出矩阵的秩：<span class="math inline">\(r\left(A\right)=2\)</span>，即有两个非自由变量，将矩阵<span class="math inline">\(X\)</span>写成如下形式（向量的个数等于变量的个数减去 <span class="math inline">\(r\left(A\right)\)</span> ）： <span class="math display">\[X=k_1\vec{\alpha_1}+k_2\vec{\alpha_2}\]</span></p></li><li><p>求出向量 <span class="math inline">\(\vec{\alpha_1},\,\vec{\alpha_2}\)</span>：找出自由变量的列数，并用<span class="math inline">\(0,\,1\)</span> 写在向量对应的行数：<span class="math inline">\(x_3,\,x_4\)</span> 是自由变量，<span class="math inline">\(x_1,\,x_2\)</span> 是非自由变量</p><p><span class="math display">\[\vec{\alpha_1}=\begin{pmatrix}\square\\\square\\1\\0\end{pmatrix},\,\vec{\alpha_2}=\begin{pmatrix}\square\\\square\\0\\1\end{pmatrix}\]</span></p><p>其它行则先将自由变量的系数取反后顺序填入： <span class="math display">\[\vec{\alpha_1}=\begin{pmatrix}-7\\4\\1\\0\end{pmatrix},\,\vec{\alpha_2}=\begin{pmatrix}3\\-2\\0\\1\\\end{pmatrix}\]</span></p></li><li><p>写出通解： <span class="math display">\[X=k_1\begin{pmatrix}-7\\4\\1\\0\end{pmatrix}+k_2\begin{pmatrix}3\\-2\\0\\1\end{pmatrix}\]</span></p></li></ol><p>对于非齐次线性方程组则仅需将自由变量对应的行全部取为0，然后其它位置填上<span class="math inline">\(\bar{A}\)</span>的最后一列的非零数即可。</p><h1 id="矩阵">矩阵</h1><h2 id="矩阵的运算">矩阵的运算</h2><p>矩阵的乘法：只有前列后行标相同才可以相乘，如<span class="math inline">\(A_{m\times n}\)</span>和<span class="math inline">\(B_{n\timess}\)</span>，得到的矩阵的行列数为前行后列，即<span class="math inline">\({AB}_{m\times s}\)</span>。</p><ul><li>性质<ul><li><span class="math inline">\(A\neq0,\,B\neq0\nRightarrowAB\neq0\)</span></li><li><span class="math inline">\(A\neq0\nRightarrowA^k\neq0\)</span></li></ul></li></ul><h2 id="矩阵的属性">矩阵的属性</h2><pre><code class=" mermaid">flowchart TB  矩阵 --- 行列式  矩阵 --- 特征值  矩阵 --- 特征向量  矩阵 --- 迹  矩阵 ---- 秩  subgraph 方阵    行列式    特征值 --特征值之积--&gt; 行列式    特征值 --特征值之和--&gt; 迹    特征向量  end</code></pre><h3 id="行列式">行列式</h3><p><span class="math display">\[D=\begin{vmatrix}  a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\  a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\  \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\  a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}\end{vmatrix} = \sum_{j_1j_2\cdotsj_n}{\left(-1\right)^{\tau\left(j_1j_2\cdotsj_n\right)}a_{1j_1}a_{2j_2}\cdots a_{nj_n} }\]</span></p><p><span class="math inline">\(Laplace\)</span> 展开： <span class="math display">\[\begin{vmatrix}D\end{vmatrix} =a_{i1}A_{i1}+a_{i2}A_{i2}+\cdots+a_{in}A_{in} =a_{1j}A_{1j}+a_{2j}A_{2j}+\cdots+a_{nj}A_{nj}\]</span></p><p>特殊的行列式：</p><ul><li><p>上/下三角行列式</p><p><span class="math display">\[\begin{vmatrix}a_{11} &amp; 0 &amp; \cdots &amp; 0 \\a_{21} &amp; a_{22} &amp; \cdots &amp; 0 \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}\end{vmatrix} =\begin{vmatrix}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\0 &amp; a_{22} &amp; \cdots &amp; a_{2n} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\0 &amp; 0 &amp; \cdots &amp; a_{nn}\end{vmatrix} = \sum_{i=1}^{n}a_{ii}\]</span></p></li><li><p>分块行列式 <span class="math display">\[\begin{vmatrix}  \boldsymbol{A} &amp; \boldsymbol{C} \\  \boldsymbol{O} &amp; \boldsymbol{B}\end{vmatrix} =\begin{vmatrix}  \boldsymbol{A} &amp; \boldsymbol{O} \\  \boldsymbol{D} &amp; \boldsymbol{B}\end{vmatrix} = \left|\boldsymbol{A}\right|\left|\boldsymbol{B}\right|\]</span></p></li><li><p><span class="math inline">\(Vandermonde\)</span> 行列式</p><p><span class="math display">\[\begin{vmatrix}1&amp;1&amp;\cdots&amp;1\\a_1&amp;a_2&amp;\cdots&amp;a_n\\a_1^2&amp;a_2^2&amp;\cdots&amp;a_n^2\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_1^{n-1}&amp;a_2^{n-1}&amp;\cdots&amp;a_n^{n-1}\end{vmatrix}=\prod_{n\geqi\gt j\geq 1}\left(a_i-a_j\right)\]</span></p></li><li><p>箭形（爪形）行列式</p><p><span class="math display">\[\begin{vmatrix}a_1&amp;1&amp;1&amp;\cdots&amp;1\\1&amp;a_2&amp;0&amp;\cdots&amp;0\\1&amp;0&amp;a_3&amp;\cdots&amp;0\\\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\1&amp;0&amp;0&amp;\cdots&amp;a_n\end{vmatrix}\;\left(a_2a_3\cdotsa_n\neq0\right)\]</span> <span class="math display">\[\xlongequal{c_1-\frac{1}{a_2}c_2-\frac{1}{a_3}c_3-\cdots-\frac{1}{a_n}c_n}\begin{vmatrix}a_1-\frac{1}{a_2}-\cdots-\frac{1}{a_n}&amp;1&amp;1&amp;\cdots&amp;1\\0&amp;a_2&amp;0&amp;\cdots&amp;0\\0&amp;0&amp;a_3&amp;\cdots&amp;0\\\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\0&amp;0&amp;0&amp;\cdots&amp;a_n\end{vmatrix}\]</span><span class="math display">\[=\prod_{i=2}^{n}a_i\left(a_1-\sum_{j=2}^{n}\frac{1}{a_j}\right)\]</span></p></li></ul><hr><h3 id="特征值与特征向量">特征值与特征向量</h3><blockquote><p>设 <span class="math inline">\(n\)</span> 阶方阵 <span class="math inline">\(A_{n\times n}\)</span>，若存在数 <span class="math inline">\(\lambda\)</span>（不一定是实数）以及非零向量 <span class="math inline">\(\vec\alpha\)</span>，使得 <span class="math inline">\(A\vec\alpha=\lambda\vec\alpha\)</span>，则称 <span class="math inline">\(\lambda\)</span> 为矩阵 <span class="math inline">\(A\)</span> 的<strong>特征值</strong>，<span class="math inline">\(\vec\alpha\)</span> 为 <span class="math inline">\(\vec\lambda\)</span>对应的<strong>特征向量</strong>。</p></blockquote><p>要求解特征向量与特征值，则需把定义的等式转化为其它形式：</p><p><span class="math inline">\(A\alpha=\lambda\alpha\Rightarrow\left(\lambdaE-A\right)\alpha=0\)</span>。</p><p><span class="math inline">\(\because\alpha\neq0\,\,\therefore\left(\lambdaE-A\right)X=0有非零解\Rightarrow\left|\lambdaE-A\right|=0\)</span>。</p><p>最终得到的等式即特征方程。</p><p>性质：</p><ul><li>若 <span class="math inline">\(A\vec\alpha=\lambda\vec\alpha\)</span> 成立，则<span class="math inline">\(f\left(A\right)\vec\alpha=f\left(\lambda\right)\vec\alpha\)</span>同样成立。</li><li>若方阵 <span class="math inline">\(A\)</span> 可逆，则 <span class="math inline">\(\displaystyleA^{-1}\alpha=\frac{1}{\lambda}\alpha,\,A^\ast\alpha=\frac{\left|A\right|}{\lambda}\alpha\)</span></li></ul><hr><h3 id="秩">秩</h3><p>本质上是线性方程组的约束条件个数。</p><blockquote><p>设矩阵 <span class="math inline">\(A_{m\times n}\)</span>，在 <span class="math inline">\(A\)</span> 中任取 <span class="math inline">\(r\)</span> 行 <span class="math inline">\(r\)</span> 列，构成 <span class="math inline">\(r\)</span> 阶行列式，称为 <span class="math inline">\(A\)</span> 的 <span class="math inline">\(r\)</span> 阶子式（个数：<span class="math inline">\(C_m^rC_n^r\)</span>）</p><p>若：</p><ol type="1"><li>存在不为零的 <span class="math inline">\(r\)</span> 阶子式</li><li>任意 <span class="math inline">\(r+1\)</span>阶子式要么不存在要么为零</li></ol><p>则 <span class="math inline">\(r\)</span> 为矩阵 <span class="math inline">\(A\)</span> 的秩 (Rank)，记为 <span class="math inline">\(r\left(A\right)=r\)</span></p></blockquote><p>对于 <span class="math inline">\(n\)</span> 阶可逆矩阵，由于 <span class="math inline">\(\left|A_{n\times n}\right|\neq0\)</span>，故 <span class="math inline">\(r\left(A\right)=n\)</span>。又因为其阶数与其秩相等，故称其为满秩矩阵。同理，如果方阵不可逆则<span class="math inline">\(\left|A\right|=0\)</span>，其最高阶非零子式的阶数必定小于<span class="math inline">\(n\)</span>，称其为降秩矩阵。</p><p>矩阵秩的性质：</p><ol type="1"><li><strong>矩阵秩必小于等于其行标列标的最小值</strong>：<span class="math inline">\(r\left(A_{m\times n}\right)\le\min{\left\{m,\n\right\}}\)</span></li><li><ul><li><span class="math inline">\(r\left(A\right)=0\LeftrightarrowA=0\)</span></li><li><span class="math inline">\(r\left(A\right)\geq1\LeftrightarrowA\neq0\)</span></li><li><span class="math inline">\(r\left(A\right)\geq2\LeftrightarrowA\)</span> 至少有2行不成比例</li></ul></li><li><strong>矩阵与其转置矩阵的秩相等</strong>： <span class="math inline">\(r\left(A\right)=r\left(A^T\right)=r\left(AA^T\right)=r\left(A^TA\right)\)</span></li><li><strong>矩阵作加减运算得到新矩阵的秩必小于等于原矩阵秩的加减</strong>：<span class="math inline">\(r\left(A\pm B\right)\ler\left(A\right)+r\left(B\right)\)</span></li><li><strong>矩阵相乘后秩小于等于原任一矩阵的秩</strong>：<span class="math inline">\(r\left(AB\right)\le r(A)、r\left(AB\right)\ler\left(B\right)、r\left(AB\right)\le\min{\left\{r\left(A\right),r\left(B\right)\right\}}\)</span></li><li><strong>矩阵相乘为零阵，秩之和小于等于内标</strong>：<span class="math inline">\(A_{m\times n},\,B_{n\times s}\)</span>，且 <span class="math inline">\(AB=0\)</span>，则 <span class="math inline">\(r\left(A\right)+r\left(B\right)\le n\)</span></li><li><strong>矩阵与可逆阵相乘，秩不变</strong>：若 <span class="math inline">\(n\)</span> 阶方阵 <span class="math inline">\(P,\,Q\)</span> 可逆，则 <span class="math inline">\(r\left(A\right)=r\left(PA\right)=r\left(AQ\right)=r(PAQ)\)</span></li><li><strong>伴随矩阵的秩与原矩阵秩的关系</strong>：<span class="math inline">\(r\left(A^\ast\right)=\left\{\begin{array}{ll}n&amp;r\left(A\right)=n\\1&amp;r\left(A\right)=n-1\\0&amp;r\left(A\right)\ltn-1\end{array}\right.\)</span></li></ol><h2 id="矩阵的关系">矩阵的关系</h2><pre><code class=" mermaid">flowchart TB  矩阵 --可逆方阵--&gt; 相似 &amp; 合同</code></pre><h3 id="方阵相似">方阵相似</h3><blockquote><p>设 <span class="math inline">\(n\)</span> 阶矩阵 <span class="math inline">\(A,\,B\)</span>，若存在可逆矩阵 <span class="math inline">\(P\)</span> 使得 <span class="math inline">\(P^{-1}AP=B\)</span>，则称 <span class="math inline">\(A\)</span> 与 <span class="math inline">\(B\)</span> 相似，记为 <span class="math inline">\(A~B\)</span>。</p></blockquote><h4 id="方阵的相似对角化">方阵的相似对角化</h4><blockquote><p>设 <span class="math inline">\(n\)</span> 阶方阵，若存在可逆阵 <span class="math inline">\(P\)</span> 使得 <span class="math inline">\(P^{-1}AP\)</span> 为对角阵，则称 <span class="math inline">\(A\)</span> 可对角化（即 <span class="math inline">\(A\)</span> 与某一对角矩阵相似）</p></blockquote><p><strong><span class="math inline">\(n\)</span>阶方阵可对角化的充要条件是存在 <span class="math inline">\(n\)</span>个线性无关的特征向量。</strong></p><p>方阵可对角化的判定</p><ul><li><span class="math inline">\(n\)</span> 阶方阵 <span class="math inline">\(A\)</span> 有 <span class="math inline">\(n\)</span> 个互不相同的特征值 <span class="math inline">\(\to A\)</span> 可对角化</li><li><span class="math inline">\(n\)</span> 阶方阵 <span class="math inline">\(A\)</span> 互异的特征值为 <span class="math inline">\(\lambda_1,\,\lambda_2,\,\cdots,\,\lambda_m\)</span>，重数依次为<span class="math inline">\(r_1,\,r_2,\,\cdots,\,r_m\Leftrightarrow\forall\lambda_i\)</span>，<span class="math inline">\(A\)</span> 有 <span class="math inline">\(r_i\)</span> 个线性无关的特征向量。</li></ul><p>方阵对角化的过程</p><ol type="1"><li><p><span class="math inline">\(\left|\lambdaE-A\right|=0\Rightarrow\lambda_1,\,\lambda_2,\\cdots,\,\lambda_n\)</span></p></li><li><p><span class="math inline">\(\left(\lambda_iE-A\right)X=0\Rightarrow\vec{\alpha_1},\,\vec{\alpha_2},\,\cdots,\,\vec{\alpha_m}\,(m\len)\)</span></p></li><li><p>仅当 <span class="math inline">\(m=n\)</span> 时才可以对角化</p><p>由 <span class="math inline">\(\left(A\vec{\alpha_1},\,A\vec{\alpha_2},\,\cdots,\,A\vec{\alpha_n}\right)=\left(\lambda_1\vec{\alpha_1},\,\lambda_2\vec{\alpha_2},\,\cdots,\,\lambda_n\vec{\alpha_n}\right)\)</span><span class="math inline">\(\require{extpfeil}\Newextarrow{\xRightarrow}{5,5}{0x21D2}\xRightarrow{P=\left(\vec{\alpha_1},\,\vec{\alpha_2},\,\cdots,\,\vec{\alpha_n}\right)}\newcommand\diag[1]{\begin{pmatrix}\begin{smallmatrix}#1_1&amp;&amp;&amp;\\&amp;#1_2&amp;&amp;\\&amp;&amp;\ddots&amp;\\&amp;&amp;&amp;#1_n\end{smallmatrix}\end{pmatrix}}AP=P\diag{\lambda}\RightarrowP^{-1}AP=\diag{\lambda}\)</span></p></li></ol><h2 id="派生矩阵">派生矩阵</h2><pre><code class=" mermaid">flowchart TB  矩阵 --方阵--&gt; 伴随矩阵 &amp; 逆矩阵  矩阵 --&gt; 转置矩阵</code></pre><hr><h3 id="伴随矩阵">伴随矩阵</h3><p><span class="math display">\[A=\begin{pmatrix}a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1n}\\a_{21}&amp;a_{22}&amp;\cdots&amp;a_{2n}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_{n1}&amp;a_{n2}&amp;\cdots&amp;a_{nn}\end{pmatrix}\rightarrowA^\ast=\begin{pmatrix}A_{11}&amp;A_{21}&amp;\cdots&amp;A_{n1}\\A_{12}&amp;A_{22}&amp;\cdots&amp;A_{n2}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\A_{1n}&amp;A_{2n}&amp;\cdots&amp;A_{nn}\end{pmatrix}\]</span>（其中 <span class="math inline">\(A_{ij}\)</span> 为元素 <span class="math inline">\(a_{ij}\)</span> 的代数余子式）</p><p>伴随矩阵的性质：</p><ul><li><span class="math inline">\(AA^\ast=A^\ast A=|A|E\)</span></li><li><span class="math inline">\(\left|A_{n\timesn}^\ast\right|=\left|A_{n\times n}\right|^{n-1}\)</span></li></ul><hr><h3 id="逆矩阵">逆矩阵</h3><p>别名：</p><ul><li>满秩矩阵，<span class="math inline">\(r\left(A_{n\times{n}}\right)=n\)</span></li><li>非奇异矩阵</li></ul><p>求法：</p><ul><li>伴随矩阵法<ul><li>原理：<span class="math inline">\(\displaystyleA^{-1}=\frac{1}{|A|}A^\ast\)</span></li></ul></li><li>矩阵的初等行变换法<ul><li>原理：<span class="math inline">\(\displaystyle\begin{pmatrix}\begin{array}{c:c}A&amp;E\end{array}\end{pmatrix}\to\begin{pmatrix}\begin{array}{c:c}E&amp;A^{-1}\end{array}\end{pmatrix}\)</span></li></ul></li></ul><p>存在的条件：</p><ul><li>矩阵必须为方阵</li><li>（充要条件）<span class="math inline">\(\left|A\right|\neq0\)</span></li></ul><p>逆矩阵的性质：</p><ul><li><span class="math inline">\(\left(A^{-1}\right)^{-1}=A\)</span></li><li><span class="math inline">\(\left(kA\right)^{-1}=\frac{1}{k}A^{-1}\)</span></li><li><span class="math inline">\(\left(AB\right)^{-1}=B^{-1}A^{-1}\)</span></li><li><span class="math inline">\(\left(A^T\right)^{-1}=\left(A^{-1}\right)^T\)</span></li><li><span class="math inline">\(\left|A^{-1}\right|=\left|A\right|^{-1}\)</span></li></ul><hr><h3 id="特殊的矩阵">特殊的矩阵</h3><pre><code class=" mermaid">flowchart TB  矩阵 --方阵--&gt; 实对称矩阵</code></pre><h4 id="实对称矩阵">实对称矩阵</h4><ul><li>不同特征值对应的特征向量是正交的</li><li>特征值都是实数，特征向量都是实向量</li><li>必可相似对角化，且相似对角阵上的元素即为矩阵本身特征值</li></ul><h1 id="向量">向量</h1><p>向量组等价：若两个向量组的向量可以相互线性表示，则两向量组等价</p><p>极大线性无关组：设 <span class="math inline">\(\alpha_1,\,\alpha_2,\,\cdots,\,\alpha_n\)</span>为向量组，若存在 <span class="math inline">\(r\)</span>个向量线性无关；且任取 <span class="math inline">\(r+1\)</span>个向量（不一定有）线性相关，则称这 <span class="math inline">\(r\)</span>个线性无关的向量组为极大无关组（不一定唯一），<span class="math inline">\(r\)</span> 即向量组的秩。</p><p><span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 注意</p><ul><li>向量组与其极大线性无关组等价。</li><li>设 <span class="math inline">\(\alpha_1,\,\alpha_2,\,\cdots,\,\alpha_n\)</span>为向量组，则：<ul><li><span class="math inline">\(\alpha_1,\,\alpha_2,\,\cdots,\,\alpha_n\)</span>线性无关<span class="math inline">\(\Rightarrow\alpha_1,\,\alpha_2,\,\cdots,\,\alpha_n\)</span>为极大线性无关组 <span class="math inline">\(\Rightarrow\)</span>向量组的秩 <span class="math inline">\(=n\)</span>。</li><li><span class="math inline">\(\alpha_1,\,\alpha_2,\,\cdots,\,\alpha_n\)</span>线性相关 <span class="math inline">\(\Rightarrow\)</span> 向量组的秩<span class="math inline">\(\lt n\)</span>。</li></ul></li><li>设向量组 <span class="math inline">\(\mathrm{I}:\,\alpha_1,\,\alpha_2,\,\cdots,\,\alpha_n;\;\mathrm{II}:\,\alpha_1,\,\alpha_2,\,\cdots,\,\alpha_n,\,\beta\)</span>，则：<ul><li><span class="math inline">\(R\left(\mathrm{I}\right)=R\left(\mathrm{II}\right)\Rightarrow\beta\)</span>可以由组 <span class="math inline">\(\mathrm{I}\)</span> 线性表示</li><li><span class="math inline">\(R\left(\mathrm{I}\right)=R\left(\mathrm{II}\right)+1\Rightarrow\beta\)</span>不可由组 <span class="math inline">\(\mathrm{I}\)</span> 线性表示</li></ul></li><li>设矩阵 <span class="math inline">\(A_{m\times n},\,B_{n\timess}=\left(\beta_1,\,\beta_2,\,\cdots,\,\beta_s\right)\)</span>，则 <span class="math inline">\(AB=\left({A\beta}_1,\,{A\beta}_2,\,\cdots,\,{A\beta}_s\right)\)</span><ul><li>例：<span class="math inline">\(A=\begin{pmatrix}\begin{smallmatrix}\alpha_1,\,\alpha_2,\,\alpha_3\end{smallmatrix}\end{pmatrix},\,B=\begin{pmatrix}\begin{smallmatrix}\alpha_1-\alpha_2+\alpha_3,\,2\alpha_1+\alpha_2,\,\alpha_2-4\alpha_3\end{smallmatrix}\end{pmatrix}\)</span>，则<span class="math inline">\(B=A\begin{pmatrix}\begin{smallmatrix}1&amp;2&amp;0\\-1&amp;1&amp;1\\1&amp;0&amp;-4\end{smallmatrix}\end{pmatrix}\)</span>。</li></ul></li></ul><p>向量组秩的诸性质</p><ul><li>设向量组<span class="math inline">\(\mathrm{I}:\,\alpha_1,\,\alpha_2,\,\cdots,\,\alpha_m;\;\mathrm{II}:\,\beta_1,\,\beta_2,\,\cdots,\,\beta_n\)</span>。若组<span class="math inline">\(\mathrm{I}\)</span> 可由组 <span class="math inline">\(\mathrm{II}\)</span> 线性表示，则 <span class="math inline">\(R\left(\mathrm{I}\right)\leqR\left(\mathrm{II}\right)\)</span></li><li>两个等价向量组的秩相等，反之不对。</li></ul><h2 id="向量的正交">向量的正交</h2><p>若 <span class="math inline">\(\left(\alpha,\,\beta\right)=0\)</span>则 <span class="math inline">\(\alpha,\,\beta\)</span> 正交，记为 <span class="math inline">\(\alpha\bot\beta\)</span>。正交的向量一定线性无关。</p><p>性质：</p><ul><li>非零向量 <span class="math inline">\(\alpha_1,\,\alpha_2,\,\cdots,\,\alpha_n\)</span>两两正交，则 <span class="math inline">\(\alpha_1,\,\alpha_2,\,\cdots,\,\alpha_n\)</span>线性无关。</li></ul><h3 id="施密特正交化">施密特正交化</h3><p>设向量组 <span class="math inline">\(\alpha_1,\,\alpha_2,\,\cdots,\,\alpha_n\)</span>，经过施密特正交化（Schmidtorthogonalization）后得到的向量组为：</p><p><span class="math display">\[\left\{\begin{array}{l}\beta_1=\alpha_1\\\beta_2=\alpha_2-\frac{\begin{pmatrix}\alpha_2,\,\beta_1\end{pmatrix}}{\begin{pmatrix}\beta_1,\,\beta_1\end{pmatrix}}\beta_1\\\beta_3=\alpha_3-\frac{\begin{pmatrix}\alpha_3,\,\beta_1\end{pmatrix}}{\begin{pmatrix}\beta_1,\,\beta_1\end{pmatrix}}\beta_1-\frac{\begin{pmatrix}\alpha_3,\,\beta_2\end{pmatrix}}{\begin{pmatrix}\beta_2,\,\beta_2\end{pmatrix}}\beta_2\\\;\,\quad\vdots\\\beta_n=\alpha_n-\frac{\begin{pmatrix}\alpha_n,\,\beta_1\end{pmatrix}}{\begin{pmatrix}\beta_1,\,\beta_1\end{pmatrix}}\beta_1-\cdots-\frac{\begin{pmatrix}\alpha_n,\,\beta_{n-1}\end{pmatrix}}{\begin{pmatrix}\beta_{n-1},\,\beta_{n-1}\end{pmatrix}}\beta_{n-1}\end{array}\right.\]</span></p><h1 id="二次型">二次型</h1><h2 id="标准形">标准形</h2><blockquote><p>只含有平方项的二次型称为二次型的标准形，其<strong>秩等于正负惯性指数之和</strong>（正惯性指数就是标准形中正平方项的个数，负惯性指数同理）</p><blockquote><p>在标准形中，若平方项的系数为<span class="math inline">\(-1,\,1,\,0\)</span>，则称其为二次型的<strong>规范形</strong></p></blockquote></blockquote><h3 id="化二次型为标准型的方法">化二次型为标准型的方法</h3><p><strong>任意实对称矩阵与对角阵合同</strong></p><h4 id="正交变换法">正交变换法</h4><ol type="1"><li>把二次型表示成矩阵形式 <span class="math inline">\(x^T\boldsymbol{A}x\)</span></li><li>求出 <span class="math inline">\(\boldsymbol{A}\)</span>的全部互异特征值 <span class="math inline">\(\lambda_i\)</span>，设<span class="math inline">\(\lambda_i\)</span> 是 <span class="math inline">\(n\)</span> 重根</li><li>对每个特征值 <span class="math inline">\(\lambda_i\)</span>，求解齐次线性方程组 <span class="math inline">\(\left(\lambda_i\boldsymbol{E}-\boldsymbol{A}\right)x=0\)</span>；求得基础解系，即属于<span class="math inline">\(\lambda_i\)</span> 的线性无关的特征向量</li><li>将 <span class="math inline">\(\boldsymbol{A}\)</span>的属于同一个特征值的特征向量正交化</li><li>将全部向量单位化</li><li>将向量作列，按照 <span class="math inline">\(\lambda_i\)</span>在对角矩阵主对角线上的位置构成正交矩阵 <span class="math inline">\(\boldsymbol{Q}\)</span></li><li>令<span class="math inline">\(x=\boldsymbol{Q}y\)</span>，得 <span class="math inline">\(x^T\boldsymbol{A}x=\lambda_1y_1^2+\lambda_2y_2^2+\cdots+\lambda_ny_n^2\)</span></li></ol><h2 id="正定二次型">正定二次型</h2><blockquote><p>若二次型 <span class="math inline">\(f=x^T\boldsymbol{A}x\)</span>对任意 <span class="math inline">\(x\neq0\)</span> 都有 <span class="math inline">\(f\gt0\)</span>，则称 <span class="math inline">\(f\)</span> 为<strong>正定二次型</strong>，矩阵<span class="math inline">\(A\)</span> 称为正定矩阵。</p></blockquote><p>判别法</p><ul><li><span class="math inline">\(f\)</span> 的标准型的 <span class="math inline">\(n\)</span> 个系数全为正</li><li><span class="math inline">\(f\)</span> 的正惯性指数为 <span class="math inline">\(n\)</span></li><li><span class="math inline">\(f\)</span> 的矩阵 <span class="math inline">\(A\)</span> 的特征值全大于零</li><li>存在可逆阵 <span class="math inline">\(P\)</span>，使得 <span class="math inline">\(P^TAP=E\)</span> 或 <span class="math inline">\(A=P^TP\)</span></li><li><span class="math inline">\(f\)</span> 的矩阵 <span class="math inline">\(A\)</span> 的各顺序主子式全大于零<ul><li><p>顺序主子式</p><p>设 <span class="math inline">\(\displaystyleA=\begin{pmatrix}\begin{smallmatrix}a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1n}\\a_{21}&amp;a_{22}&amp;\cdots&amp;a_{2n}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_{n1}&amp;a_{n2}&amp;\cdots&amp;a_{nn}\end{smallmatrix}\end{pmatrix}\)</span>，则<span class="math inline">\(\displaystyle\begin{vmatrix}A_k\end{vmatrix}=\begin{vmatrix}a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1k}\\a_{21}&amp;a_{22}&amp;\cdots&amp;a_{2k}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_{k1}&amp;a_{k2}&amp;\cdots&amp;a_{kk}\end{vmatrix}\)</span>称为 <span class="math inline">\(n\)</span> 阶方阵 <span class="math inline">\(A\)</span> 的 <span class="math inline">\(k\)</span> 阶顺序主子式。</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《算法导论》笔记</title>
    <link href="/2023/Note_Of_Introduction_To_Algorithms/"/>
    <url>/2023/Note_Of_Introduction_To_Algorithms/</url>
    
    <content type="html"><![CDATA[<h1 id="introduction-to-algorithms">Introduction to Algorithms</h1><h2 id="算法衡量指标">算法衡量指标</h2><p>渐进表示法 Asymptotic notation</p><ul><li><p><span class="math inline">\(O\)</span> 表示法 - 函数存在<strong>渐进上界</strong></p><p>设函数<span class="math inline">\(f(n),\,g(n)\)</span>，则集合<span class="math inline">\(O(g(n))\)</span>可表示为： <span class="math display">\[\{f(n)\,|\,\exists{c,n_0}&gt;0,\,\forall{n\geq{n_0}},\,0\leq{f(n)}\leq{cg(n)}\}\]</span></p></li><li><p><span class="math inline">\(\Omega\)</span> 表示法 - 函数存在<strong>渐进下界</strong></p><p>设函数<span class="math inline">\(f(n),\,g(n)\)</span>，则集合<span class="math inline">\(\Omega(g(n))\)</span>可表示为： <span class="math display">\[\{f(n)\,|\,\exists{c,n_0}&gt;0,\,\forall{n\geq{n_0}},\,0\leq{cg(n)}\leq{f(n)}\}\]</span></p></li><li><p><span class="math inline">\(\Theta\)</span> 表示法 - 函数存在<strong>渐进紧确界</strong></p><p>设函数<span class="math inline">\(f(n),\,g(n)\)</span>，则集合<span class="math inline">\(\Theta(g(n))\)</span>可表示为： <span class="math display">\[\{f(n)\,|\,\exists{c_1,c_2,n_0}&gt;0,\,\forall{n\geq{n_0}},\,0\leq{c_1g(n)}\leq{f(n)}\leq{c_2g(n)}\}\]</span></p></li></ul><h2 id="排序">排序</h2><h3 id="插入排序-insertion-sort">插入排序 Insertion sort</h3><table><thead><tr class="header"><th style="text-align: center;">方法</th><th style="text-align: center;">最好情况</th><th style="text-align: center;">最差情况</th><th style="text-align: center;">平均情况</th><th style="text-align: center;">辅助存储</th><th style="text-align: center;">稳定性</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">直接插入排序</td><td style="text-align: center;"><span class="math inline">\(O(n)\)</span></td><td style="text-align: center;"><span class="math inline">\(O(n^2)\)</span></td><td style="text-align: center;"><span class="math inline">\(O(n^2)\)</span></td><td style="text-align: center;"><span class="math inline">\(O(1)\)</span></td><td style="text-align: center;">稳定</td></tr><tr class="even"><td style="text-align: center;">希尔排序</td><td style="text-align: center;"><span class="math inline">\(O(n)\)</span></td><td style="text-align: center;"><span class="math inline">\(O(n^2)\)</span></td><td style="text-align: center;"><span class="math inline">\(\approx{O(n^{1.3})}\)</span></td><td style="text-align: center;"><span class="math inline">\(O(1)\)</span></td><td style="text-align: center;">不稳定</td></tr></tbody></table><h3 id="交换排序">交换排序</h3><table><thead><tr class="header"><th style="text-align: center;">方法</th><th style="text-align: center;">最好情况</th><th style="text-align: center;">最差情况</th><th style="text-align: center;">平均情况</th><th style="text-align: center;">辅助存储</th><th style="text-align: center;">稳定性</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">冒泡排序</td><td style="text-align: center;"><span class="math inline">\(O(n)\)</span></td><td style="text-align: center;"><span class="math inline">\(O(n^2)\)</span></td><td style="text-align: center;"><span class="math inline">\(O(n^2)\)</span></td><td style="text-align: center;"><span class="math inline">\(O(1)\)</span></td><td style="text-align: center;">稳定</td></tr><tr class="even"><td style="text-align: center;">快速排序</td><td style="text-align: center;"><span class="math inline">\(O(n\log_2{n})\)</span></td><td style="text-align: center;"><span class="math inline">\(O(n^2)\)</span></td><td style="text-align: center;"><span class="math inline">\(O(n\log_2{n})\)</span></td><td style="text-align: center;"><span class="math inline">\(O(n\log_2{n})\)</span></td><td style="text-align: center;">不稳定</td></tr></tbody></table><h3 id="选择排序-selection-sort">选择排序 Selection sort</h3><table><thead><tr class="header"><th style="text-align: center;">方法</th><th style="text-align: center;">最好情况</th><th style="text-align: center;">最差情况</th><th style="text-align: center;">平均情况</th><th style="text-align: center;">辅助存储</th><th style="text-align: center;">稳定性</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">简单选择排序</td><td style="text-align: center;"><span class="math inline">\(O(n^2)\)</span></td><td style="text-align: center;"><span class="math inline">\(O(n^2)\)</span></td><td style="text-align: center;"><span class="math inline">\(O(n^2)\)</span></td><td style="text-align: center;"><span class="math inline">\(O(1)\)</span></td><td style="text-align: center;">不稳定</td></tr><tr class="even"><td style="text-align: center;">堆排序</td><td style="text-align: center;"><span class="math inline">\(O(n\log_2{n})\)</span></td><td style="text-align: center;"><span class="math inline">\(O(n\log_2{n})\)</span></td><td style="text-align: center;"><span class="math inline">\(O(n\log_2{n})\)</span></td><td style="text-align: center;"><span class="math inline">\(O(1)\)</span></td><td style="text-align: center;">不稳定</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不同语言中常用的操作</title>
    <link href="/2023/Practical_Codes_In_Different_Languages/"/>
    <url>/2023/Practical_Codes_In_Different_Languages/</url>
    
    <content type="html"><![CDATA[<h1 id="不同语言中常用的操作">不同语言中常用的操作</h1><p>简要记录一下，以防某一天用时才想着四处寻找 ## 遍历文件 C++标准库（C++17 及以上） </p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::filesystem;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; i : <span class="hljs-built_in">directory_iterator</span>(<span class="hljs-string">"C:\\example"</span>)) {<br>        cout &lt;&lt; i.<span class="hljs-built_in">path</span>().<span class="hljs-built_in">string</span>() &lt;&lt; endl;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p></p><p>Python 有两种标准库中支持的遍历方法： 1. <code>os.walk()</code>函数（递归遍历所有子孙目录） 该函数返回一个三元元组<code>(dirpath, dirnames, filenames)</code>，分别表示根目录、路径下所有的子目录、路径下所有的文件。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>  <span class="hljs-keyword">for</span> dirpath, dirnames, filenames <span class="hljs-keyword">in</span> os.walk(<span class="hljs-string">'C:\\example'</span>):<br>     <span class="hljs-keyword">for</span> filepath <span class="hljs-keyword">in</span> filenames:<br>         <span class="hljs-built_in">print</span>(os.path.join(dirpath, filepath))<br></code></pre></td></tr></tbody></table></figure> 2. <code>os.listdir()</code> 函数 不同于<code>os.walk()</code>，该函数仅遍历指定路径下所有的文件以及文件夹，但不会遍历子孙文件夹。<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>  <span class="hljs-keyword">for</span> entry <span class="hljs-keyword">in</span> os.listdir(<span class="hljs-string">'C:\\example'</span>):<br>     path: <span class="hljs-built_in">str</span> = os.path.join(<span class="hljs-string">'C:\\example'</span>, entry)<br>     <span class="hljs-keyword">if</span> os.path.isfile(path):<br>         <span class="hljs-built_in">print</span>(path)<br></code></pre></td></tr></tbody></table></figure><p></p><p>Go 标准库同样提供了类似于 Python 中的两种方法： 1.<code>filepath.Walk</code> - 类似于 Python 中的 <code>os.walk()</code>函数，递归遍历所有子孙目录。 </p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">"fmt"</span><br>   <span class="hljs-string">"os"</span><br>   <span class="hljs-string">"path/filepath"</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br>    <span class="hljs-keyword">var</span> files = <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">16</span>)<br>    err := filepath.Walk(<span class="hljs-string">"C:\\example"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(path <span class="hljs-type">string</span>, info os.FileInfo, err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">error</span> {<br>        <span class="hljs-keyword">if</span> !info.IsDir() { <span class="hljs-comment">// Not a directory</span><br>            files = <span class="hljs-built_in">append</span>(files, path)<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    })<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<br>        <span class="hljs-built_in">panic</span>(err)<br>    }<br>    <span class="hljs-keyword">for</span> _, file := <span class="hljs-keyword">range</span> files {<br>        fmt.Println(file)<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure> 2. <code>File.ReadDir</code>- 类似于 Python 中的<code>os.listdir()</code>，只遍历目录下的文件或文件夹，不包含子孙目录。<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br> <span class="hljs-string">"fmt"</span><br> <span class="hljs-string">"os"</span><br> <span class="hljs-string">"path/filepath"</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br> cur_path := <span class="hljs-string">"C:\\example"</span><br> f, _ := os.Open(cur_path)<br> files, _ := f.ReadDir(<span class="hljs-number">-1</span>)<br> err := f.Close()<br> <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<br> <span class="hljs-built_in">panic</span>(err)<br> }<br> <span class="hljs-keyword">for</span> _, file := <span class="hljs-keyword">range</span> files {<br>  <span class="hljs-keyword">if</span> !file.IsDir() {<br>   fmt.Println(filepath.Join(cur_path, file.Name()))<br>  }<br> }<br>}<br></code></pre></td></tr></tbody></table></figure><p></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>编程语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 学习笔记</title>
    <link href="/2023/Go_Manuscript/"/>
    <url>/2023/Go_Manuscript/</url>
    
    <content type="html"><![CDATA[<h1 id="the-go-programming-language">The Go Programming Language</h1><h2 id="与其它语言的对比">与其它语言的对比</h2><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">Go</th><th style="text-align: center;">C/C++</th><th style="text-align: center;">Java</th><th style="text-align: center;">Python</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">内存管理</td><td style="text-align: center;">GC</td><td style="text-align: center;">手动管理</td><td style="text-align: center;">GC</td><td style="text-align: center;">GC</td></tr><tr class="even"><td style="text-align: center;">有无标准格式</td><td style="text-align: center;">✔️</td><td style="text-align: center;">❌</td><td style="text-align: center;">❌</td><td style="text-align: center;">❌</td></tr><tr class="odd"><td style="text-align: center;">操作符重载</td><td style="text-align: center;">❌</td><td style="text-align: center;">✔️</td><td style="text-align: center;">❌</td><td style="text-align: center;">✔️</td></tr><tr class="even"><td style="text-align: center;">参数默认值</td><td style="text-align: center;">❌</td><td style="text-align: center;">✔️</td><td style="text-align: center;">❌</td><td style="text-align: center;">✔️</td></tr><tr class="odd"><td style="text-align: center;">构造函数与析构函数</td><td style="text-align: center;">❌</td><td style="text-align: center;">✔️</td><td style="text-align: center;">仅构造函数</td><td style="text-align: center;">✔️</td></tr><tr class="even"><td style="text-align: center;">继承</td><td style="text-align: center;">❌</td><td style="text-align: center;">✔️</td><td style="text-align: center;">✔️</td><td style="text-align: center;">✔️</td></tr><tr class="odd"><td style="text-align: center;">模板</td><td style="text-align: center;">❌</td><td style="text-align: center;">✔️</td><td style="text-align: center;">✔️</td><td style="text-align: center;">❌</td></tr><tr class="even"><td style="text-align: center;">异常</td><td style="text-align: center;">❌</td><td style="text-align: center;">✔️</td><td style="text-align: center;">✔️</td><td style="text-align: center;">✔️</td></tr><tr class="odd"><td style="text-align: center;">宏</td><td style="text-align: center;">❌</td><td style="text-align: center;">✔️</td><td style="text-align: center;">❌</td><td style="text-align: center;">❌</td></tr><tr class="even"><td style="text-align: center;">隐式数值类型转换</td><td style="text-align: center;">❌</td><td style="text-align: center;">✔️</td><td style="text-align: center;">❌</td><td style="text-align: center;">✔️</td></tr><tr class="odd"><td style="text-align: center;">注解</td><td style="text-align: center;">❌</td><td style="text-align: center;">❌</td><td style="text-align: center;">✔️</td><td style="text-align: center;">❌</td></tr></tbody></table><h2 id="go-官方工具链">Go 官方工具链</h2><p>工具 <code>go</code> - <code>go run source-code.go</code> -直接运行Go程序 - <code>go build source-code.go</code> - 编译Go源代码</p><p>代码格式化工具 <code>gofmt</code></p><h2 id="go-语法">Go 语法</h2><h3 id="package-包">package 包</h3><p>类似于 Java 的package，但不要求放在对应的目录中。一个包可以由多个源代码文件组成。</p><p>常用的包： - <code>os</code> - 操作系统无关的函数及变量（类似 Python的 <code>os</code>） - <code>fmt</code> - 输入输出（类似 C++的<code>iostream</code>）</p><p>导入包的语法</p><p><code>import fmt</code> - 导入单个包 <code>fmt</code> </p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">"fmt"</span><br>    <span class="hljs-string">"os"</span><br>)<br></code></pre></td></tr></tbody></table></figure>导入两个包 <code>fmt</code> 和 <code>os</code><p></p><h3 id="编写语句">编写语句</h3><h4 id="注意事项">⚠️ <strong>注意事项</strong></h4><ul><li>和 Python 一样，每行一般无需分号，但是<strong>如果一行内有多个语句则要加分号</strong></li><li>大括号必须紧跟函数声明或 for 循环之后，不能换行</li><li>换行只能在操作符之后换行，不能在操作符前换行</li></ul><h4 id="变量声明">变量声明</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> variable_name <span class="hljs-type">int</span><br></code></pre></td></tr></tbody></table></figure><p>声明一个变量格式如上，首先用关键字 <code>var</code>说明要声明的是变量，随后跟上变量名，最后指明其数据类型。</p><p>以该方式声明的变量会被赋初值，<code>int</code> 类型的会被赋值0，<code>bool</code> 类型赋值 <code>false</code>，<code>string</code>类型则赋值 <code>""</code>。</p><p>Go 支持自动类型推导，故以下两个语句是等价的 </p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span> = <span class="hljs-string">"ABCD"</span> <span class="hljs-comment">// 显式声明变量的类型</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">"ABCD"</span> <span class="hljs-comment">// 自动类型推导</span><br></code></pre></td></tr></tbody></table></figure><p></p><p>也可以同时声明/初始化多个变量： </p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i, j, k <span class="hljs-type">int</span> <span class="hljs-comment">// int, int, int</span><br><span class="hljs-keyword">var</span> b, f, s = <span class="hljs-literal">true</span>, <span class="hljs-number">2.3</span>, <span class="hljs-string">"four"</span> <span class="hljs-comment">// bool, float64, string</span><br><br><span class="hljs-comment">// 使用多返回值的函数来初始化多变量</span><br><span class="hljs-keyword">var</span> f, err = os.Open(name) <span class="hljs-comment">// os.Open 函数返回 file 和 error</span><br></code></pre></td></tr></tbody></table></figure><p></p><p>还有一种变量声明的方法，被称为短变量声明 (short variabledeclaration)，可以看作是一种语法糖，不需要添加关键字<code>var</code>，而是使用一个新的符号<code>:=</code>。<strong>需要注意的是，该种形式只能在函数内部充当局部变量，不能作为全局变量。</strong></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">"ABCD"</span><br></code></pre></td></tr></tbody></table></figure><p></p><p>需要注意的是，<code>:=</code> 是声明，而 <code>=</code>是赋值。因此使用 <code>:=</code>时，必须至少有一个变量是语法块中新的变量；如果是一个已经被声明的变量，则其行为和赋值操作一样。</p><h3 id="操作符">操作符</h3><p>自增、自减操作符：<code>++</code>、<code>--</code>，<strong>只能在变量之后使用</strong>，不能前缀使用，也就是<code>c++</code> 是合法的，但是 <code>++c</code>非法；使用这两种操作符时，语句仅仅只是个语句，而不是表达式，不能得到值，也就是C/C++ 中的 <code>j = i++</code> 在 Go 中是非法的。</p><h3 id="循环">循环</h3><p>Go 中循环只有一个，使用 <code>for</code> 关键字来定义，语法如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> initialization; condition; post {<br>    <span class="hljs-comment">// 零个或多个语句</span><br>}<br></code></pre></td></tr></tbody></table></figure> 与 C/C++相同的是，三个语句皆可省略，但是省略了之后分号也可以省略： <figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 省略 initialization 和 post</span><br><span class="hljs-keyword">for</span> condition {<br>    <span class="hljs-comment">// 实现 C/C++ 中 while 循环同样的效果</span><br>}<br><br><span class="hljs-comment">// 省略所有</span><br><span class="hljs-keyword">for</span> {<br>    <span class="hljs-comment">// 无限循环，实现 while(true) 的效果</span><br>}<br></code></pre></td></tr></tbody></table></figure>Go 也可以使用类似 Python 中的 for range 循环： <figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">""</span><br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] {<br>    s += <span class="hljs-string">" "</span> + arg<br>}<br></code></pre></td></tr></tbody></table></figure> 其中 range会在每次循环开始之时返回两个对象，一个索引(index)，一个则是索引对应的值。若要弃用某一个值，则用 <code>_</code>代替。<p></p><h3 id="指针">指针</h3><p>和 C/C++ 一样，可以对某个对象使用取地址操作符<code>&amp;</code>，对指针使用 <code>*</code>操作符可以获取其指向的对象： </p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 返回一个 int 指针</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function</span><span class="hljs-params">()</span></span> *<span class="hljs-type">int</span> {<br>    v := <span class="hljs-number">10</span><br>    <span class="hljs-keyword">return</span> &amp;v <span class="hljs-comment">// 在 C/C++ 中这么做会导致“野指针”问题，返回栈对象的指针的结果是随机的</span><br>}<br></code></pre></td></tr></tbody></table></figure> 任何指针的默认值是<code>nil</code>，相当于 C++ 中的 <code>nullptr</code>。由于 Go不存在未被初始化的变量之说，故只声明一个指针而不赋值只会得到一个空指针。<p></p><p>Go 也提供了直接创建指针的机制，即使用 <code>new(T)</code>函数。但是需要注意的是，其行为和对局部变量取地址是等价的，也就是下面两段代码等价：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newInt</span><span class="hljs-params">()</span></span> *<span class="hljs-type">int</span> {<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)<br>}<br></code></pre></td></tr></tbody></table></figure> <figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newInt</span><span class="hljs-params">()</span></span> *<span class="hljs-type">int</span> {<br>    <span class="hljs-keyword">var</span> dummy <span class="hljs-type">int</span><br>    <span class="hljs-keyword">return</span> &amp;dummy<br>}<br></code></pre></td></tr></tbody></table></figure><p></p><h3 id="内建数据类型">内建数据类型</h3><h4 id="切片-slice">切片 slice</h4><p>类似于数组，但是大小可以变化</p><p>创建方式： </p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建一个初始元素长度为5的切片，元素初始值为0： </span><br>mySlice1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>) <br><span class="hljs-comment">// 创建一个初始元素长度为5的切片，元素初始值为0，并预留10个元素的存储空间： </span><br>mySlice2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>) <br><span class="hljs-comment">// 切片字面量创建长度为5容量为5的切片,需要注意的是 [ ] 里面不要写数组的容量，因为如果写了个数以后就是数组了，而不是切片了。</span><br>mySlice3 := []<span class="hljs-type">int</span>{<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>}<br></code></pre></td></tr></tbody></table></figure><p></p><h4 id="映射-map">映射 map</h4><p>存储一系列的键值对，类似于 C++ 中的<code>std::unordered_map</code></p><p>创建方式： </p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建了一个键类型为string、值类型为PersonInfo</span><br>myMap = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>] PersonInfo) <br><span class="hljs-comment">// 也可以选择是否在创建时指定该map的初始存储能力，创建了一个初始存储能力为100的map</span><br>myMap = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>] PersonInfo, <span class="hljs-number">100</span>) <br><span class="hljs-comment">// 创建并初始化map的代码</span><br>myMap = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>] PersonInfo { <br>  <span class="hljs-string">"1234"</span>: PersonInfo{<span class="hljs-string">"1"</span>, <span class="hljs-string">"Jack"</span>, <span class="hljs-string">"Room 101,..."</span>}, <br>} <br></code></pre></td></tr></tbody></table></figure><p></p><p>遍历： </p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// map 的遍历是随机的，没有指定的顺序</span><br><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> myMap {<br>    <span class="hljs-comment">// myMap 为 map 对象</span><br>}<br></code></pre></td></tr></tbody></table></figure> 在作为参数传递时，是<strong>按引用传递</strong>的，因此在某一函数中对其作修改，也会影响到其它函数。<p></p><h2 id="生命周期">生命周期</h2><p>Go 的 GC 回收策略</p><h2 id="编译的诸限制">编译的诸限制</h2><ul><li>如果存在未被引用的包，则不能通过编译</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>编程语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
