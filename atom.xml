<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杂货小铺</title>
  
  <subtitle>位于网络一隅的博客</subtitle>
  <link href="https://devexzh.github.io/atom.xml" rel="self"/>
  
  <link href="https://devexzh.github.io/"/>
  <updated>2023-01-16T06:18:35.798Z</updated>
  <id>https://devexzh.github.io/</id>
  
  <author>
    <name>Ryker Zhu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>不同语言中常用的操作</title>
    <link href="https://devexzh.github.io/2023/Practical_Codes_In_Different_Languages/"/>
    <id>https://devexzh.github.io/2023/Practical_Codes_In_Different_Languages/</id>
    <published>2023-01-16T04:57:25.367Z</published>
    <updated>2023-01-16T06:18:35.798Z</updated>
    
    <content type="html"><![CDATA[<h1>不同语言中常用的操作</h1><p>简要记录一下，以防某一天用时才想着四处寻找</p><h2 id="遍历文件">遍历文件</h2><p>C++ 标准库（C++17 及以上）</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::filesystem;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; i : <span class="hljs-built_in">directory_iterator</span>(<span class="hljs-string">"C:\\example"</span>)) {<br>        cout &lt;&lt; i.<span class="hljs-built_in">path</span>().<span class="hljs-built_in">string</span>() &lt;&lt; endl;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>Python 有两种标准库中支持的遍历方法：</p><ol><li><code>os.walk()</code> 函数（递归遍历所有子孙目录）<br>该函数返回一个三元元组 <code>(dirpath, dirnames, filenames)</code>，分别表示根目录、路径下所有的子目录、路径下所有的文件。<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>  <span class="hljs-keyword">for</span> dirpath, dirnames, filenames <span class="hljs-keyword">in</span> os.walk(<span class="hljs-string">'C:\\example'</span>):<br>     <span class="hljs-keyword">for</span> filepath <span class="hljs-keyword">in</span> filenames:<br>         <span class="hljs-built_in">print</span>(os.path.join(dirpath, filepath))<br></code></pre></td></tr></tbody></table></figure></li><li><code>os.listdir()</code> 函数<br>不同于 <code>os.walk()</code>，该函数仅遍历指定路径下所有的文件以及文件夹，但不会遍历子孙文件夹。<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>  <span class="hljs-keyword">for</span> entry <span class="hljs-keyword">in</span> os.listdir(<span class="hljs-string">'C:\\example'</span>):<br>     path: <span class="hljs-built_in">str</span> = os.path.join(<span class="hljs-string">'C:\\example'</span>, entry)<br>     <span class="hljs-keyword">if</span> os.path.isfile(path):<br>         <span class="hljs-built_in">print</span>(path)<br></code></pre></td></tr></tbody></table></figure></li></ol><p>Go 标准库同样提供了类似于 Python 中的两种方法：</p><ol><li><code>filepath.Walk</code> - 类似于 Python 中的 <code>os.walk()</code> 函数，递归遍历所有子孙目录。<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">"fmt"</span><br>   <span class="hljs-string">"os"</span><br>   <span class="hljs-string">"path/filepath"</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br>    <span class="hljs-keyword">var</span> files = <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">16</span>)<br>    err := filepath.Walk(<span class="hljs-string">"C:\\example"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(path <span class="hljs-type">string</span>, info os.FileInfo, err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">error</span> {<br>        <span class="hljs-keyword">if</span> !info.IsDir() { <span class="hljs-comment">// Not a directory</span><br>            files = <span class="hljs-built_in">append</span>(files, path)<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    })<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<br>        <span class="hljs-built_in">panic</span>(err)<br>    }<br>    <span class="hljs-keyword">for</span> _, file := <span class="hljs-keyword">range</span> files {<br>        fmt.Println(file)<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure></li><li><code>File.ReadDir</code> - 类似于 Python 中的 <code>os.listdir()</code>，只遍历目录下的文件或文件夹，不包含子孙目录。<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br> <span class="hljs-string">"fmt"</span><br> <span class="hljs-string">"os"</span><br> <span class="hljs-string">"path/filepath"</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<br> cur_path := <span class="hljs-string">"C:\\example"</span><br> f, _ := os.Open(cur_path)<br> files, _ := f.ReadDir(<span class="hljs-number">-1</span>)<br> err := f.Close()<br> <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<br> <span class="hljs-built_in">panic</span>(err)<br> }<br> <span class="hljs-keyword">for</span> _, file := <span class="hljs-keyword">range</span> files {<br>  <span class="hljs-keyword">if</span> !file.IsDir() {<br>   fmt.Println(filepath.Join(cur_path, file.Name()))<br>  }<br> }<br>}<br></code></pre></td></tr></tbody></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;不同语言中常用的操作&lt;/h1&gt;
&lt;p&gt;简要记录一下，以防某一天用时才想着四处寻找&lt;/p&gt;
&lt;h2 id=&quot;遍历文件&quot;&gt;遍历文件&lt;/h2&gt;
&lt;p&gt;C++ 标准库（C++17 及以上）&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tbo</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://devexzh.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="开发" scheme="https://devexzh.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
    <category term="编程语言" scheme="https://devexzh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Go 学习笔记</title>
    <link href="https://devexzh.github.io/2023/Go_Manuscript/"/>
    <id>https://devexzh.github.io/2023/Go_Manuscript/</id>
    <published>2023-01-15T05:00:07.118Z</published>
    <updated>2023-01-16T06:45:08.770Z</updated>
    
    <content type="html"><![CDATA[<h1>The Go Programming Language</h1><h2 id="与其它语言的对比">与其它语言的对比</h2><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Go</th><th style="text-align:center">C/C++</th><th style="text-align:center">Java</th><th style="text-align:center">Python</th></tr></thead><tbody><tr><td style="text-align:center">内存管理</td><td style="text-align:center">GC</td><td style="text-align:center">手动管理</td><td style="text-align:center">GC</td><td style="text-align:center">GC</td></tr><tr><td style="text-align:center">有无标准格式</td><td style="text-align:center">✔️</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td></tr><tr><td style="text-align:center">操作符重载</td><td style="text-align:center">❌</td><td style="text-align:center">✔️</td><td style="text-align:center">❌</td><td style="text-align:center">✔️</td></tr><tr><td style="text-align:center">参数默认值</td><td style="text-align:center">❌</td><td style="text-align:center">✔️</td><td style="text-align:center">❌</td><td style="text-align:center">✔️</td></tr><tr><td style="text-align:center">构造函数与析构函数</td><td style="text-align:center">❌</td><td style="text-align:center">✔️</td><td style="text-align:center">仅构造函数</td><td style="text-align:center">✔️</td></tr><tr><td style="text-align:center">继承</td><td style="text-align:center">❌</td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td></tr><tr><td style="text-align:center">模板</td><td style="text-align:center">❌</td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td><td style="text-align:center">❌</td></tr><tr><td style="text-align:center">异常</td><td style="text-align:center">❌</td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td></tr><tr><td style="text-align:center">宏</td><td style="text-align:center">❌</td><td style="text-align:center">✔️</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td></tr><tr><td style="text-align:center">隐式数值类型转换</td><td style="text-align:center">❌</td><td style="text-align:center">✔️</td><td style="text-align:center">❌</td><td style="text-align:center">✔️</td></tr><tr><td style="text-align:center">注解</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td><td style="text-align:center">✔️</td><td style="text-align:center">❌</td></tr></tbody></table><h2 id="Go-官方工具链">Go 官方工具链</h2><p>工具 <code>go</code></p><ul><li><code>go run source-code.go</code> - 直接运行Go程序</li><li><code>go build source-code.go</code> - 编译Go源代码</li></ul><p>代码格式化工具 <code>gofmt</code></p><h2 id="Go-语法">Go 语法</h2><h3 id="package-包">package 包</h3><p>类似于 Java 的 package，但不要求放在对应的目录中。一个包可以由多个源代码文件组成。</p><p>常用的包：</p><ul><li><code>os</code> - 操作系统无关的函数及变量（类似 Python 的 <code>os</code>）</li><li><code>fmt</code> - 输入输出（类似 C++ 的<code>iostream</code>）</li></ul><p>导入包的语法</p><p><code>import fmt</code> - 导入单个包 <code>fmt</code></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">"fmt"</span><br>    <span class="hljs-string">"os"</span><br>)<br></code></pre></td></tr></tbody></table></figure><p>导入两个包 <code>fmt</code> 和 <code>os</code></p><h3 id="编写语句">编写语句</h3><h4 id="⚠️-注意事项">⚠️ <strong>注意事项</strong></h4><ul><li>和 Python 一样，每行一般无需分号，但是 <strong>如果一行内有多个语句则要加分号</strong></li><li>大括号必须紧跟函数声明或 for 循环之后，不能换行</li><li>换行只能在操作符之后换行，不能在操作符前换行</li></ul><h4 id="变量声明">变量声明</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> variable_name <span class="hljs-type">int</span><br></code></pre></td></tr></tbody></table></figure><p>声明一个变量格式如上，首先用关键字 <code>var</code> 说明要声明的是变量，随后跟上变量名，最后指明其数据类型。</p><p>以该方式声明的变量会被赋初值，<code>int</code> 类型的会被赋值 0，<code>bool</code> 类型赋值 <code>false</code>，<code>string</code> 类型则赋值 <code>""</code>。</p><p>Go 支持自动类型推导，故以下两个语句是等价的</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span> = <span class="hljs-string">"ABCD"</span> <span class="hljs-comment">// 显式声明变量的类型</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">"ABCD"</span> <span class="hljs-comment">// 自动类型推导</span><br></code></pre></td></tr></tbody></table></figure><p>也可以同时声明/初始化多个变量：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i, j, k <span class="hljs-type">int</span> <span class="hljs-comment">// int, int, int</span><br><span class="hljs-keyword">var</span> b, f, s = <span class="hljs-literal">true</span>, <span class="hljs-number">2.3</span>, <span class="hljs-string">"four"</span> <span class="hljs-comment">// bool, float64, string</span><br><br><span class="hljs-comment">// 使用多返回值的函数来初始化多变量</span><br><span class="hljs-keyword">var</span> f, err = os.Open(name) <span class="hljs-comment">// os.Open 函数返回 file 和 error</span><br></code></pre></td></tr></tbody></table></figure><p>还有一种变量声明的方法，被称为短变量声明 (short variable declaration)，可以看作是一种语法糖，不需要添加关键字 <code>var</code>，而是使用一个新的符号 <code>:=</code>。<strong>需要注意的是，该种形式只能在函数内部充当局部变量，不能作为全局变量。</strong></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">"ABCD"</span><br></code></pre></td></tr></tbody></table></figure><p>需要注意的是，<code>:=</code> 是声明，而 <code>=</code> 是赋值。因此使用 <code>:=</code> 时，必须至少有一个变量是语法块中新的变量；如果是一个已经被声明的变量，则其行为和赋值操作一样。</p><h3 id="操作符">操作符</h3><p>自增、自减操作符：<code>++</code>、<code>--</code>，<strong>只能在变量之后使用</strong>，不能前缀使用，也就是 <code>c++</code> 是合法的，但是 <code>++c</code> 非法；使用这两种操作符时，语句仅仅只是个语句，而不是表达式，不能得到值，也就是 C/C++ 中的 <code>j = i++</code> 在 Go 中是非法的。</p><h3 id="循环">循环</h3><p>Go 中循环只有一个，使用 <code>for</code> 关键字来定义，语法如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> initialization; condition; post {<br>    <span class="hljs-comment">// 零个或多个语句</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>与 C/C++ 相同的是，三个语句皆可省略，但是省略了之后分号也可以省略：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 省略 initialization 和 post</span><br><span class="hljs-keyword">for</span> condition {<br>    <span class="hljs-comment">// 实现 C/C++ 中 while 循环同样的效果</span><br>}<br><br><span class="hljs-comment">// 省略所有</span><br><span class="hljs-keyword">for</span> {<br>    <span class="hljs-comment">// 无限循环，实现 while(true) 的效果</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>Go 也可以使用类似 Python 中的 for range 循环：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">""</span><br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] {<br>    s += <span class="hljs-string">" "</span> + arg<br>}<br></code></pre></td></tr></tbody></table></figure><p>其中 range 会在每次循环开始之时返回两个对象，一个索引 (index)，一个则是索引对应的值。若要弃用某一个值，则用 <code>_</code> 代替。</p><h3 id="指针">指针</h3><p>和 C/C++ 一样，可以对某个对象使用取地址操作符 <code>&amp;</code>，对指针使用 <code>*</code> 操作符可以获取其指向的对象：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 返回一个 int 指针</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function</span><span class="hljs-params">()</span></span> *<span class="hljs-type">int</span> {<br>    v := <span class="hljs-number">10</span><br>    <span class="hljs-keyword">return</span> &amp;v <span class="hljs-comment">// 在 C/C++ 中这么做会导致“野指针”问题，返回栈对象的指针的结果是随机的</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>任何指针的默认值是 <code>nil</code>，相当于 C++ 中的 <code>nullptr</code>。由于 Go 不存在未被初始化的变量之说，故只声明一个指针而不赋值只会得到一个空指针。</p><p>Go 也提供了直接创建指针的机制，即使用 <code>new(T)</code> 函数。但是需要注意的是，其行为和对局部变量取地址是等价的，也就是下面两段代码等价：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newInt</span><span class="hljs-params">()</span></span> *<span class="hljs-type">int</span> {<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newInt</span><span class="hljs-params">()</span></span> *<span class="hljs-type">int</span> {<br>    <span class="hljs-keyword">var</span> dummy <span class="hljs-type">int</span><br>    <span class="hljs-keyword">return</span> &amp;dummy<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="内建数据类型">内建数据类型</h3><h4 id="切片-slice">切片 slice</h4><p>类似于数组，但是大小可以变化</p><p>创建方式：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建一个初始元素长度为5的切片，元素初始值为0： </span><br>mySlice1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>) <br><span class="hljs-comment">// 创建一个初始元素长度为5的切片，元素初始值为0，并预留10个元素的存储空间： </span><br>mySlice2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>) <br><span class="hljs-comment">// 切片字面量创建长度为5容量为5的切片,需要注意的是 [ ] 里面不要写数组的容量，因为如果写了个数以后就是数组了，而不是切片了。</span><br>mySlice3 := []<span class="hljs-type">int</span>{<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>}<br></code></pre></td></tr></tbody></table></figure><h4 id="映射-map">映射 map</h4><p>存储一系列的键值对，类似于 C++ 中的 <code>std::unordered_map</code></p><p>创建方式：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建了一个键类型为string、值类型为PersonInfo</span><br>myMap = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>] PersonInfo) <br><span class="hljs-comment">// 也可以选择是否在创建时指定该map的初始存储能力，创建了一个初始存储能力为100的map</span><br>myMap = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>] PersonInfo, <span class="hljs-number">100</span>) <br><span class="hljs-comment">// 创建并初始化map的代码</span><br>myMap = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>] PersonInfo { <br>  <span class="hljs-string">"1234"</span>: PersonInfo{<span class="hljs-string">"1"</span>, <span class="hljs-string">"Jack"</span>, <span class="hljs-string">"Room 101,..."</span>}, <br>} <br></code></pre></td></tr></tbody></table></figure><p>遍历：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// map 的遍历是随机的，没有指定的顺序</span><br><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> myMap {<br>    <span class="hljs-comment">// myMap 为 map 对象</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>在作为参数传递时，是 <strong>按引用传递</strong> 的，因此在某一函数中对其作修改，也会影响到其它函数。</p><h2 id="生命周期">生命周期</h2><p>Go 的 GC 回收策略</p><h2 id="编译的诸限制">编译的诸限制</h2><ul><li>如果存在未被引用的包，则不能通过编译</li></ul>]]></content>
    
    
    <summary type="html">在阅读《The Go Programming Language》时做的一些笔记📓</summary>
    
    
    
    <category term="学习笔记" scheme="https://devexzh.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="开发" scheme="https://devexzh.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
    <category term="编程语言" scheme="https://devexzh.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
