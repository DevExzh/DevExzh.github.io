<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杂货小铺</title>
  
  <subtitle>位于网络一隅的博客</subtitle>
  <link href="https://devexzh.github.io/atom.xml" rel="self"/>
  
  <link href="https://devexzh.github.io/"/>
  <updated>2023-08-19T12:03:25.615Z</updated>
  <id>https://devexzh.github.io/</id>
  
  <author>
    <name>Ryker Zhu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>X86 汇编语言学习笔记</title>
    <link href="https://devexzh.github.io/2023/Note_Of_X86_Assembly_Language/"/>
    <id>https://devexzh.github.io/2023/Note_Of_X86_Assembly_Language/</id>
    <published>2023-08-14T16:01:54.000Z</published>
    <updated>2023-08-19T12:03:25.615Z</updated>
    
    <content type="html"><![CDATA[<p>以 intel 上世纪推出的 8088/8086 处理器为切入点学习 X86 汇编语言</p><style type="text/css">  .register-name {    font-family: "CMU Typewriter Text";    font-weight: bold;  }</style><h1 id="处理器与总线">处理器与总线</h1><h2 id="x86-系列-cpu-的寄存器">X86 系列 CPU 的寄存器</h2><p>在最初的 8086 系列 CPU 中仅有 14 个 16 位的寄存器，按功能可分为：8个通用寄存器、4 个段寄存器和 2个控制寄存器；通用寄存器又可以分为数据寄存器（<span class="register-name">AX, BX, CX, DX</span>）、地址指针寄存器（<span class="register-name">BP, SP</span>）、变址寄存器（<span class="register-name">SI, DI</span>）</p><p><img src="/img/post_gallery/067e1844f354e9d76cdcb0a97ed94d79/general_purpose_data_registers.svg"></p><p>1985年，intel 推出了 <abbr title="后来被命名为 i386">80386处理器</abbr>，这是 x86 系列的第一款 32 位处理器，主寄存器被扩展到了32-bit。所有 32位主寄存器的命名方式就是在原先寄存器名基础上<abbr title="E 即表示 Extended">加了一个E</abbr>。后来随着 AMD 在 2003 年推出第一款 x86-64 架构的 64位处理器，主寄存器又被扩展到了 64-bit，也是在原先的基础上把 E 改成了R，即 Register（如上图所示）。</p><p><img src="/img/post_gallery/067e1844f354e9d76cdcb0a97ed94d79/r8-r15.svg"></p><p>此外，x86-64 架构也新增了 R8 ~ R15寄存器，如同先前已有的寄存器那样，也可以访问其低位，分别用 <span class="math inline">\(\mathrm{R}x\mathrm{B}\)</span>、<span class="math inline">\(\mathrm{R}x\mathrm{W}\)</span>、<span class="math inline">\(\mathrm{R}x\mathrm{D}\)</span> 来表示（Byte, Word,Double-word）</p><p><img src="/img/post_gallery/067e1844f354e9d76cdcb0a97ed94d79/bp_sp.svg"></p><h2 id="寻址方式">寻址方式</h2><pre><code class=" mermaid">flowchart LR;a(寻址方式) --- ima(立即寻址) &amp; bva(基址变址寻址) &amp; ta(隐含寻址)bva --- da(直接寻址) &amp; ia(间接寻址)ia --- ra(寄存器间接寻址) &amp; ma(存储器间接寻址)</code></pre><h3 id="立即寻址">立即寻址</h3><p>由指令直接给出运算的数据（操作数是立即数），为常数形式或字符形式：</p><figure class="highlight x86asm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-number">1200h</span> <span class="hljs-comment">; 往 AX 寄存器写入 16 进制的 1200 这个立即数</span><br></code></pre></td></tr></tbody></table></figure><h3 id="基址变址寻址">基址变址寻址</h3><p>方括号内表示偏移地址，由至多三个部分组成：基址寄存器内容 +变址寄存器内容 + 位移量</p><ul><li><p>只有一个常数就是直接寻址：</p><p>方括号里就是操作数的偏移地址，也就是被操作的数据在距某一段（默认为<strong>数据段</strong>）段首的偏移多少距离的内存单元里面</p><figure class="highlight x86asm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-number">1200h</span>] <span class="hljs-comment">; 操作的数据被存放在距 DS 1200 远的地方</span><br></code></pre></td></tr></tbody></table></figure><p>如果要人为指定逻辑段，可以用<strong>段重设</strong>：</p><figure class="highlight x86asm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-built_in">es</span>: [<span class="hljs-number">1200h</span>] <span class="hljs-comment">; 操作的数据被存放在距 ES 1200 远的地方</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>只有一个寄存器名就是寄存器间接寻址：</p><p>需要注意的是，<strong>仅4个通用寄存器可用于存数据的偏移地址，即 <span class="register-name">BX</span>, <span class="register-name">BP</span>,<span class="register-name">SI</span>, <span class="register-name">DI</span></strong></p><figure class="highlight x86asm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">bx</span>] <span class="hljs-comment">; 把由 BX 存着的偏移地址上的内存单元数据送给 AX</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>寄存器名 + 一个常数就是寄存器相对寻址：</p><p>操作数的段地址（数据处于哪个段）取决于选择哪一个间址寄存器</p><ul><li><span class="register-name">BX, SI, DI</span> : 默认在数据段</li><li><span class="register-name">BP</span> : 默认在堆栈段</li></ul></li><li><p>两个寄存器就是基址变址寻址：</p><figure class="highlight x86asm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, [<span class="hljs-built_in">bx</span>]<span class="hljs-number">5</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, [<span class="hljs-built_in">bx</span> + <span class="hljs-number">5</span>] <span class="hljs-comment">; 和上个语句完全一样</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">bx</span>][<span class="hljs-built_in">si</span>] <span class="hljs-comment">; 相当于 BX + SI</span><br></code></pre></td></tr></tbody></table></figure></li></ul><h3 id="隐含寻址">隐含寻址</h3><figure class="highlight x86asm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mul</span> <span class="hljs-built_in">bl</span> <span class="hljs-comment">; 隐含寻址，AL 和 BL 相乘送入 AX</span><br></code></pre></td></tr></tbody></table></figure><h1 id="指令系统">指令系统</h1><h2 id="数据传送指令">数据传送指令</h2><pre><code class=" mermaid">flowchart TB;cat(数据传送类指令) --- gm(通用数据传送指令) &amp; io(输入输出指令) &amp; am(地址传送指令) &amp; fm(标志传送指令)</code></pre><h3 id="通用数据传送指令">通用数据传送指令</h3><h4 id="一般数据传送指令">一般数据传送指令</h4><p>格式： <span class="math display">\[\operatorname{mov}\;dest,\,src\]</span></p><p>将 src 中的数据传送给 dest，作个不太恰当的比方就是 C++ 中的</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">register</span> <span class="hljs-type">int</span> dest, src;<br>dest = src; <span class="hljs-comment">// 把 src 赋值给 dest</span><br></code></pre></td></tr></tbody></table></figure><p>但是需要注意几点：</p><ul><li>两操作数字长必须相同</li><li>两操作数不允许同时为存储器操作数；</li><li>两操作数不允许同时为段寄存器；</li><li>在源操作数是立即数时，目标操作数不能是段寄存器；</li><li><span class="register-name">IP</span> 和 <span class="register-name">CS</span> 不作为目标操作数，<span class="register-name">FLAGS</span> 一般也不作为操作数在指令中出现。</li></ul><h4 id="堆栈操作指令">堆栈操作指令</h4><p>格式： <span class="math display">\[\operatorname{push}\;operand\qquad\operatorname{pop}\;operand\]</span></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span>* sp;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(byte[] operand)</span> </span>{<br>    sp -= <span class="hljs-number">2</span>;<br>    sp + <span class="hljs-number">1</span> = operand[<span class="hljs-number">1</span>];<br>    sp = operand[<span class="hljs-number">0</span>];<br>}<br></code></pre></td></tr></tbody></table></figure><p>注意：</p><ul><li>操作数可以是寄存器或存储器两单元，但不能是立即数</li></ul><h4 id="交换指令">交换指令</h4><p>格式： <span class="math display">\[\operatorname{xchg}\;reg,\,mem/reg\]</span></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python">reg, mem = mem, reg<br></code></pre></td></tr></tbody></table></figure><h4 id="查表转换指令">查表转换指令</h4><p>格式： <span class="math display">\[\operatorname{xlat}\]</span></p><p>所做操作是用 <span class="register-name">BX</span>的内容代表表格首地址，<span class="register-name">AL</span>内容为表内位移量，<span class="register-name">BX + AL</span>得到要查找元素的偏移地址</p><h4 id="字位扩展指令">字位扩展指令</h4><p>此类指令将符号数的符号位扩展到高位</p><h2 id="算术运算指令">算术运算指令</h2><h3 id="加法">加法</h3><h4 id="普通加法指令-add">普通加法指令 ADD</h4><p>格式： <span class="math display">\[\operatorname{add}\;operand_1,\,operand_2\]</span></p><p>将 <span class="register-name">operand<sub>1</sub></span> 和 <span class="register-name">operand<sub>2</sub></span> 相加后，结果送入 <span class="register-name">operand<sub>1</sub></span> 中</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">register</span> <span class="hljs-type">int</span> operand1, operand2;<br>operand1 += operand2;<br></code></pre></td></tr></tbody></table></figure><h4 id="带进位的加法指令-adc">带进位的加法指令 ADC</h4><p>和 ADD 指令一样，只不过还加了 <span class="register-name">CF</span>标志位；ADC 指令多用于多字节数相加，使用前要先将 <span class="register-name">CF</span> 清零</p><h4 id="自增指令-inc">自增指令 INC</h4><p>格式： <span class="math display">\[\operatorname{inc}\;operand\]</span></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">register</span> <span class="hljs-type">int</span> operand;<br>operand++;<br></code></pre></td></tr></tbody></table></figure><div class="to-be-continued" style="width: 100%; border-radius: 10px; text-align: center; background: linear-gradient(#484878, #202048); color: #e8c890; padding: 2%; box-shadow: 2px 2px rgba(0,0,0,0.5);">未完待续<br>To be continued...</div><div style="display: none;"><h3 id="减法">减法</h3><h3 id="乘法">乘法</h3><h3 id="除法">除法</h3><h2 id="逻辑运算指令">逻辑运算指令</h2><h2 id="串操作指令">串操作指令</h2><h2 id="程序控制指令">程序控制指令</h2><h2 id="处理器控制指令">处理器控制指令</h2></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以 intel 上世纪推出的 8088/8086 处理器为切入点学习 X86 汇编语言&lt;/p&gt;
&lt;style type=&quot;text/css&quot;&gt;
  .register-name {
    font-family: &quot;CMU Typewriter Text&quot;;
    fo</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://devexzh.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机" scheme="https://devexzh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="汇编语言" scheme="https://devexzh.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>SymPy 库使用小记</title>
    <link href="https://devexzh.github.io/2023/Manuscript_Of_Using_SymPy_Module/"/>
    <id>https://devexzh.github.io/2023/Manuscript_Of_Using_SymPy_Module/</id>
    <published>2023-08-14T13:11:32.000Z</published>
    <updated>2023-08-14T15:04:17.543Z</updated>
    
    <content type="html"><![CDATA[<blockquote>Life is short，you need Python.<p style="text-align: right;">—— Guido van Rossum</p></blockquote><p>你离计算机代数只差一行 Python 代码：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> sympy <span class="hljs-keyword">import</span> *<br></code></pre></td></tr></tbody></table></figure><h2 id="微积分">微积分</h2><h3 id="求导">求导</h3><p>拿 <span class="math inline">\(\displaystyle\frac{d}{d x}2^{\operatorname{arctan}{\frac{1 - x^{2}}{1 + x^{2}}}}\)</span><abbr title="出自汤家凤考研数学接力题典 1800 题目册 P14">这个</abbr>来说</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 初始化一下打印</span><br>init_printing()<br><span class="hljs-comment"># 声明一下符号</span><br>x = symbols(<span class="hljs-string">'x'</span>)<br><span class="hljs-comment"># 定义一个式子</span><br>expr = Derivative(<span class="hljs-number">2</span>**atan((<span class="hljs-number">1</span>-x**<span class="hljs-number">2</span>)/(<span class="hljs-number">1</span>+x**<span class="hljs-number">2</span>)), x)<br><span class="hljs-comment"># 让 sympy 来求解</span><br><span class="hljs-built_in">print</span>(expr.doit())<br></code></pre></td></tr></tbody></table></figure><p>然后我们就得到了</p><p><span class="math display">\[- 2^{\operatorname{arctan}{\frac{1 -x^{2}}{1 + x^{2}}}}\ln2\cdot\frac{2x}{x^{4} + 1}\]</span></p><p>求 <span class="math inline">\(\displaystyle e^{x^{2} + y^{2}}\sin{\left(x y \right)}\)</span><abbr title="出自汤家凤考研数学接力题典 1800 题目册 P98">这个</abbr>的偏导也可以：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python">init_printing()<br>x, y = symbols(<span class="hljs-string">'x y'</span>)<br>expr = E**(x**<span class="hljs-number">2</span>+y**<span class="hljs-number">2</span>)*sin(x*y)<br><span class="hljs-comment"># 分别对 x、对 y 和先对 x 再对 y 求偏导</span><br><span class="hljs-built_in">print</span>(diff(expr, x), diff(expr, y))<br><span class="hljs-built_in">print</span>(diff(expr, x, y))<br></code></pre></td></tr></tbody></table></figure><p>然后就分别得到了 <span class="math display">\[\begin{array}{c}2 xe^{x^{2} + y^{2}} \sin{\left(x y \right)} + y e^{x^{2} + y^{2}}\cos{\left(x y \right)}\\ e^{x^{2} + y^{2}} \cos{\left(x y \right)} + 2y e^{x^{2} + y^{2}} \sin{\left(x y \right)}\\ \left(3 x y \sin{\left(x y\right)} + \left(2 x^{2} + 2 y^{2} + 1\right) \cos{\left(x y\right)}\right) e^{x^{2} + y^{2}}\end{array}\]</span></p><p>完美！</p><h3 id="积分">积分</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 对象形式</span><br>Integral(expr, (var, lower, upper))<br><span class="hljs-comment"># 函数形式</span><br>integrate(expr, (var, lower, upper))<br></code></pre></td></tr></tbody></table></figure><p>比如说<abbr title="出自汤家凤考研数学接力题典 1800 题目册 P24">这个</abbr>不定积分<span class="math inline">\(\displaystyle\int\frac{\ln{\frac{1+x}{1-x}}}{1 - x^{2}}\, dx\)</span>：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python">integ = Integral(<span class="hljs-number">1</span>/(<span class="hljs-number">1</span>-x**<span class="hljs-number">2</span>)*log((<span class="hljs-number">1</span>+x)/(<span class="hljs-number">1</span>-x)), x)<br><span class="hljs-built_in">print</span>(integ.doit())<br></code></pre></td></tr></tbody></table></figure><p>最后输出（可以注意到默认都是不带任意常数 <span class="math inline">\(C\)</span> 的）： <span class="math display">\[\frac{1}{4}{\left(\ln{\frac{x + 1}{1 -x}}\right)}^2\]</span></p><p>对<abbr title="出自汤家凤考研数学接力题典 1800 题目册 P28">这个</abbr>不定积分<span class="math inline">\(\displaystyle\int_{0}^{1}\frac{x^{3}}{\sqrt{x^{2} + 1}}\, dx\)</span> 则是传入一个三元组：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python">integrate((x**<span class="hljs-number">3</span>)/sqrt(x**<span class="hljs-number">2</span>+<span class="hljs-number">1</span>), (x, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br></code></pre></td></tr></tbody></table></figure><h3 id="极限">极限</h3><p>SymPy 使用 <code>oo</code> 来表示 <span class="math inline">\(\infty\)</span>（没错就是两个<code>o</code>），类似于 <span class="math inline">\(\infty -\infty\)</span> 和 <span class="math inline">\(\dfrac\infty\infty\)</span> 这种则返回<code>nan</code> （不是一个数，Not a Number）</p><blockquote>Talk is cheap, show me the code.<p style="text-align: right;">—— Linus Torvalds</p></blockquote><p>求重要极限 <span class="math inline">\(\lim\limits_{x\to\infty}{\left(1+\dfrac{1}{x}\right)}^{x}\)</span></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 对象形式</span><br>Limit((<span class="hljs-number">1</span>+<span class="hljs-number">1</span>/x)**x, x, oo)<br><span class="hljs-comment"># 函数形式</span><br>limit((<span class="hljs-number">1</span>+<span class="hljs-number">1</span>/x)**x, x, oo)<br></code></pre></td></tr></tbody></table></figure><p>求单侧极限 <span class="math inline">\(\lim\limits_{x \to 0^+}\dfrac{1}{x}\)</span> 和 <span class="math inline">\(\lim\limits_{x \to0^-} \dfrac{1}{x}\)</span></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python">limit(<span class="hljs-number">1</span>/x, x, <span class="hljs-number">0</span>, <span class="hljs-string">'+'</span>)<br>limit(<span class="hljs-number">1</span>/x, x, <span class="hljs-number">0</span>, <span class="hljs-string">'-'</span>)<br></code></pre></td></tr></tbody></table></figure><h2 id="打印">打印</h2><p>自动选择打印方式：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python">init_printing()<br></code></pre></td></tr></tbody></table></figure><p>不同打印方式对应的代码：</p><table><thead><tr class="header"><th style="text-align: center;">打印方式</th><th style="text-align: center;">代码</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">ASCII 字符</td><td style="text-align: center;"><code>pprint(expr, use_unicode = False)</code></td></tr><tr class="even"><td style="text-align: center;">Unicode 字符</td><td style="text-align: center;"><code>pprint(expr, use_unicode = True)</code></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\LaTeX\)</span></td><td style="text-align: center;"><code>print(latex(expr))</code></td></tr><tr class="even"><td style="text-align: center;">MathML</td><td style="text-align: center;"><code>from sympy.printing.mathml import print_mathml</code><br><code>print_mathml(expr)</code></td></tr></tbody></table><h2 id="化简">化简</h2><table><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">功能</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>simplify(expr)</code></td><td style="text-align: center;">最简单的化简函数，但是有可能会很慢</td></tr><tr class="even"><td style="text-align: center;"><code>expand(poly)</code></td><td style="text-align: center;">用来展开<strong>多项式</strong></td></tr><tr class="odd"><td style="text-align: center;"><code>factor(poly)</code></td><td style="text-align: center;">因式分解<strong>多项式</strong></td></tr><tr class="even"><td style="text-align: center;"><code>collect(expr, factor)</code></td><td style="text-align: center;">从 <code>expr</code> 表达式中提出<code>factor</code></td></tr><tr class="odd"><td style="text-align: center;"><code>cancel(rational)</code></td><td style="text-align: center;">把<strong>分式</strong>化简并展开</td></tr><tr class="even"><td style="text-align: center;"><code>apart(rational)</code></td><td style="text-align: center;">对<strong>分式</strong>作部分分式分解</td></tr><tr class="odd"><td style="text-align: center;"><code>trigsimp(expr)</code></td><td style="text-align: center;">化简<strong>三角函数</strong>表达式</td></tr><tr class="even"><td style="text-align: center;"><code>expand_trig(expr)</code></td><td style="text-align: center;">展开<strong>三角函数</strong>表达式</td></tr><tr class="odd"><td style="text-align: center;"><code>powsimp(expr)</code></td><td style="text-align: center;">化简<strong>幂</strong>表达式</td></tr><tr class="even"><td style="text-align: center;"><code>powdenest(expr)</code></td><td style="text-align: center;"><span class="math inline">\({x}^{a^b}\)</span> 化简成 <span class="math inline">\(x^{ab}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><code>expand_log(expr)</code></td><td style="text-align: center;">展开<strong>对数</strong>表达式</td></tr><tr class="even"><td style="text-align: center;"><code>logcombine(expr)</code></td><td style="text-align: center;"><span class="math inline">\(\log{x}+\log{y}\)</span> 合并成 <span class="math inline">\(\log{xy}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><code>combsimp(expr)</code></td><td style="text-align: center;">对<strong>组合数</strong>化简</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
Life is short，you need Python.
&lt;p style=&quot;text-align: right;&quot;&gt;
—— Guido van Rossum
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你离计算机代数只差一行 Python 代码：&lt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://devexzh.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Python" scheme="https://devexzh.github.io/tags/Python/"/>
    
    <category term="符号计算" scheme="https://devexzh.github.io/tags/%E7%AC%A6%E5%8F%B7%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>云服务器搭建 ShareLaTeX 备忘录</title>
    <link href="https://devexzh.github.io/2023/Memo_Of_Deploying_ShareLaTeX_On_Remote_Server/"/>
    <id>https://devexzh.github.io/2023/Memo_Of_Deploying_ShareLaTeX_On_Remote_Server/</id>
    <published>2023-08-11T14:21:41.000Z</published>
    <updated>2023-09-09T08:12:12.493Z</updated>
    
    <content type="html"><![CDATA[<p>简要记录一下利用云服务器搭建 Tex Live + ShareLaTeX 的过程</p><p>这里用的是以学生优惠价购入的腾讯云服务器（<strong>没有打广告</strong>，如果有金主爸爸肯提供广告位的话就非常感谢）</p><h2 id="git-clone-一下项目">Git clone 一下项目</h2><p>先用 SSH 连接到远程服务器（这里没必要用 PuTTY 之类的，Windows系统如果已经安装了 OpenSSH 的话直接用终端就行）</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh username@host<br></code></pre></td></tr></tbody></table></figure><p>然后克隆一下项目：<a href="https://github.com/overleaf/toolkit/">戳我访问 GitHub项目地址</a></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/overleaf/toolkit.git ./overleaf-toolkit<br><span class="hljs-built_in">cd</span> ./overleaf-toolkit<br></code></pre></td></tr></tbody></table></figure><p>接着初始化一下项目（这里用了 Docker 所以务必事先<a href="https://docs.docker.com/desktop/install/linux-install/">安装Docker</a>）</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/init<br></code></pre></td></tr></tbody></table></figure><h2 id="配置">配置</h2><p>然后就可以配置一下你的 ShareLaTeX 了（在 <code>config</code>这个文件夹里面），主要的配置文件就是 <code>overleaf.rc</code> 和<code>variables.env</code> 这两个文件</p><ul><li>修改 <code>overleaf.rc</code> 中的 <code>SHARELATEX_LISTEN_IP</code>这个变量，把它改成你服务器的内网 IP（不是127.0.0.0，不然你就根本访问不到服务器）</li><li>修改 <code>variables.env</code> 中的<code>SHARELATEX_APP_NAME</code> 这个变量，改成你自己想要的网站名称</li><li>如果想要把界面改成中文的话就在 <code>variables.env</code> 中加一行<code>SHARELATEX_SITE_LANGUAGE=zh-CN</code></li><li>剩下的要个性化的配置，直接看<a href="https://github.com/overleaf/overleaf/wiki">官方 Wiki</a> 就行</li></ul><h2 id="sharelatex启动">ShareLaTeX，启动！</h2><p><s>原神，启动！</s></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/up<br></code></pre></td></tr></tbody></table></figure><p>然后你就可以输入网址 <code>http://YourHost/launchpad</code>配置一下管理员账户了</p><p>但是，现在如果你想用 TikZ 或者其它什么 LaTeX包是不行的，因为只是把环境配置完了，相关的软件包还没安装好</p><p>先进入 Docker 容器里操作一下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it sharelatex bash<br></code></pre></td></tr></tbody></table></figure><p>第一步，先改一下 <code>sources.list</code>来加速一下安装过程（什么？没有 Vim？那就先<code>sudo apt install vim</code> 一下）</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/apt/sources.list<br></code></pre></td></tr></tbody></table></figure><p>然后改成下面这样子，其它镜像源也是同理</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">deb http:<span class="hljs-regexp">//mi</span>rrors.tencentyun.com/ubuntu jammy main restricted<br>deb http:<span class="hljs-regexp">//mi</span>rrors.tencentyun.com/ubuntu jammy-updates main restricted<br>deb http:<span class="hljs-regexp">//mi</span>rrors.tencentyun.com/ubuntu jammy universe<br>deb http:<span class="hljs-regexp">//mi</span>rrors.tencentyun.com/ubuntu jammy-updates universe<br>deb http:<span class="hljs-regexp">//mi</span>rrors.tencentyun.com/ubuntu jammy multiverse<br>deb http:<span class="hljs-regexp">//mi</span>rrors.tencentyun.com/ubuntu jammy-updates multiverse<br>deb http:<span class="hljs-regexp">//mi</span>rrors.tencentyun.com/ubuntu jammy-security main restricted<br>deb http:<span class="hljs-regexp">//mi</span>rrors.tencentyun.com/ubuntu jammy-security universe<br>deb http:<span class="hljs-regexp">//mi</span>rrors.tencentyun.com/ubuntu jammy-security multiverse<br></code></pre></td></tr></tbody></table></figure><p>国内由于众所周知的原因，CTAN 特别特别特别慢，所以这里给 CTAN也换个源：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tlmgr option repository http://mirrors.tencentyun.com/CTAN/systems/texlive/tlnet<br></code></pre></td></tr></tbody></table></figure><p>现在就可以安装 LaTeX 包了，嫌麻烦的话就直接安装所有的包：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tlmgr install scheme-full<br>tlmgr update --self --all<br></code></pre></td></tr></tbody></table></figure><p>这时候还没结束，我们还需要安装好 Tex Live的一些额外的包（特别是中文支持等等），这里同样地，嫌麻烦直接安装所有包：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install texlive-full<br></code></pre></td></tr></tbody></table></figure><p>BTW：如果不需要那么多东西的话安装下面这些也行：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install texlive-latex-base texlive-latex-extra texlive-latex-recommended texlive-fonts-recommended texlive-lang-chinese texlive-xetex<br></code></pre></td></tr></tbody></table></figure><p>现在已经全部完成安装了，赶紧愉快的玩耍吧~</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exit</span><br>docker restart sharelatex<br></code></pre></td></tr></tbody></table></figure><p>我已经搭建完成的网站：<a href="http://111.229.194.16/">Ryker ZhuLaTeX Editor</a></p><h2 id="minted-代码高亮部署">Minted 代码高亮部署</h2><p>(2023/9/9 更新，<a href="https://harrychen.xyz/2020/02/15/self-host-overleaf-scientifically/">参考资料点我</a>)虽然前面几步已经完成了 ShareLaTeX 的部署，但是如果使用了 minted这个宏包还是会报错，这是因为默认的 Docker 容器内并没有安装 Pygment环境（提供语法解析器功能）。</p><ol type="1"><li><p>安装 Python 和 Pygments</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt install python3<br>apt install python-pygments<br></code></pre></td></tr></tbody></table></figure></li><li><p>配置 Shell Escape</p><p>修改容器内的<code>/usr/local/texlive/(版本)/texmf.cnf</code>，在最低行添加</p><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">shell_escape</span> = t<br></code></pre></td></tr></tbody></table></figure><p>然后重启一下 <code>sharelatex</code> 这个 Docker 容器</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;简要记录一下利用云服务器搭建 Tex Live + ShareLaTeX 的过程&lt;/p&gt;
&lt;p&gt;这里用的是以学生优惠价购入的腾讯云服务器（&lt;strong&gt;没有打广告&lt;/strong&gt;，如果有金主爸爸肯提供广告位的话就非常感谢）&lt;/p&gt;
&lt;h2 id=&quot;git-clone-一</summary>
      
    
    
    
    <category term="备忘录" scheme="https://devexzh.github.io/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
    <category term="LaTeX" scheme="https://devexzh.github.io/tags/LaTeX/"/>
    
    <category term="服务器建设" scheme="https://devexzh.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%BA%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>日本語学習ノート</title>
    <link href="https://devexzh.github.io/2023/Note_Of_Japanese_Learning/"/>
    <id>https://devexzh.github.io/2023/Note_Of_Japanese_Learning/</id>
    <published>2023-07-24T06:40:00.000Z</published>
    <updated>2023-08-01T11:40:12.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="五十音図">五十音図</h1><noscript>请允许运行 JavaScript 以启用点读功能</noscript><style type="text/css">    td {text-align: center;}    .fifty-sounds-row {width: 9ex; font-weight: bold;}    .fifty-sounds-col {font-weight: bold;}    .fifty-sounds-romaji {        font-family: "CMU Serif";        font-style: italic;    }    .fifty-sounds-romaji-obsolete {display: none;}    .fifty-sounds-kana, .fifty-sounds-additional-row {        -webkit-transform: scale(1) rotate(0deg);            -ms-transform: scale(1) rotate(0deg);                transform: scale(1) rotate(0deg);        -webkit-transition: -webkit-transform .25s ease;        transition: -webkit-transform .25s ease;        -o-transition: transform .25s ease;        transition: transform .25s ease;        transition: transform .25s ease, -webkit-transform .25s ease;        font-family: "ShipporiMincho";    }    .fifty-sounds-kana:hover, .fifty-sounds-additional-row:hover {-webkit-transform: scale(1.618) rotate(-360deg);-ms-transform: scale(1.618) rotate(-360deg);transform: scale(1.618) rotate(-360deg); -webkit-transition: -webkit-transform .25s ease; transition: -webkit-transform .25s ease; -o-transition: transform .25s ease; transition: transform .25s ease; transition: transform .25s ease, -webkit-transform .25s ease; color: #2196f3;}</style><script>let flag_enable_speech = false;function findName(e) {    for(let c of e.className.split(" ")) {        if(c.startsWith("speak-kana-")) {            return c.replace("speak-kana-", "");        }    }    return null;}function speakOut(e) {    if(!flag_enable_speech) return;    const n = findName(e);    if(n == null) return;    new Audio("/audio/0c2683ac2763bccf036093d0a0c4deba/" + n + ".wav").play();}function toggleJapaneseKanaSpeech(e) {    flag_enable_speech = !flag_enable_speech;    if(flag_enable_speech) {        e.innerHTML = "关闭点读功能";    } else {        e.innerHTML = "开启点读功能";    }}</script><span><b>提示：</b>鼠标悬浮在特定假名上可以播放对应读音（音源：<a href="https://www.bilibili.com/video/av800548050">志方優</a>）</span><button class="btn btn-default speech-toggle-button" onclick="toggleJapaneseKanaSpeech(this)">开启点读功能</button><br><table style="overflow: hidden; table-layout: fixed;" class="table markdown-body"><tbody><tr><td rowspan="2"></td><td class="fifty-sounds-col" colspan="2">あ 段</td><td class="fifty-sounds-col" colspan="2">い 段</td><td class="fifty-sounds-col" colspan="2">う 段</td><td class="fifty-sounds-col" colspan="2">え 段</td><td class="fifty-sounds-col" colspan="2">お 段</td></tr><tr><td class="fifty-sounds-hiragana-col">平仮名</td><td class="fifty-sounds-katakana-col">片仮名</td><td class="fifty-sounds-hiragana-col">平仮名</td><td class="fifty-sounds-katakana-col">片仮名</td><td class="fifty-sounds-hiragana-col">平仮名</td><td class="fifty-sounds-katakana-col">片仮名</td><td class="fifty-sounds-hiragana-col">平仮名</td><td class="fifty-sounds-katakana-col">片仮名</td><td class="fifty-sounds-hiragana-col">平仮名</td><td class="fifty-sounds-katakana-col">片仮名</td></tr><tr><td class="fifty-sounds-row" rowspan="2"><span class="fifty-sounds-romaji">a</span><br>あ 行</td><td colspan="2"><span class="fifty-sounds-romaji">a</span></td><td colspan="2"><span class="fifty-sounds-romaji">i</span></td><td colspan="2"><span class="fifty-sounds-romaji">u</span></td><td colspan="2"><span class="fifty-sounds-romaji">e</span></td><td colspan="2"><span class="fifty-sounds-romaji">o</span></td></tr><tr><td class="fifty-sounds-kana speak-kana-a" onmouseover="speakOut(this);">あ</td><td class="fifty-sounds-kana speak-kana-a" onmouseover="speakOut(this);">ア</td><td class="fifty-sounds-kana speak-kana-i" onmouseover="speakOut(this);">い</td><td class="fifty-sounds-kana speak-kana-i" onmouseover="speakOut(this);">イ</td><td class="fifty-sounds-kana speak-kana-u" onmouseover="speakOut(this);">う</td><td class="fifty-sounds-kana speak-kana-u" onmouseover="speakOut(this);">ウ</td><td class="fifty-sounds-kana speak-kana-e" onmouseover="speakOut(this);">え</td><td class="fifty-sounds-kana speak-kana-e" onmouseover="speakOut(this);">エ</td><td class="fifty-sounds-kana speak-kana-o" onmouseover="speakOut(this);">お</td><td class="fifty-sounds-kana speak-kana-o" onmouseover="speakOut(this);">オ</td></tr><tr><td class="fifty-sounds-row" rowspan="2"><span class="fifty-sounds-romaji">k</span><br>か 行</td><td colspan="2"><span class="fifty-sounds-romaji">ka</span></td><td colspan="2"><span class="fifty-sounds-romaji">ki</span></td><td colspan="2"><span class="fifty-sounds-romaji">ku</span></td><td colspan="2"><span class="fifty-sounds-romaji">ke</span></td><td colspan="2"><span class="fifty-sounds-romaji">ko</span></td></tr><tr><td class="fifty-sounds-kana speak-kana-ka" onmouseover="speakOut(this);">か</td><td class="fifty-sounds-kana speak-kana-ka" onmouseover="speakOut(this);">カ</td><td class="fifty-sounds-kana speak-kana-ki" onmouseover="speakOut(this);">き</td><td class="fifty-sounds-kana speak-kana-ki" onmouseover="speakOut(this);">キ</td><td class="fifty-sounds-kana speak-kana-ku" onmouseover="speakOut(this);">く</td><td class="fifty-sounds-kana speak-kana-ku" onmouseover="speakOut(this);">ク</td><td class="fifty-sounds-kana speak-kana-ke" onmouseover="speakOut(this);">け</td><td class="fifty-sounds-kana speak-kana-ke" onmouseover="speakOut(this);">ケ</td><td class="fifty-sounds-kana speak-kana-ko" onmouseover="speakOut(this);">こ</td><td class="fifty-sounds-kana speak-kana-ko" onmouseover="speakOut(this);">コ</td></tr><tr><td class="fifty-sounds-row" rowspan="2"><span class="fifty-sounds-romaji">s</span><br>さ 行</td><td colspan="2"><span class="fifty-sounds-romaji">sa</span></td><td colspan="2"><span class="fifty-sounds-romaji">shi</span></td><td colspan="2"><span class="fifty-sounds-romaji">su</span></td><td colspan="2"><span class="fifty-sounds-romaji">se</span></td><td colspan="2"><span class="fifty-sounds-romaji">so</span></td></tr><tr><td class="fifty-sounds-kana speak-kana-sa" onmouseover="speakOut(this);">さ</td><td class="fifty-sounds-kana speak-kana-sa" onmouseover="speakOut(this);">サ</td><td class="fifty-sounds-kana speak-kana-shi" onmouseover="speakOut(this);">し</td><td class="fifty-sounds-kana speak-kana-shi" onmouseover="speakOut(this);">シ</td><td class="fifty-sounds-kana speak-kana-su" onmouseover="speakOut(this);">す</td><td class="fifty-sounds-kana speak-kana-su" onmouseover="speakOut(this);">ス</td><td class="fifty-sounds-kana speak-kana-se" onmouseover="speakOut(this);">せ</td><td class="fifty-sounds-kana speak-kana-se" onmouseover="speakOut(this);">セ</td><td class="fifty-sounds-kana speak-kana-so" onmouseover="speakOut(this);">そ</td><td class="fifty-sounds-kana speak-kana-so" onmouseover="speakOut(this);">ソ</td></tr><tr><td class="fifty-sounds-row" rowspan="2"><span class="fifty-sounds-romaji">t</span><br>た 行</td><td colspan="2"><span class="fifty-sounds-romaji">ta</span></td><td colspan="2"><span class="fifty-sounds-romaji">chi</span></td><td colspan="2"><span class="fifty-sounds-romaji">tsu</span></td><td colspan="2"><span class="fifty-sounds-romaji">te</span></td><td colspan="2"><span class="fifty-sounds-romaji">to</span></td></tr><tr><td class="fifty-sounds-kana speak-kana-ta" onmouseover="speakOut(this);">た</td><td class="fifty-sounds-kana speak-kana-ta" onmouseover="speakOut(this);">タ</td><td class="fifty-sounds-kana speak-kana-chi" onmouseover="speakOut(this);">ち</td><td class="fifty-sounds-kana speak-kana-chi" onmouseover="speakOut(this);">チ</td><td class="fifty-sounds-kana speak-kana-tsu" onmouseover="speakOut(this);">つ</td><td class="fifty-sounds-kana speak-kana-tsu" onmouseover="speakOut(this);">ツ</td><td class="fifty-sounds-kana speak-kana-te" onmouseover="speakOut(this);">て</td><td class="fifty-sounds-kana speak-kana-te" onmouseover="speakOut(this);">テ</td><td class="fifty-sounds-kana speak-kana-to" onmouseover="speakOut(this);">と</td><td class="fifty-sounds-kana speak-kana-to" onmouseover="speakOut(this);">ト</td></tr><tr><td class="fifty-sounds-row" rowspan="2"><span class="fifty-sounds-romaji">n</span><br>な 行</td><td colspan="2"><span class="fifty-sounds-romaji">na</span></td><td colspan="2"><span class="fifty-sounds-romaji">ni</span></td><td colspan="2"><span class="fifty-sounds-romaji">nu</span></td><td colspan="2"><span class="fifty-sounds-romaji">ne</span></td><td colspan="2"><span class="fifty-sounds-romaji">no</span></td></tr><tr><td class="fifty-sounds-kana speak-kana-na" onmouseover="speakOut(this);">な</td><td class="fifty-sounds-kana speak-kana-na" onmouseover="speakOut(this);">ナ</td><td class="fifty-sounds-kana speak-kana-ni" onmouseover="speakOut(this);">に</td><td class="fifty-sounds-kana speak-kana-ni" onmouseover="speakOut(this);">ニ</td><td class="fifty-sounds-kana speak-kana-nu" onmouseover="speakOut(this);">ぬ</td><td class="fifty-sounds-kana speak-kana-nu" onmouseover="speakOut(this);">ヌ</td><td class="fifty-sounds-kana speak-kana-ne" onmouseover="speakOut(this);">ね</td><td class="fifty-sounds-kana speak-kana-ne" onmouseover="speakOut(this);">ネ</td><td class="fifty-sounds-kana speak-kana-no" onmouseover="speakOut(this);">の</td><td class="fifty-sounds-kana speak-kana-no" onmouseover="speakOut(this);">ノ</td></tr><tr><td class="fifty-sounds-row" rowspan="2"><span class="fifty-sounds-romaji">h</span><br>は 行</td><td colspan="2"><span class="fifty-sounds-romaji">ha</span></td><td colspan="2"><span class="fifty-sounds-romaji">hi</span></td><td colspan="2"><span class="fifty-sounds-romaji">fu</span></td><td colspan="2"><span class="fifty-sounds-romaji">he</span></td><td colspan="2"><span class="fifty-sounds-romaji">ho</span></td></tr><tr><td class="fifty-sounds-kana speak-kana-ha" onmouseover="speakOut(this);">は</td><td class="fifty-sounds-kana speak-kana-ha" onmouseover="speakOut(this);">ハ</td><td class="fifty-sounds-kana speak-kana-hi" onmouseover="speakOut(this);">ひ</td><td class="fifty-sounds-kana speak-kana-hi" onmouseover="speakOut(this);">ヒ</td><td class="fifty-sounds-kana speak-kana-fu" onmouseover="speakOut(this);">ふ</td><td class="fifty-sounds-kana speak-kana-fu" onmouseover="speakOut(this);">フ</td><td class="fifty-sounds-kana speak-kana-he" onmouseover="speakOut(this);">へ</td><td class="fifty-sounds-kana speak-kana-he" onmouseover="speakOut(this);">ヘ</td><td class="fifty-sounds-kana speak-kana-ho" onmouseover="speakOut(this);">ほ</td><td class="fifty-sounds-kana speak-kana-ho" onmouseover="speakOut(this);">ホ</td></tr><tr><td class="fifty-sounds-row" rowspan="2"><span class="fifty-sounds-romaji">m</span><br>ま 行</td><td colspan="2"><span class="fifty-sounds-romaji">ma</span></td><td colspan="2"><span class="fifty-sounds-romaji">mi</span></td><td colspan="2"><span class="fifty-sounds-romaji">mu</span></td><td colspan="2"><span class="fifty-sounds-romaji">me</span></td><td colspan="2"><span class="fifty-sounds-romaji">mo</span></td></tr><tr><td class="fifty-sounds-kana speak-kana-ma" onmouseover="speakOut(this);">ま</td><td class="fifty-sounds-kana speak-kana-ma" onmouseover="speakOut(this);">マ</td><td class="fifty-sounds-kana speak-kana-mi" onmouseover="speakOut(this);">み</td><td class="fifty-sounds-kana speak-kana-mi" onmouseover="speakOut(this);">ミ</td><td class="fifty-sounds-kana speak-kana-mu" onmouseover="speakOut(this);">む</td><td class="fifty-sounds-kana speak-kana-mu" onmouseover="speakOut(this);">ム</td><td class="fifty-sounds-kana speak-kana-me" onmouseover="speakOut(this);">め</td><td class="fifty-sounds-kana speak-kana-me" onmouseover="speakOut(this);">メ</td><td class="fifty-sounds-kana speak-kana-mo" onmouseover="speakOut(this);">も</td><td class="fifty-sounds-kana speak-kana-mo" onmouseover="speakOut(this);">モ</td></tr><tr><td class="fifty-sounds-row" rowspan="2"><span class="fifty-sounds-romaji">y</span><br>や 行</td><td colspan="2"><span class="fifty-sounds-romaji">ya</span></td><td colspan="2" rowspan="2"><span class="fifty-sounds-romaji-obsolete" rowspan="2">(obsolete)</span></td><td colspan="2"><span class="fifty-sounds-romaji">yu</span></td><td colspan="2" rowspan="2"><span class="fifty-sounds-romaji-obsolete" rowspan="2">(obsolete)</span></td><td colspan="2"><span class="fifty-sounds-romaji">yo</span></td></tr><tr><td class="fifty-sounds-kana speak-kana-ya" onmouseover="speakOut(this);">や</td><td class="fifty-sounds-kana speak-kana-ya" onmouseover="speakOut(this);">ヤ</td><td class="fifty-sounds-kana speak-kana-yu" onmouseover="speakOut(this);">ゆ</td><td class="fifty-sounds-kana speak-kana-yu" onmouseover="speakOut(this);">ユ</td><td class="fifty-sounds-kana speak-kana-yo" onmouseover="speakOut(this);">よ</td><td class="fifty-sounds-kana speak-kana-yo" onmouseover="speakOut(this);">ヨ</td></tr><tr><td class="fifty-sounds-row" rowspan="2"><span class="fifty-sounds-romaji">r</span><br>ら 行</td><td colspan="2"><span class="fifty-sounds-romaji">ra</span></td><td colspan="2"><span class="fifty-sounds-romaji">ri</span></td><td colspan="2"><span class="fifty-sounds-romaji">ru</span></td><td colspan="2"><span class="fifty-sounds-romaji">re</span></td><td colspan="2"><span class="fifty-sounds-romaji">ro</span></td></tr><tr><td class="fifty-sounds-kana speak-kana-ra" onmouseover="speakOut(this);">ら</td><td class="fifty-sounds-kana speak-kana-ra" onmouseover="speakOut(this);">ラ</td><td class="fifty-sounds-kana speak-kana-ri" onmouseover="speakOut(this);">り</td><td class="fifty-sounds-kana speak-kana-ri" onmouseover="speakOut(this);">リ</td><td class="fifty-sounds-kana speak-kana-ru" onmouseover="speakOut(this);">る</td><td class="fifty-sounds-kana speak-kana-ru" onmouseover="speakOut(this);">ル</td><td class="fifty-sounds-kana speak-kana-re" onmouseover="speakOut(this);">れ</td><td class="fifty-sounds-kana speak-kana-re" onmouseover="speakOut(this);">レ</td><td class="fifty-sounds-kana speak-kana-ro" onmouseover="speakOut(this);">ろ</td><td class="fifty-sounds-kana speak-kana-ro" onmouseover="speakOut(this);">ロ</td></tr><tr><td class="fifty-sounds-row" rowspan="2"><span class="fifty-sounds-romaji">w</span><br>わ 行</td><td colspan="2"><span class="fifty-sounds-romaji">wa</span></td><td colspan="2" rowspan="2"><span class="fifty-sounds-romaji-obsolete" rowspan="2">(obsolete)</span></td><td colspan="2" rowspan="2"><span class="fifty-sounds-romaji-obsolete" rowspan="2">(obsolete)</span></td><td colspan="2" rowspan="2"><span class="fifty-sounds-romaji-obsolete" rowspan="2">(obsolete)</span></td><td colspan="2"><span class="fifty-sounds-romaji">o</span></td></tr><tr><td class="fifty-sounds-kana speak-kana-wa" onmouseover="speakOut(this);">わ</td><td class="fifty-sounds-kana speak-kana-wa" onmouseover="speakOut(this);">ワ</td><td class="fifty-sounds-kana speak-kana-wo" onmouseover="speakOut(this);">を</td><td class="fifty-sounds-kana speak-kana-wo" onmouseover="speakOut(this);">ヲ</td></tr><tr><td style="border: none;" rowspan="2"></td><td colspan="10"><span class="fifty-sounds-romaji">n</span></td></tr><tr><td class="fifty-sounds-additional-row speak-kana-n" colspan="5">ん</td><td class="fifty-sounds-additional-row speak-kana-n" colspan="5">ン</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;五十音図&quot;&gt;五十音図&lt;/h1&gt;
&lt;noscript&gt;
请允许运行 JavaScript 以启用点读功能
&lt;/noscript&gt;
&lt;style type=&quot;text/css&quot;&gt;
    td {text-align: center;}
    .fifty-soun</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://devexzh.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="语言学习" scheme="https://devexzh.github.io/tags/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="日语" scheme="https://devexzh.github.io/tags/%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>香辛料使用场景及其作用</title>
    <link href="https://devexzh.github.io/2023/Memo_On_The_Role_Of_Spices/"/>
    <id>https://devexzh.github.io/2023/Memo_On_The_Role_Of_Spices/</id>
    <published>2023-07-19T13:00:00.000Z</published>
    <updated>2023-07-24T06:30:03.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="视频推荐">视频推荐</h1><table><thead><tr class="header"><th style="text-align: center;">香辛料</th><th style="text-align: center;">调料</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><style>.bbplayer{width: 100%; max-width: 850px; margin: auto}</style><div class="bbplayer"><iframe class="bbplayer" id="mmedia-jdZYsdtxWXQdyjxW" src="https://player.bilibili.com/player.html?bvid=BV19h411N76V&amp;page=1&amp;high_quality=1&amp;danmaku=false&amp;autoplay=0" allowfullscreen="allowfullscreen" scrolling="no" border="0" frameborder="0" framespacing="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts allow-popups"></iframe></div><script> document.getElementById("mmedia-jdZYsdtxWXQdyjxW").style.height=document.getElementById("mmedia-jdZYsdtxWXQdyjxW").scrollWidth*0.76+"px";    window.onresize = function(){      document.getElementById("mmedia-jdZYsdtxWXQdyjxW").style.height=document.getElementById("mmedia-jdZYsdtxWXQdyjxW").scrollWidth*0.76+"px";    }; </script></td><td style="text-align: center;"><style>.bbplayer{width: 100%; max-width: 850px; margin: auto}</style><div class="bbplayer"><iframe class="bbplayer" id="mmedia-OsORqDKMgwwXwhIq" src="https://player.bilibili.com/player.html?bvid=BV1DP41197Dj&amp;page=1&amp;high_quality=1&amp;danmaku=false&amp;autoplay=0" allowfullscreen="allowfullscreen" scrolling="no" border="0" frameborder="0" framespacing="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts allow-popups"></iframe></div><script> document.getElementById("mmedia-OsORqDKMgwwXwhIq").style.height=document.getElementById("mmedia-OsORqDKMgwwXwhIq").scrollWidth*0.76+"px";    window.onresize = function(){      document.getElementById("mmedia-OsORqDKMgwwXwhIq").style.height=document.getElementById("mmedia-OsORqDKMgwwXwhIq").scrollWidth*0.76+"px";    }; </script></td></tr></tbody></table><h1 id="分类">分类</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;视频推荐&quot;&gt;视频推荐&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th style=&quot;text-align: center;&quot;&gt;香辛料&lt;/th&gt;
&lt;th style=&quot;text-align: center;&quot;&gt;调料&lt;/th&gt;</summary>
      
    
    
    
    <category term="备忘录" scheme="https://devexzh.github.io/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
    <category term="厨艺" scheme="https://devexzh.github.io/tags/%E5%8E%A8%E8%89%BA/"/>
    
    <category term="分类" scheme="https://devexzh.github.io/tags/%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>C++ 模板元编程笔记</title>
    <link href="https://devexzh.github.io/2023/Note_Of_Cplusplus_Template_Metaprogramming/"/>
    <id>https://devexzh.github.io/2023/Note_Of_Cplusplus_Template_Metaprogramming/</id>
    <published>2023-07-17T11:00:00.000Z</published>
    <updated>2023-07-24T06:29:42.962Z</updated>
    
    <content type="html"><![CDATA[<details><summary>PREFACE</summary><p><br></p><p><strong>参考书籍</strong> <strong>Reference Book</strong>:</p><ul><li><em>C++ Templates: The Complete Guide 2nd Edition</em></li></ul><div style="display: flex; justify-content: center;"><p><img src="https://m.media-amazon.com/images/I/51Rmsy9wSdL.jpg" style="width: 30%;"></p></div><p><br></p><p><strong>版权声明</strong>：本文受到 Creative Commons BY-NC-SA协议的著作权保护，转载或改编时，请署名原作者。</p><p><strong>Copyright</strong>: WRITTEN BY RYKER ZHU in Shanghai under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA</a><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="CC BY-NC-SA" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"></a></p><p><strong>提示</strong>：您可以通过单击网页右侧的目录以快速导航至您需要查看的内容。</p><p><strong>Tips</strong>: You can click on the table of contents on theright sidebar of the web page to navigate.</p><p>本笔记为中英双语，在没有合适的中文对应翻译时，会直接保留英文原名，不便之处敬请谅解。</p><p>除有特殊说明的外，所有以<strong><em>粗斜体</em></strong>标出的皆为概念、以<strong>粗体</strong>标出的为关键点或者小节标题。文中所有代码皆使用<a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License2.0</a> 协议授权。</p><p style="text-align: right;">2023年 夏<br>于上海<br>祝禾 著</p><p></p></details><hr><h1 id="the-basics">The Basics</h1><p><img class="post-gallery-images" oncontextmenu="return false;" id="img-template_params" src="/img/post_gallery/391a733d783b3d32cdea0de0fa557068/template_params.svg"></p><h2 id="function-templates">Function Templates</h2><p>编译模板需要经过两个阶段：</p><ol type="1"><li><strong><em>定义阶段</em></strong> (<em>DefinitionTime</em>)，在该阶段会在忽略掉模板参数的前提下检查错误，也就是和模板参数无关的错误；</li><li><strong><em>实例化阶段</em></strong> (<em>InstantiationTime</em>)，在该阶段经过模板实例化之后，会进行全面错误检查。</li></ol><h2 id="class-templates">Class Templates</h2><h2 id="nontype-template-parameters">Nontype Template Parameters</h2><h2 id="variadic-templates">Variadic Templates</h2><h2 id="tricky-basics">Tricky Basics</h2><h2 id="move-semantics-and-enable_if">Move Semantics and<code>enable_if&lt;&gt;</code></h2><p>C++11 起引入了<strong><em>移动语义</em></strong> (<em>MoveSemantics</em>)这一特性，利用这个特性可以避免在调用拷贝构造函数时，其深度拷贝引发的时间和空间开销问题。</p><p>一类应用移动语义特性的典型如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Move Semantics</span><br>    <span class="hljs-built_in">Object</span>(Object&amp;&amp; another) {<br>        <span class="hljs-keyword">this</span>-&gt;data = another.data;<br>        another.data = <span class="hljs-literal">nullptr</span>;<br>    }<br><br>    ~<span class="hljs-built_in">Object</span>() { <span class="hljs-keyword">delete</span> data; }<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">void</span>* data;<br>};<br></code></pre></td></tr></tbody></table></figure><p>在上述代码中 <code>another</code> 这个形参是右值引用<code>Object &amp;&amp;</code> 的形式，“移动”所做的就是将传入的右值的字段 <code>data</code>移为己有；为了保证调用析构函数 <code>~Object()</code>时，<code>data</code>指向的对象不会被析构两次（右值引用的值在表达式语句结束之后就会马上被析构），所以将数据偷过来之后还需要把原本右值的字段变成空指针，这样析构空指针就不会引发错误了。</p><p>简而言之，移动语义就只干了两件事：</p><ol type="1"><li>将右值的字段移为己用；</li><li>置空右值字段。</li></ol><p>由于本质上只是传递了指针，其时间和空间开销近乎可以忽略不计，相比深度拷贝来说，所需的代价小了不少。</p><h3 id="perfect-forwarding">Perfect Forwarding</h3><p><strong><em>完美转发</em></strong> (<em>PerfectForwarding</em>)，一言以蔽之，就是确保参数在传递过程中，原有的属性限定符保持不变。</p><p>少说废话，直接上代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operation</span><span class="hljs-params">(<span class="hljs-type">const</span> Type&amp; value)</span> </span>{<br>    std::cout &lt;&lt; <span class="hljs-string">"const Type&amp;\t\t"</span> &lt;&lt; value &lt;&lt; std::endl;<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operation</span><span class="hljs-params">(Type&amp; value)</span> </span>{<br>    std::cout &lt;&lt; <span class="hljs-string">"Type&amp;\t\t"</span> &lt;&lt; value &lt;&lt; std::endl;<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operation</span><span class="hljs-params">(Type&amp;&amp; value)</span> </span>{<br>    std::cout &lt;&lt; <span class="hljs-string">"Type&amp;\t\t"</span> &lt;&lt; value &lt;&lt; std::endl;<br>}<br><br><span class="hljs-comment">// Forwarding</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-type">const</span> Type&amp; value)</span> </span>{<br>    <span class="hljs-built_in">operation</span>(value);<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">forward</span><span class="hljs-params">(Type&amp; value)</span> </span>{<br>    <span class="hljs-built_in">operation</span>(value);<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">forward</span><span class="hljs-params">(Type&amp;&amp; value)</span> </span>{<br>    <span class="hljs-built_in">operation</span>(std::<span class="hljs-built_in">move</span>(value));<br>}<br></code></pre></td></tr></tbody></table></figure><p>在上述代码中，定义了两个函数（只看函数名而不是函数签名的话）<code>operation</code>以及<code>forward</code>，后者仅仅是将参数原封不动地传给前者。需要注意的是<code>forward</code> 的第三个函数重载，这里用了 <code>std::move</code>函数，作用是将左值转换成右值，因为虽然其看上去是右值引用<code>Type&amp;&amp;</code>，但实际上是 <code>Type&amp;</code>这个左值。</p><p>如果要用函数模板来实现的话虽然可以写成这个形式：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">forward</span><span class="hljs-params">(T value)</span> </span>{<br>    <span class="hljs-built_in">operation</span>(value);<br>}<br></code></pre></td></tr></tbody></table></figure><p>但是对于右值引用却没法很好地转发，因此 C++11起可以写成以下形式以同时支持上述三种参数类型：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">forward</span><span class="hljs-params">(T&amp;&amp; value)</span> </span>{<br>    <span class="hljs-built_in">operation</span>(std::forward&lt;T&gt;(value));<br>}<br></code></pre></td></tr></tbody></table></figure><p>上面的 <code>T&amp;&amp;</code>称为<strong><em>转发引用</em></strong> (<em>forwarding reference</em>,C++17 标准规定的术语) 或者是 <strong><em>万能引用</em></strong>(<em>universal reference</em>)，但是需要注意，这里的 <code>T</code>是待推导的类型而不是具体的类型，比如 <code>int&amp;&amp;</code>就不是转发引用。</p><h2 id="compile-time-programming">Compile-Time Programming</h2><h2 id="basic-template-terminology">Basic Template Terminology</h2><h2 id="generic-libraries">Generic Libraries</h2><h1 id="templates-in-depth">Templates in Depth</h1><h1 id="templates-and-design">Templates and Design</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;
PREFACE
&lt;/summary&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考书籍&lt;/strong&gt; &lt;strong&gt;Reference Book&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;C++ Templates:</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://devexzh.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="程序设计" scheme="https://devexzh.github.io/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="元编程" scheme="https://devexzh.github.io/tags/%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>电子技术基础笔记</title>
    <link href="https://devexzh.github.io/2023/Note_Of_Fundamentals_Of_Electronics/"/>
    <id>https://devexzh.github.io/2023/Note_Of_Fundamentals_Of_Electronics/</id>
    <published>2023-07-14T14:00:00.000Z</published>
    <updated>2023-09-09T10:52:36.651Z</updated>
    
    <content type="html"><![CDATA[<details><summary>PREFACE</summary><p><br></p><p><strong>Copyright</strong>: WRITTEN BY RYKER ZHU in Shanghai under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA</a><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="CC BY-NC-SA" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"></a></p><strong>Tips</strong>: You can click on the table of contents on theright sidebar of the web page to navigate.</details><h1 id="digital-integrated-circuits">Digital Integrated Circuits</h1><h1 id="analog-integrated-circuits">Analog Integrated Circuits</h1><h2 id="basic-physics-of-semiconductors">Basic Physics ofSemiconductors</h2><table style="border:none;width:100%;text-align:center;"><tbody><tr style="border:none;"><td style="border:none; width:50%;"><img class="post-gallery-images" oncontextmenu="return false;" id="img-silicon_atom" src="/img/post_gallery/ad58b7a3528e73bff9c8a532f7d09129/silicon_atom.svg" alt="The atomic structure of silicon"></td><td style="border:none; width:50%;"><img class="post-gallery-images" oncontextmenu="return false;" id="img-silicons_covalent_bond" src="/img/post_gallery/ad58b7a3528e73bff9c8a532f7d09129/silicons_covalent_bond.svg"></td></tr></tbody></table><p>The sharing of <strong><em>valence electrons</em></strong>, i.e.electrons in the outermost shell, produces strong <strong><em>covalentbonds</em></strong> that hold the atoms together.</p><p>A piece of <strong><em>intrinsic (pure) silicon</em></strong> at roomtemperature has, at any instant, a number of conduction-band (free)electrons that are unattached to any atom and are essentially driftingrandomly throughout the material while an equal number of holes arecreated, which is called <strong><em>intrinsicexcitation</em></strong>.</p><h3 id="p-n-junction">P-N Junction</h3><p><img class="post-gallery-images" oncontextmenu="return false;" id="img-n_and_p_type_semiconductors" src="/img/post_gallery/ad58b7a3528e73bff9c8a532f7d09129/n_and_p_type_semiconductors.svg"></p><p>The conductivity of silicon can be drastically increased by thecontrolled addition of impurities to the intrinsic semiconductor. Thisprocess, called <strong><em>doping</em></strong>, increases the numberof current carriers (electrons or holes), thus increasing theconductivity and decreasing the resistivity. The two categories of dopedintrinsic silicon are N-type and P-type.</p><p><img class="post-gallery-images" oncontextmenu="return false;" id="img-pn_junction" src="/img/post_gallery/ad58b7a3528e73bff9c8a532f7d09129/pn_junction.svg"></p><p>When a piece of intrinsic silicon is doped so that half is N-type andthe other half is P-type, a PN junction is formed between the tworegions where the area on both sides of the junction becomes essentiallydepleted of any conduction electrons or holes and is known as the<strong><em>depletion region</em></strong>.</p><h3 id="reverse-breakdown">Reverse Breakdown</h3><h4 id="bias">Bias</h4><p>The term <strong><em>bias</em></strong> in electronics refers to aﬁxed DC voltage that sets the operating conditions for a semiconductordevice. <strong><em>Forward bias</em></strong> is the condition thatpermits current across a PN junction while the <strong><em>reversebias</em></strong> prevents current across it.</p><h4 id="avalanche-breakdown">Avalanche Breakdown</h4><table><tbody><tr style="border:none;"><td style="border:none;">If the external reverse-bias voltage is increased to a large enoughvalue, <strong><em>avalanche breakdown</em></strong> occurs. Just likenuclear fission, when a free electron acquires enough energy, i.e.higher voltage than the <span class="math inline">\(V_{\mathrm{BR}}\)</span> (see the <a href="#diode-current-voltage-characteristics">figure</a> below), fromthe external source to accelerate it toward the positive end of thediode and then it would collide with atoms so there will be more valenceelectrons turned into free electrons, resulting in a rapid buildup ofreverse current.</td><td style="border:none;text-align:center;"><img class="post-gallery-images" oncontextmenu="return false;" id="img-diode_characteristics_curve" alt="Nuclear Fission" src="/img/post_gallery/ad58b7a3528e73bff9c8a532f7d09129/nuclear_fission_reaction.svg"><figcaption aria-hidden="true" class="image-caption">NuclearFission<br><sub><a href="https://commons.wikimedia.org/wiki/File:Nuclear_fission_reaction.svg">Reference</a></sub></figcaption></td></tr></tbody></table><h2 id="diode-models-and-circuits">Diode Models and Circuits</h2><p><img class="post-gallery-images" id="diode-symbol" oncontextmenu="return false;" src="/img/post_gallery/ad58b7a3528e73bff9c8a532f7d09129/diode_symbol.svg" alt="Standard schematic symbol for diode"></p><table><tbody><tr style="border:none;"><td style="border:none;">There is nearly no forward current for forward voltages below thebarrier potential (0.7V on the figure, which is the typical for siliconand the germanium's is 0.3V) but as the voltage reaches it, the currentincreases drastically and must be limited. For a forward-biased diode,the voltage is also called the <b><i>diode drop</i></b>.</td><td style="border:none;" width="40%"><img class="post-gallery-images" id="diode-current-voltage-characteristics" oncontextmenu="return false;" src="/img/post_gallery/ad58b7a3528e73bff9c8a532f7d09129/diode_characteristics_curve.svg"></td></tr></tbody></table><h3 id="special-purpose-diodes">Special-Purpose Diodes</h3><h4 id="zener-diode">Zener Diode</h4><p><img class="post-gallery-images" id="zdiode-symbol" oncontextmenu="return false;" src="/img/post_gallery/ad58b7a3528e73bff9c8a532f7d09129/zdiode_symbol.svg" alt="Standard schematic symbol for zener diode"></p><p>For the general purpose diodes, it should not operate in thereverse-breakdown region but the zener diode does. From the figureabove, when the diode is reverse biased and reaches <span class="math inline">\(V_{\mathrm{BR}}\)</span>, the current wouldincrease drastically but the voltage remains almost unchanged.</p><h2 id="bipolar-junction-transistors">Bipolar Junction Transistors</h2><p>The <strong><em>bipolar junction transistor</em></strong>(<em>BJT</em>) is constructed with three doped semiconductor regionscalled emitter, base, and collector, where each of two are separated bytwo PN junctions.</p><p><img class="post-gallery-images" id="bjt-structure" oncontextmenu="return false;" src="/img/post_gallery/ad58b7a3528e73bff9c8a532f7d09129/bjt_struct.svg" alt="Two types of BJT"></p><h2 id="field-effect-transistors">Field Effect Transistors</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;
PREFACE
&lt;/summary&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Copyright&lt;/strong&gt;: WRITTEN BY RYKER ZHU in Shanghai under &lt;a href=&quot;http://cre</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://devexzh.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="电子学" scheme="https://devexzh.github.io/tags/%E7%94%B5%E5%AD%90%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络笔记</title>
    <link href="https://devexzh.github.io/2023/Note_Of_Computer_Network/"/>
    <id>https://devexzh.github.io/2023/Note_Of_Computer_Network/</id>
    <published>2023-07-12T06:00:00.000Z</published>
    <updated>2023-09-09T08:04:17.329Z</updated>
    
    <content type="html"><![CDATA[<details><summary>PREFACE</summary><p><br></p><p><strong>Reference Book</strong>:</p><ul><li><em>Computer Networking: A Top-Down Approach 8th Edition</em></li></ul><div class="books-container"><p><img src="https://m.media-amazon.com/images/I/51vT3X2tdtL.jpg" class="book-cover"></p></div><style type="text/css">    .books-container {        display: flex;        justify-content: center;        flex-direction: row;    }    .book-cover {        width: 10em;        box-shadow: 1ex 1ex 1.5ex rgba(0, 0, 0, 0.3);        transition: all 0.3s ease-in-out;    }    .book-cover:hover {        transform: scale(1.25) rotateZ(20deg);    }</style><p><strong>Copyright</strong>: WRITTEN BY RYKER ZHU in Shanghai under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA</a><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="CC BY-NC-SA" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"></a></p><strong>Tips</strong>: You can click on the table of contents on theright sidebar of the web page to navigate.</details><h1 id="computer-networks-and-the-internet">Computer Networks and theInternet</h1><p><img src="/img/post_gallery/30d6b2fafb2300e024f9e9fdcd619e99/nuts_and_bolts_of_internet.svg"></p><div class="to-be-continued" style="width: 100%; border-radius: 10px; text-align: center; background: linear-gradient(#484878, #202048); color: #e8c890; padding: 2%; box-shadow: 2px 2px rgba(0,0,0,0.5);">未完待续<br>To be continued...</div><div style="display: none;"><h1 id="application-layer">Application Layer</h1><h1 id="transport-layer">Transport Layer</h1><h1 id="the-network-layer-data-plane">The Network Layer: Data Plane</h1><h1 id="the-network-layer-control-plane">The Network Layer: ControlPlane</h1><h1 id="the-link-layer-and-lans">The Link Layer and LANs</h1><h1 id="wireless-and-mobile-networks">Wireless and Mobile Networks</h1><h1 id="security-in-computer-networks">Security in ComputerNetworks</h1></div>]]></content>
    
    
    <summary type="html">（未完待续）《计算机网络》作为本科阶段计算机相关专业的必修课，对于认识网络架构有着举足轻重的作用。本文是针对 Computer Networking A Top-Down Approach 这本书的学习笔记。</summary>
    
    
    
    <category term="学习笔记" scheme="https://devexzh.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机" scheme="https://devexzh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法笔记</title>
    <link href="https://devexzh.github.io/2023/Note_Of_Data_Structures_And_Algorithms/"/>
    <id>https://devexzh.github.io/2023/Note_Of_Data_Structures_And_Algorithms/</id>
    <published>2023-07-03T01:00:00.000Z</published>
    <updated>2023-08-05T05:55:56.488Z</updated>
    
    <content type="html"><![CDATA[<details><summary>PREFACE</summary><p><br></p><p><strong>Reference Book</strong>:</p><ul><li><em>Data Structures and Algorithm Analysis in C++ 4thEdition</em></li><li><em>Data Structures and Algorithm Analysis in Java 3rdEdition</em></li></ul><div class="books-container"><p><img src="https://m.media-amazon.com/images/I/41x7Y46JVkL.jpg" class="book-cover"><img src="https://m.media-amazon.com/images/I/41MMd73GzcL.jpg" class="book-cover"></p></div><style type="text/css">    .books-container {        display: flex;        justify-content: center;        flex-direction: row;    }    .book-cover {        width: 10em;        box-shadow: 1ex 1ex 1.5ex rgba(0, 0, 0, 0.3);        transition: all 0.3s ease-in-out;    }    .book-cover:hover {        transform: scale(1.25) rotateZ(20deg);    }</style><p><span class="github-emoji"><span>📓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4d3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> This note would present code in multiple languages(<code>C++</code>, <code>Java</code> and <code>Python</code>) where theyare tested well to ensure their running. Make sure you have commanded atleast one of them first, or it will be hard for you to read.</p><p><strong>Copyright</strong>: WRITTEN BY RYKER ZHU in Shanghai under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA</a><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="CC BY-NC-SA" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"></a></p><p><b><span style="color: red;">Unless otherwise noted, all graphics andimages in this post were drawn by the author and are protected bycopyright under the Creative Commons agreement. Any commercial use ofthe works is strictly prohibited. By copying or adapting this article,you are agreeing to and accepting the restrictions of the terms andconditions.</span></b></p><p>If you find any errors, please contact me via email and I will makecorrections as soon as possible.</p><strong>Tips</strong>: You can click on the table of contents on theright sidebar of the web page to navigate.</details><script type="text/javascript">    window.addEventListener('load', function () {        var t = document.querySelectorAll(".md-centering-table");        for(let i = 0; i < t.length; i++) {            var w = t[i].clientWidth / 2;            t[i].style.marginLeft = w;            t[i].style.marginRight = w;        }    });</script><h1 id="overview">Overview</h1><h2 id="c-details">C++ Details</h2><h3 id="lvalues-rvalues-and-references">Lvalues, Rvalues andReferences</h3><p>As the textbook defines,</p><blockquote><p><strong>Lvalue</strong>: expression that identifies a<strong>non-temporary</strong> object;<br><strong>Rvalue</strong>: expression that identifies a<strong>temporary</strong> object or or is a value not associated withany object.</p></blockquote><p><span class="github-emoji"><span>📓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4d3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> If a variable has a name, then regardless of whether it ismodifiable, it is a lvalue.</p><p><a href="https://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c/">ClickHere to know more about lvalues and rvalues</a></p><p><strong>Example</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-number">666</span> = variable;         <span class="hljs-comment">// ERROR !!!</span><br>(variable + <span class="hljs-number">1</span>) = <span class="hljs-number">1234</span>;  <span class="hljs-comment">// ERROR !!!</span><br></code></pre></td></tr></tbody></table></figure><p>Neither the constant <code>666</code> nor the expression<code>variable + 1</code> are lvalues since they are temporary resultsof expressions, and they reside in some temporary register for theduration of computation.</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> variable = <span class="hljs-number">1234</span>;  <span class="hljs-comment">// It's a lvalue,</span><br>variable = <span class="hljs-number">4321</span>;            <span class="hljs-comment">// but it cannot be assigned!</span><br></code></pre></td></tr></tbody></table></figure><p>Not all lvalues can be assigned to but except for this special case,initially, lvalues meant "values suitable for left-hand-side ofassignment".</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::string firstName = <span class="hljs-string">"Ryker"</span>;    <span class="hljs-comment">// Lvalue</span><br>std::string lastName = <span class="hljs-string">"Zhu"</span>;       <span class="hljs-comment">// Lvalue</span><br>std::string fullName = firstName + lastName; <span class="hljs-comment">// Converted to Rvalue</span><br></code></pre></td></tr></tbody></table></figure><p>All lvalues that aren't arrays, functions or of incomplete types canbe converted to rvalues.</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; lvalue_ref)</span> </span>{<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">doSomething</span>(a); <span class="hljs-comment">// WORKS</span><br>    <span class="hljs-built_in">doSomething</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// ERROR</span><br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; b = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">doSomething</span>(b); <span class="hljs-comment">// WORKS</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>Rvalues cannot be converted into a lvalue reference but can be constlvalue reference. (That is why pass-by-constant is so common in C++)</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(cosnt <span class="hljs-type">int</span>&amp; value)</span> </span>{<br>    std::cout &lt;&lt; <span class="hljs-string">"[lvalue] "</span> &lt;&lt; value &lt;&lt; std::endl;<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;&amp; value)</span> </span>{<br>    std::cout &lt;&lt; <span class="hljs-string">"[rvalue] "</span> &lt;&lt; value &lt;&lt; std::endl;<br>}<br></code></pre></td></tr></tbody></table></figure><p>C++11 standard supports <a href="https://en.cppreference.com/w/cpp/language/reference#Rvalue_references">rvaluereference</a> and it is useful for detecting whether an object istemporary or persistent and especially with move semantics.</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">string</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">string</span>(<span class="hljs-type">char</span>* str) {<br>        m_size = <span class="hljs-built_in">strlen</span>(str) + <span class="hljs-number">1</span>;<br>        m_data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[m_size]; <span class="hljs-comment">// Deep Copy</span><br>        <span class="hljs-built_in">memcpy</span>(m_data, str, m_size);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Created!\n"</span>);<br>    }<br><br>    ~<span class="hljs-built_in">string</span>() {<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Destroyed!\n"</span>);<br>        <span class="hljs-keyword">delete</span> m_data;<br>    }<br><br>    <span class="hljs-built_in">string</span>(<span class="hljs-type">const</span> string&amp; another) {<br>        m_size = another.m_size;<br>        m_data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[m_size]; <span class="hljs-comment">// Deep Copy</span><br>        <span class="hljs-built_in">memcpy</span>(m_data, another.m_data, m_size);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Copied!\n"</span>);<br>    }<br><br>    <span class="hljs-built_in">string</span>(string&amp;&amp; another) {<br>        <span class="hljs-comment">// Move Semantics</span><br>        <span class="hljs-comment">// Just like stealing the data from another object</span><br>        m_data = another.m_data; <span class="hljs-comment">// Move the pointer</span><br>        m_size = another.m_size;<br><br>        another.m_size = <span class="hljs-number">0</span>;<br>        another.m_data = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Moved!\n"</span>);<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; m_size; ++i)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>, m_data[i]);<br>    }<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* m_data;<br>    <span class="hljs-type">int</span> m_size;<br>};<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">entity</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">entity</span>(<span class="hljs-type">const</span> string&amp; str) : <span class="hljs-built_in">m_string</span>(str) {<br>    }<br><br>    <span class="hljs-built_in">entity</span>(string&amp;&amp; str) : <span class="hljs-built_in">m_string</span>(std::<span class="hljs-built_in">move</span>(str)) {<br>        <span class="hljs-comment">// std::move works same as just simply</span><br>        <span class="hljs-comment">// cast it into rvalue reference.</span><br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>{<br>        m_string.<span class="hljs-built_in">print</span>();<br>    }<br><br><span class="hljs-keyword">private</span>:<br>    string m_string;<br>};<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-function">string <span class="hljs-title">lvalue_string</span><span class="hljs-params">(<span class="hljs-string">"Hello!\n"</span>)</span></span>;<br>    <span class="hljs-function">entity <span class="hljs-title">copied_entity</span><span class="hljs-params">(lvalue_string)</span></span>;<br>    copied_entity.<span class="hljs-built_in">print</span>();<br><br>    <span class="hljs-function">entity <span class="hljs-title">moved_entity</span><span class="hljs-params">(<span class="hljs-string">"Bonjour!\n"</span>)</span></span>;<br>    moved_entity.<span class="hljs-built_in">print</span>();<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="generic-classes-and-templates">Generic Classes andTemplates</h2><p>Both Java and C++ provides "template" but their mechanisms differfrom each other. Java employs <strong>Type Erasure</strong> (since allclasses written in Java extends from <code>java.lang.Object</code>)while C++ template member functions would only be created when they arecalled.</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Type&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MemoryCell</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MemoryCell</span><span class="hljs-params">(<span class="hljs-type">const</span> Type &amp;initial = Type())</span> : </span><br><span class="hljs-function">        m_data(initial) {</span>}<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> Type&amp; data)</span> </span>{<br>        m_data = data;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">const</span> Type&amp; <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> m_data;<br>    }<br><br><span class="hljs-keyword">private</span>:<br>    Type m_data;<br>}<br></code></pre></td></tr></tbody></table></figure><p>Same class written in Java:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MemoryCell</span>&lt;Type&gt; {<br>    <span class="hljs-keyword">public</span> Type <span class="hljs-title function_">read</span><span class="hljs-params">()</span> {<span class="hljs-keyword">return</span> m_data;}<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(Type data)</span> {m_data = data;}<br>    <span class="hljs-keyword">private</span> Type m_data;<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="algorithm-analysis">Algorithm Analysis</h1><p><img class="post-gallery-images" oncontextmenu="return false;" id="img-analysis" src="/img/post_gallery/14e0db42d09363a6774504c54ea40fcb/analysis.svg"></p><h2 id="mathematical-analysis">Mathematical Analysis</h2><p>Some contents are just directly copied from another post: <a href="../Note_Of_Introduction_To_Algorithms/">Note of <em>Introductionto Algorithms</em></a></p><h2 id="running-time-calculation">Running Time Calculation</h2><h3 id="general-rules">General Rules</h3><ul><li><p><code>for</code> loops</p><p>The running time of a <code>for</code> loop is at most the runningtime of the statements inside the for loop (including tests) times thenumber of iterations.</p></li><li><p>Nested loops</p><p>The total running time of a statement inside a group of nested loopsis the running time of the statement multiplied by the product of thesizes of all the loops.</p></li><li><p>Consecutive statements</p><p>These just add (which means that the maximum is the one thatcounts).</p></li><li><p><code>if</code> / <code>else</code></p><p>The running time of an if/else statement is never more than therunning time of the test plus the larger one of the running times of twobraches.</p></li></ul><h3 id="logarithms-in-the-running-time">Logarithms in the RunningTime</h3><p><strong>General rules to distinguish between <span class="math inline">\(O(n)\)</span> and <span class="math inline">\(O(\log n)\)</span></strong></p><ul><li>An algorithm is <span class="math inline">\(O\left(\log{n}\right)\)</span> <em>if it takes<u>constant</u> <span class="math inline">\(O\left(1\right)\)</span>time to cut the problem size by a fraction</em> (which is usually <span class="math inline">\(\dfrac12\)</span>).</li><li>An algorithm is <span class="math inline">\(O\left(n\right)\)</span>if constant time is required to merely reduce the problem by a constantamount (such as to make the problem smaller by 1).</li></ul><table class="md-centering-table table markdown-body"><tbody><tr><th>Algorithms</th><th>Running Time</th></tr><tr><td>Binary Search</td><td rowspan="2"><a href="#img-analysis">Logarithm</a></td></tr><tr><td><a href="../Note_Of_Discrete_Mathematics/#euclidean-algorithm">EuclideanAlgorithm</a></td></tr></tbody></table><h1 id="lists-stacks-and-queues">Lists, Stacks and Queues</h1><pre><code class=" mermaid">flowchart LR;logical(Logical Structure) --- linear(Linear Structure) &amp; nonlinear(Non-linear Structure)linear --- List &amp; Stack &amp; Queue &amp; String &amp; Arraynonlinear --- Tree &amp; Graphclick Tree href "https://devexzh.github.io/2023/Note_Of_Data_Structures_And_Algorithms/#trees" _blankclick Graph href "https://devexzh.github.io/2023/Note_Of_Data_Structures_And_Algorithms/#graph-algorithms" _blankclick Stack href "https://devexzh.github.io/2023/Note_Of_Data_Structures_And_Algorithms/#stacks" _blankclick Queue href "https://devexzh.github.io/2023/Note_Of_Data_Structures_And_Algorithms/#queues" _blank</code></pre><h2 id="stacks">Stacks</h2><blockquote><p>A stack is a list with the restriction that insertions and deletionscan be performed in only one position, namely, the end of the list,called the top.</p></blockquote><p><strong>Implementations</strong></p><ol type="1"><li><p>Array or vector based</p><p><strong>Features</strong>: easy, convenient but easy to causeerrors.</p><ul><li><strong><em>Stack Underflow</em></strong> — An error called when anitem is popped from a stack, but the stack is empty.</li><li><strong><em>Stack Overflow</em></strong> — An error called when anitem is pushed onto a stack, but the stack is full.</li></ul><p><img class="post-gallery-images" oncontextmenu="return false;" id="img-stack" src="/img/post_gallery/14e0db42d09363a6774504c54ea40fcb/stack.svg"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_MAX_SIZE 128</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> {<br><span class="hljs-keyword">private</span>:<br>    ElementType *base, *top;<br>    <span class="hljs-type">int</span> stacksize;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Stack</span>() : <span class="hljs-built_in">base</span>(<span class="hljs-keyword">new</span> ElementType[STACK_MAX_SIZE]),<br>              <span class="hljs-built_in">top</span>(base),<br>              <span class="hljs-built_in">stacksize</span>(STACK_MAX_SIZE) {<br>        <span class="hljs-keyword">if</span>(!base) <span class="hljs-keyword">throw</span> <span class="hljs-string">"Stack Overflow"</span>;<br>    }<br><br>    ~<span class="hljs-built_in">Stack</span>() <span class="hljs-keyword">noexcept</span> {<br>        <span class="hljs-keyword">delete</span>[] base;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> ElementType&amp; value)</span> </span>{<br>        <span class="hljs-keyword">if</span>(top - base == stacksize)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-string">"Full Stack"</span>;<br>        *top = value;<br>        ++top;<br>    }<br><br>    <span class="hljs-function">ElementType&amp; <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">if</span>(top == base)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-string">"Empty Stack"</span>;<br>        ElementType* e = top;<br>        --top;<br>        <span class="hljs-keyword">return</span> *e;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>{<br>        <span class="hljs-keyword">return</span> top == base;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>{<br>        <span class="hljs-keyword">return</span> top - base;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure></li><li><p>Linked-list based</p><p><img class="post-gallery-images" oncontextmenu="return false;" id="img-ll_based_stack" src="/img/post_gallery/14e0db42d09363a6774504c54ea40fcb/ll_based_stack.svg"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackNode</span> {<br>        <span class="hljs-keyword">friend</span> Stack;<br>    <span class="hljs-keyword">private</span>:<br>        ElementType data;<br>        StackNode* next;<br>    } *top;<br> <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Stack</span>() <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) {}<br>    ~<span class="hljs-built_in">Stack</span>() <span class="hljs-keyword">noexcept</span> {<br>        StackNode *p = top;<br>        <span class="hljs-keyword">while</span>(p-&gt;next) {<br>            <span class="hljs-keyword">delete</span> p;<br>            p = p-&gt;next;<br>        }<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> ElementType&amp; value)</span> <span class="hljs-keyword">noexcept</span> </span>{<br>        StackNode* p = <span class="hljs-keyword">new</span> StackNode;<br>        p-&gt;data = value;<br>        p-&gt;next = top;<br>        top = p;<br>    }<br><br>    <span class="hljs-function">ElementType&amp; <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">if</span>(!top) <span class="hljs-keyword">throw</span> <span class="hljs-string">"Stack Underflow"</span>;<br>        ElementType&amp;&amp; e = top-&gt;data;<br>        StackNode* p = top;<br>        top = top-&gt;next;<br>        <span class="hljs-keyword">delete</span> p;<br>        <span class="hljs-keyword">return</span> e;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>{<br>        <span class="hljs-keyword">return</span> !top;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>{<br>        <span class="hljs-keyword">if</span>(!top) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        StackNode* p = top;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(p-&gt;next) {<br>            p = p-&gt;next;<br>            ++count;<br>        }<br>        <span class="hljs-keyword">return</span> count;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure></li></ol><p><strong>Standard Libraries Support</strong></p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">C++</th><th style="text-align: center;">Java</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Standard Library</td><td style="text-align: center;"><code>#include &lt;stack&gt;</code><br><code>std::stack&lt;T&gt;</code></td><td style="text-align: center;"><code>package java.util;</code><br><code>Stack&lt;E&gt; extends Vector&lt;E&gt;</code></td></tr><tr class="even"><td style="text-align: center;">Check if is empty</td><td style="text-align: center;"><code>bool empty() const</code></td><td style="text-align: center;"><code>boolean empty()</code></td></tr><tr class="odd"><td style="text-align: center;">Number of elements</td><td style="text-align: center;"><code>size_type size() const</code></td><td style="text-align: center;"><code>int size()</code><br>(inheritedfrom <code>Vector&lt;E&gt;</code>)</td></tr><tr class="even"><td style="text-align: center;">Top element access</td><td style="text-align: center;"><code>T&amp; top()</code></td><td style="text-align: center;"><code>E peek()</code></td></tr><tr class="odd"><td style="text-align: center;">Push</td><td style="text-align: center;"><code>void push(const T&amp;)</code></td><td style="text-align: center;"><code>E push(E)</code></td></tr><tr class="even"><td style="text-align: center;">Pop</td><td style="text-align: center;"><code>void pop()</code></td><td style="text-align: center;"><code>E pop()</code></td></tr></tbody></table><h2 id="queues">Queues</h2><blockquote><p>Like stacks, <strong><em>queues</em></strong> are lists. With aqueue, however, insertion is done at one end whereas deletion isperformed at the other end.</p></blockquote><p><strong>Implementations</strong></p><ol type="1"><li><p>Array or vector based</p><p><img class="post-gallery-images" oncontextmenu="return false;" id="img-non_circular_list" src="/img/post_gallery/14e0db42d09363a6774504c54ea40fcb/non_circular_list.svg"></p><p>When array is employed to serve as the base container of queue, itwould sometimes encounter the problem of overflow (the pointer<code>rear</code> points out of range, as is depicted as the fourthfigure above). A better way to solve it is to consider the array as acircular one (i.e. <strong><em>circular array</em></strong>), as isshown below.</p><p><img class="post-gallery-images" oncontextmenu="return false;" id="img-circular_array_queue" src="/img/post_gallery/14e0db42d09363a6774504c54ea40fcb/circular_array_queue.svg"></p><p>There still exists a problem: how to deal with<code>rear == front</code> since both empty <span class="math inline">\(Q_e\)</span> and full queue <span class="math inline">\(Q_f\)</span> satisfy the condition, as is shownabove. There are three methods to wrestle with it:</p><ol type="1"><li>Add an extra boolean field to distinguish whether it is full orempty;</li><li>Add an extra integer field to keep the record of number ofelements;</li><li>Reserve an index intentionally.</li></ol><p><br></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_QUEUE_SIZE 128</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span> {<br><span class="hljs-keyword">private</span>:<br>    ElementType *base;<br>    <span class="hljs-type">int</span> front, rear;<br> <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Queue</span>() : <span class="hljs-built_in">font</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">rear</span>(<span class="hljs-number">0</span>),<br>              <span class="hljs-built_in">base</span>(<span class="hljs-keyword">new</span> ElementType[MAX_QUEUE_SIZE]) {}<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-type">const</span> ElementType&amp; value)</span> </span>{<br>        <span class="hljs-keyword">if</span>((rear + <span class="hljs-number">1</span>) % MAX_QUEUE_SIZE == front)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-string">"Full Stack, cannot enqueue"</span>;<br>        base[rear] = value;<br>        <span class="hljs-comment">// Simply increment rear might cause overflow</span><br>        rear = (rear + <span class="hljs-number">1</span> == MAX_QUEUE_SIZE ? <span class="hljs-number">0</span> : rear + <span class="hljs-number">1</span>);<br>    }<br><br>    <span class="hljs-function">ElementType&amp; <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">if</span>(front == rear)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-string">"Empty Queue, Nothing to dequeue"</span>;<br>        ElementType&amp;&amp; e = base[front];<br>        front = (front + <span class="hljs-number">1</span> == MAX_QUEUE_SIZE ? <span class="hljs-number">0</span> : front + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> e;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>{<br>        <span class="hljs-keyword">return</span> (rear - front + MAX_QUEUE_SIZE) % MAX_QUEUE_SIZE;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>{<br>        <span class="hljs-keyword">return</span> front == rear;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure></li><li><p>Linked-list based</p></li></ol><h1 id="trees">Trees</h1><p>A <strong><em>tree</em></strong> is a collection of <span class="math inline">\(N\)</span> nodes.</p><ul><li><p><span class="math inline">\(N=0\)</span>, it is empty;</p></li><li><p><span class="math inline">\(N\gt 0\)</span>, it is consistsof</p><ol type="1"><li>a distinguished node <span class="math inline">\(r\)</span>, calledthe root;</li><li>zero or more nonempty (sub)trees <span class="math inline">\(T_1,\,T_2,\,\cdots,\,T_k\)</span>, each of whoseroots are connected by a directed <strong><em>edge</em></strong> fromr.</li></ol></li></ul><p><strong>Properties</strong></p><ul><li><p><strong><em>Depth</em></strong>: The length of the unique pathfrom the root to a node <span class="math inline">\(n_i\)</span>. (<span class="math inline">\(\text{Level}=\text{depth}+1\)</span>)</p></li><li><p><b><i><span id="anchor-tree-props-height">Height</span></i></b>:The length of the longest path from a node <span class="math inline">\(n_i\)</span> to a leaf.</p><ul><li>The height of a tree is equal to the height of the root.</li></ul></li></ul><p><img class="post-gallery-images" oncontextmenu="return false;" id="img-treeillus" src="/img/post_gallery/14e0db42d09363a6774504c54ea40fcb/treeillus.svg"></p><h2 id="binary-trees">Binary Trees</h2><p><strong>Properties</strong></p><ol type="1"><li>A binary tree has <span class="math inline">\(\textcolor{orange}{\text{at most}}\)</span> <span class="math inline">\(2^d\)</span> nodes with depth <span class="math inline">\(d\)</span>;</li><li>A binary tree has <span class="math inline">\(\textcolor{orange}{\text{at most}}\)</span> <span class="math inline">\(2^{h-1}-1\)</span> nodes with height <span class="math inline">\(h\)</span>;</li><li>For all binary tree <span class="math inline">\(T\)</span>, if ithas <span class="math inline">\(n_0\)</span> leaves and <span class="math inline">\(n_2\)</span> nodes with degree of <span class="math inline">\(2\)</span>, then <span class="math inline">\(n_0=n_2+1\)</span>.</li></ol><p><strong><em>Full Binary Trees</em></strong> <span class="github-emoji"><span>🆚</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f19a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong><em>CompleteBinary Trees</em></strong></p><ul><li>A <strong><em>full binary tree</em></strong> (sometimes properbinary tree) is a tree in which every node other than the leaves has twochildren.</li><li>A <strong><em>complete binary tree</em></strong> is a binary tree inwhich every level, except possibly the last, is completely filled, andall nodes are as far left as possible.</li></ul><p><img class="post-gallery-images" oncontextmenu="return false;" id="img-diff_full_and_compl_bin_tree" src="/img/post_gallery/14e0db42d09363a6774504c54ea40fcb/diff_full_and_compl_bin_tree.svg"></p><p><strong>Implementation</strong> (C++)</p><ol type="1"><li><p>Sequential storage</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-keyword">using</span> BinaryTree&lt;ElementType&gt; = std::vector&lt;ElementType&gt;;<br></code></pre></td></tr></tbody></table></figure></li><li><p>Linked-list storage</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTree</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BinaryTree</span>() : <span class="hljs-built_in">left_child</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right_child</span>(<span class="hljs-literal">nullptr</span>) {}<br>    ~<span class="hljs-built_in">BinaryTree</span>() {<br>        <span class="hljs-keyword">delete</span> left_child;<br>        <span class="hljs-keyword">delete</span> right_child;<br>        left_child = right_child = <span class="hljs-literal">nullptr</span>;<br>    }<br><br><span class="hljs-keyword">private</span>:<br>    BinaryTree* left_child, right_child;<br>    ElementType data;<br>};<br></code></pre></td></tr></tbody></table></figure><p>or add an extra field <code>parent</code>, a pointer to itsparent</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTree</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BinaryTree</span>() : <span class="hljs-built_in">left_child</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right_child</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">parent</span>(<span class="hljs-literal">nullptr</span>) {}<br>    ~<span class="hljs-built_in">BinaryTree</span>() {<br>        <span class="hljs-keyword">delete</span> left_child;<br>        <span class="hljs-keyword">delete</span> right_child;<br>        left_child = right_child = <span class="hljs-literal">nullptr</span>;<br>    }<br><br><span class="hljs-keyword">protected</span>:<br>    BinaryTree* left_child, right_child, parent;<br>    ElementType data;<br>};<br></code></pre></td></tr></tbody></table></figure></li></ol><h2 id="tree-traversals">Tree Traversals</h2><p><img class="post-gallery-images" oncontextmenu="return false;" id="img-tree_traversals" src="/img/post_gallery/14e0db42d09363a6774504c54ea40fcb/tree_traversals.svg"></p><table class="md-centering-table markdown-body" style="margin: 0 auto;"><thead><tr class="header" style="text-align: center;"><th>Preorder Traversal</th><th>Inorder Traversal</th><th>Postorder Traversal</th></tr></thead><tbody style="text-align: left; margin: 0;"><tr class="odd"><td colspan="3" style="text-align: center;">If the tree is empty, then simply return.</td></tr><tr class="even"><td><ol type="1"><li style="color: #4384a1;">Visit the root;</li><li>Traverse the left subtree;</li><li>Traverse the right subtree.</li></ol></td><td><ol type="1"><li>Traverse the left subtree;</li><li style="color: #4384a1;">Visit the root;</li><li>Traverse the right subtree.</li></ol></td><td><ol type="1"><li>Traverse the left subtree;</li><li>Traverse the right subtree;</li><li style="color: #4384a1;">Visit the root;</li></ol></td></tr></tbody></table><p><br></p><p><strong>Implementation</strong> (C++)</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ElementType&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreorderTraversal</span><span class="hljs-params">(BinaryTree&lt;ElementType&gt; *tree)</span> </span>{<br>    <span class="hljs-keyword">if</span>(!tree) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">visit</span>(tree); <span class="hljs-comment">// Visit the root node</span><br>    <span class="hljs-built_in">PreorderTraversal</span>(tree-&gt;left_child);<br>    <span class="hljs-built_in">PreorderTraversal</span>(tree-&gt;right_child);<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ElementType&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InorderTraversal</span><span class="hljs-params">(BinaryTree&lt;ElementType&gt; *tree)</span> </span>{<br>    <span class="hljs-keyword">if</span>(!tree) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">InorderTraversal</span>(tree-&gt;left_child);<br>    <span class="hljs-built_in">visit</span>(tree); <span class="hljs-comment">// Visit the root node</span><br>    <span class="hljs-built_in">InorderTraversal</span>(tree-&gt;right_child);<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ElementType&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostorderTraversal</span><span class="hljs-params">(BinaryTree&lt;ElementType&gt; *tree)</span> </span>{<br>    <span class="hljs-keyword">if</span>(!tree) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">PostorderTraversal</span>(tree-&gt;left_child);<br>    <span class="hljs-built_in">PostorderTraversal</span>(tree-&gt;right_child);<br>    <span class="hljs-built_in">visit</span>(tree); <span class="hljs-comment">// Visit the root node</span><br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="applications">Applications</h3><h4 id="mathematical-notations">Mathematical notations</h4><table class="md-centering-table markdown-body" style="border: none; border-collapse: collapse;"><tbody><tr style="border: none;"><td style="border: none;" rowspan="3"><img class="post-gallery-images" oncontextmenu="return false;" id="img-tree_traversal_polish_notation" src="/img/post_gallery/14e0db42d09363a6774504c54ea40fcb/tree_traversal_polish_notation.svg"></td><td style="border: none;"><b>Preorder Traversal</b>:<math xmlns="http://www.w3.org/1998/Math/MathML"><mo>−</mo><mo>+</mo><mi>a</mi><mo>×</mo><mi>b</mi><mo>−</mo><mi>c</mi><mi>d</mi><mo>÷</mo><mi>e</mi><mi>f</mi></math><br>Also called <i><b>Polish notation (PN)</b></i></td></tr><tr style="border: none;"><td style="border: none;"><b>Inorder Traversal</b>:<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi><mo>+</mo><mi>b</mi><mo>×</mo><mi>c</mi><mo>−</mo><mi>d</mi><mo>-</mo><mi>e</mi><mo>÷</mo><mi>f</mi></math></td></tr><tr style="border: none;"><td style="border: none;"><b>Postorder Traversal</b>:<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi><mi>b</mi><mi>c</mi><mi>d</mi><mo>-</mo><mo>×</mo><mo>+</mo><mi>e</mi><mi>f</mi><mo>÷</mo><mo>-</mo></math><br>Also called <i><b>Reverse Polish notation (RPN)</b></i></td></tr></tbody></table><h4 id="construct-a-binary-tree">Construct a binary tree</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ElementType&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BinaryTree::createBinaryTree</span><span class="hljs-params">(BinaryTree&lt;ElementType&gt;* tree)</span> </span>{<br>    <span class="hljs-type">char</span> current_char;<br>    std::cin &gt;&gt; current_char;<br>    <span class="hljs-keyword">if</span>(current_char == <span class="hljs-string">'#'</span>)<br>        tree = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">else</span> {<br>        tree = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BinaryTree</span>&lt;ElementType&gt;();<br>        tree-&gt;data = current_char;<br>        <span class="hljs-built_in">createBinaryTree</span>(tree-&gt;left_child);<br>        <span class="hljs-built_in">createBinaryTree</span>(tree-&gt;right_child);<br>    }<br>}<br><br>BinaryTree::<span class="hljs-built_in">BinaryTree</span>() {<br>    <span class="hljs-type">char</span> current_char;<br>    std::cin &gt;&gt; current_char;<br>    <span class="hljs-keyword">if</span>(current_char != <span class="hljs-string">'#'</span>) {<br>        data = current_char;<br>        <span class="hljs-built_in">createBinaryTree</span>(left_child);<br>        <span class="hljs-built_in">createBinaryTree</span>(right_child);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="copy-a-binary-tree">Copy a binary tree</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ElementType&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BinaryTree::copyBinaryTree</span><span class="hljs-params">(BinaryTree&lt;ElementType&gt; *original,</span></span><br><span class="hljs-params"><span class="hljs-function">                                BinaryTree&lt;ElementType&gt; *target)</span> </span>{<br>    <span class="hljs-keyword">if</span>(!original) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">else</span> {<br>        target = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BinaryTree</span>&lt;ElementType&gt;();<br>        target-&gt;data = original-&gt;data;<br>        <span class="hljs-built_in">copyBinaryTree</span>(original-&gt;left_child, target-&gt;left_child);<br>        <span class="hljs-built_in">copyBinaryTree</span>(original-&gt;right_child, target-&gt;right_child);<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ElementType&gt;</span><br><span class="hljs-function"><span class="hljs-title">BinaryTree::BinaryTree</span><span class="hljs-params">(BinaryTree&lt;ElementType&gt;* another)</span> </span>{<br>    <span class="hljs-built_in">copyBinaryTree</span>(<span class="hljs-keyword">this</span>, another);<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="calculate-the-depth">Calculate the depth</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">BinaryTree::depth</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">depth</span>(<span class="hljs-keyword">this</span>);<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ElementType&gt;</span><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">BinaryTree::depth</span><span class="hljs-params">(<span class="hljs-type">const</span> BinaryTree&lt;ElementType&gt; *tree)</span> <span class="hljs-type">const</span> </span>{<br>    <span class="hljs-keyword">if</span>(!tree) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>&amp;&amp; m = <span class="hljs-built_in">depth</span>(tree-&gt;left_child), n = <span class="hljs-built_in">depth</span>(tree-&gt;right_child);<br>    <span class="hljs-keyword">return</span> (m &gt; n ? m + <span class="hljs-number">1</span> : n + <span class="hljs-number">1</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="calculate-the-number-of-nodes">Calculate the number ofnodes</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">BinaryTree::nodeCount</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">nodeCount</span>(<span class="hljs-keyword">this</span>);<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ElementType&gt;</span><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">BinaryTree::nodeCount</span><span class="hljs-params">(<span class="hljs-type">const</span> BinaryTree&lt;ElementType&gt; *tree)</span> <span class="hljs-type">const</span> </span>{<br>    <span class="hljs-keyword">if</span>(!tree) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">nodeCount</span>(tree-&gt;left_child)  +<br>           <span class="hljs-built_in">nodeCount</span>(tree-&gt;right_child) + <span class="hljs-number">1</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="calculate-the-number-of-leaves">Calculate the number ofleaves</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">BinaryTree::leafCount</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">leafCount</span>(<span class="hljs-keyword">this</span>);<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ElementType&gt;</span><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">BinaryTree::leafCount</span><span class="hljs-params">(<span class="hljs-type">const</span> BinaryTree&lt;ElementType&gt; *tree)</span> <span class="hljs-type">const</span> </span>{<br>    <span class="hljs-keyword">if</span>(!tree) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(!tree-&gt;left_child &amp;&amp; !tree-&gt;right_child) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">leafCount</span>(tree-&gt;left_child) +<br>           <span class="hljs-built_in">leafCount</span>(tree-&gt;right_child);<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="binary-search-trees">Binary Search Trees</h2><p>The property that makes a binary tree into a <strong><em>binarysearch tree</em></strong> is that for every node <span class="math inline">\(X\)</span>,</p><ul><li>the values of all the items in its left subtree <u>are smallerthan</u> the item in <span class="math inline">\(X\)</span>;</li><li>and the values of all the items in its right subtree <u>are largerthan</u> the item in <span class="math inline">\(X\)</span>.</li></ul><p><strong>Implementation</strong> (C++)</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BinarySearchTree</span> : <span class="hljs-keyword">public</span> BinaryTree&lt;ElementType&gt; {<br>    <span class="hljs-keyword">using</span> Node = BinarySearchTree&lt;ElementType&gt;;<br>    <br>    <span class="hljs-function">Node* <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">const</span> ElementType&amp; key)</span> </span>{<br>        <span class="hljs-keyword">if</span>(data == key) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">if</span>(key &lt; data) <span class="hljs-keyword">return</span> <span class="hljs-built_in">search</span>(left_child, key);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">search</span>(right_child, key);<br>    }<br><br>    <span class="hljs-function">Node* <span class="hljs-title">search</span><span class="hljs-params">(Node* node, <span class="hljs-type">const</span> ElementType&amp; key)</span> </span>{<br>        <span class="hljs-keyword">if</span>(!node || node-&gt;data == key) <span class="hljs-keyword">return</span> node;<br>        <span class="hljs-keyword">if</span>(key &lt; node-&gt;data) <span class="hljs-keyword">return</span> <span class="hljs-built_in">search</span>(node-&gt;left_child, key);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">search</span>(node-&gt;right_child, key);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><img class="post-gallery-images" oncontextmenu="return false;" id="img-sequential_search" src="/img/post_gallery/14e0db42d09363a6774504c54ea40fcb/sequential_search.svg"></p><h4 id="eight_pointed_black_star-treaps"><span class="github-emoji"><span>✴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2734.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>Treaps</h4><h3 id="avl-trees">AVL Trees</h3><blockquote><p>An AVL (Adelson-Velskii and Landis) tree is a binary search tree witha <strong><em>balance condition</em></strong>.</p></blockquote><p>An <strong><em>AVL tree</em></strong> is identical to a binary searchtree, except that for every node in the tree, the <a href="#anchor-tree-props-height">height</a> of the left and rightsubtrees <span class="math inline">\(\mathrm{H}_L,\,\mathrm{H}_R\)</span> can differ byat most 1, i.e. <span class="math inline">\(\left|\mathrm{H}_L -\mathrm{H}_R\right|\leq1\)</span>.</p><p><strong>Adjustments for unbalanced AVL trees</strong></p><p><img class="post-gallery-images" oncontextmenu="return false;" id="img-rotations_of_avl_trees" src="/img/post_gallery/14e0db42d09363a6774504c54ea40fcb/rotations_of_avl_trees.svg"></p><h4 id="eight_pointed_black_star-red-black-trees"><span class="github-emoji"><span>✴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2734.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>Red-Black Trees</h4><blockquote><p>Red–black trees are isomorphic to 2-3 trees, meaning that they areequivalent data structures.</p></blockquote><p>To understand red-black trees, hence, we should first know what 2-3trees are:</p><p><img class="post-gallery-images" oncontextmenu="return false;" id="img-2-3-4_tree_illustration" src="/img/post_gallery/14e0db42d09363a6774504c54ea40fcb/2-3-4_tree_illustration.svg"></p><p>By artificially making the right key in the 3-nodes of the 2-3 treepoint to the left key and setting the color of the left key to red, weget a transformed 2-3 tree; then we just need to make the red node theleft child of the black node, and we get a red-black tree.</p><table class="md-centering-table table markdown-body" style="overflow: auto;"><tbody><tr style="border: none; text-align: center;"><td colspan="2" style="border: none; text-align: center;"><img class="post-gallery-images" oncontextmenu="return false;" id="img-2-3-4_tree" src="/img/post_gallery/14e0db42d09363a6774504c54ea40fcb/2-3-4_tree.svg"></td></tr><tr style="border: none; text-align: center;"><td style="border: none; text-align: center;"><img class="post-gallery-images" oncontextmenu="return false;" id="img-transformed_2-3_tree" src="/img/post_gallery/14e0db42d09363a6774504c54ea40fcb/transformed_2-3_tree.svg"></td><td style="border: none; text-align: center;"><img class="post-gallery-images" oncontextmenu="return false;" id="img-red-black_tree" src="/img/post_gallery/14e0db42d09363a6774504c54ea40fcb/red-black_tree.svg"></td></tr></tbody></table><h3 id="splay-trees">Splay Trees</h3><blockquote><p>The basic idea of the splay tree is that after a node is accessed, itis pushed to the root by a series of AVL tree rotations.</p></blockquote><p>Splay tree is another kind of binary search tree, with the propertythat the most recently searched or added content will be moved to theroot of the tree, so that when the same content is searched for nexttime, the speed can be improved, because the tree search starts from theroot, and the closer to the root, the faster it will be found.</p><p>The act of moving the most recently searched item to the root iscalled <strong><em>splay</em></strong>. It is important to note thatafter splaying, the tree may not necessarily be a balanced tree, but maybecome a skewed tree at worst.</p><h4 id="eight_pointed_black_star-top-down-splay-trees"><span class="github-emoji"><span>✴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2734.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>Top-Down Splay Trees</h4><h2 id="suffix-trees">Suffix Trees</h2><h2 id="eight_pointed_black_star-k-d-trees"><span class="github-emoji"><span>✴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2734.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><em>k</em>-d Trees</h2><h2 id="eight_pointed_black_star-pairing-heaps"><span class="github-emoji"><span>✴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2734.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>Pairing Heaps</h2><h1 id="heaps">Heaps</h1><h1 id="sorting">Sorting</h1><h1 id="hashing">Hashing</h1><p><strong><em>Hash Table</em></strong> is a data structure that mapskeys into their location of storage where the mapping is called a<strong><em>hash function</em></strong> <span class="math inline">\(\mathrm{Location}=\mathrm{Hash}\left(key\right)\)</span>.</p><p><strong>Terminologies</strong>:</p><ul><li><strong><em>Collision</em></strong>: two keys hash to the samevalue, i.e. <span class="math inline">\({key}_1\neq{key}_2\)</span> but<span class="math inline">\(\mathrm{Hash}\left({key}_1\right)=\mathrm{Hash}\left({key}_2\right)\)</span>;</li><li>Those colliding keys are called<strong><em>synonyms</em></strong>.</li></ul><h2 id="hash-function">Hash Function</h2><p>Principles of designing a "good" hash function:</p><ol type="1"><li>As simple as possible to increase the speed of processing ofmapping;</li><li>Addresses should be distributed as evenly as possible to minimizewasted space.</li></ol><p>Several hash functions:</p><ul><li><p><strong><em>Division Modulo Method</em></strong></p><p><span class="math display">\[\mathrm{Hash}\left(key\right)=key\;\mathrm{mod}\;p\]</span></p><p>The hash function divides the value <span class="math inline">\(key\)</span> by <span class="math inline">\(p\)</span> and then uses the remainder obtained.It is best suited that <span class="math inline">\(p\)</span> is <u>lessthan or equal to the size of the hash table</u> and is a <u>primenumber</u> as that can make sure the keys are more uniformlydistributed. The hash function is dependent upon the remainder of adivision.</p></li><li><p><strong><em>Mid Square Method</em></strong></p></li><li><p><strong><em>Folding Method</em></strong></p></li></ul><h2 id="methods-to-solve-collisions">Methods to solve collisions</h2><h3 id="open-addressing">Open Addressing</h3><p><strong>Basic Idea</strong>: If there exists collision, try the<strong>next</strong> alternative cells until an empty cell isfound.</p><h4 id="linear-probing">Linear Probing</h4><p><strong>Collision Function</strong>: <span class="math inline">\(f\left(i\right)=i\)</span></p><h4 id="quadratic-probing">Quadratic Probing</h4><p><strong>Collision Function</strong>: <span class="math inline">\(f\left(i\right)=\left(-1\right)^{i-1}i^2\)</span></p><h3 id="separate-chaining">Separate Chaining</h3><h1 id="the-disjoint-sets-class">The Disjoint Sets Class</h1><p>The <strong><em>equivalence class</em></strong> of an element <span class="math inline">\(a\in{S}\)</span> is the subset of <span class="math inline">\(S\)</span> that contains all the elements that arerelated to <span class="math inline">\(a\)</span>.</p><ul><li>An <strong><em>equivalence relation</em></strong> is a <a href="../Note_Of_Discrete_Mathematics/#relations">relation</a> <span class="math inline">\(R\)</span> that satisﬁes three properties:reflexive, symmetric, transitive, denoted by <span class="math inline">\(\sim\)</span>.</li><li>To decide if <span class="math inline">\(a\sim b\)</span>, we needonly to check whether <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are in the same equivalence class.</li></ul><p><img class="post-gallery-images" oncontextmenu="return false;" id="img-disjoint_sets" src="/img/post_gallery/14e0db42d09363a6774504c54ea40fcb/disjoint_sets.svg"></p><p><strong>Implementation</strong> (C++)</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span> <span class="hljs-comment">// import std::iota since C++11</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DisjointSetUnion</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">DisjointSetUnion</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">        : parents(size) {</span><br>        <span class="hljs-comment">// Fill the vector with consecutive numbers</span><br>        <span class="hljs-comment">// i.e. {0, 1, 2, ...}</span><br>        std::<span class="hljs-built_in">iota</span>(parents.<span class="hljs-built_in">begin</span>(), parents.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">size_t</span> node)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>{<br>        <span class="hljs-comment">// Only the root node would point to itself</span><br>        <span class="hljs-keyword">return</span> parents[node] == node ? node<br>        <span class="hljs-comment">// Compress the path to accelerate the query</span><br>                <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> OPTIMIZATION_ENABLED</span><br>                : parents[node] = <span class="hljs-built_in">find</span>(parents[node]);<br>                <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        <span class="hljs-comment">// If ignore the compression, the branch can</span><br>        <span class="hljs-comment">// be written as find(parents[node])</span><br>                : <span class="hljs-built_in">find</span>(parents[node]);<br>                <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionSets</span><span class="hljs-params">(<span class="hljs-type">size_t</span> node1, <span class="hljs-type">size_t</span> node2)</span> <span class="hljs-keyword">noexcept</span> </span>{<br>        <span class="hljs-comment">// To union two sets, we can simply make the root of one node</span><br>        <span class="hljs-comment">// point to another's root</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> OPTIMIZATION_ENABLED</span><br>        parents[<span class="hljs-built_in">find</span>(node1)] = <span class="hljs-built_in">find</span>(node2);<br>        <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        <span class="hljs-comment">// Attach the smaller tree to the root of the larger tree</span><br>        <span class="hljs-comment">// aka Union by rank</span><br>        node1 = <span class="hljs-built_in">find</span>(node1), node2 = <span class="hljs-built_in">find</span>(node2);<br>        <span class="hljs-keyword">if</span>(node1 == node2) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(size[node1] &lt; size[node2]) std::<span class="hljs-built_in">swap</span>(node1, node2);<br>        parents[node2] = node1;<br>        size[node1] += size[node2];<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    }<br><br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">size_t</span>&gt; parents;<br>} DSU;<br></code></pre></td></tr></tbody></table></figure><h1 id="graph-algorithms">Graph Algorithms</h1><p>A <strong><em>graph</em></strong> <span class="math inline">\(G=\left(V,\,E\right)\)</span> consists of anon-empty set of <strong><em>vertices</em></strong> <span class="math inline">\(V\)</span>, and a set of<strong><em>edges</em></strong> <span class="math inline">\(E\)</span>.Each edge is a pair <span class="math inline">\(\left(v,\,w\right)\)</span>, where <span class="math inline">\(v,\,w\in{V}\)</span>.</p><ul><li>If the pair is ordered, then the graph is<strong><em>directed</em></strong> (also referred to as<strong><em>digraphs</em></strong>).</li><li>Sometimes an edge has a third component, known as either a<strong><em>weight</em></strong> or a<strong><em>cost</em></strong>.</li></ul><p><strong><em>Path</em></strong>: a sequence of vertices <span class="math inline">\(v_1,\,v_2,\,\cdots,\,v_N\)</span> such that <span class="math inline">\(\left(v_i,\,v_{i+1}\right)\in E\)</span> for <span class="math inline">\(1\leq i\lt N\)</span></p><ul><li><strong><em>Length</em></strong>: the number of edges on the path,which is equal to <span class="math inline">\(N−1\)</span>.</li><li><strong><em>Loop</em></strong> : an edge <span class="math inline">\(\left(v,\,v\right)\)</span> from a vertex toitself.</li></ul><h2 id="representation">Representation</h2><h3 id="adjacency-matrix">Adjacency Matrix</h3><table><thead><tr class="header"><th style="text-align: center;">Undirected Graph</th><th style="text-align: center;">Adjacency Matrix</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><img class="post-gallery-images" oncontextmenu="return false;" id="img-adjmat" src="/img/post_gallery/14e0db42d09363a6774504c54ea40fcb/adjmat.svg"></td><td style="text-align: center;"><span class="math inline">\(\begin{array}{c}\begin{array}{c}\\v_1\\v_2\\v_3\\v_4\\v_5\\\end{array}\begin{array}{c}\begin{matrix}v_1&amp;v_2&amp;v_3&amp;v_4&amp;v_5\end{matrix}\\\begin{pmatrix}\,0\,&amp;\,1\,&amp;\,0\,&amp;\,1\,&amp;\,0\,\\1&amp;0&amp;1&amp;0&amp;1\\0&amp;1&amp;0&amp;1&amp;1\\1&amp;0&amp;1&amp;0&amp;0\\0&amp;1&amp;1&amp;0&amp;0\end{pmatrix}\end{array}\end{array}\)</span></td></tr></tbody></table><p><strong>Edges Without Weight</strong></p><ul><li>For each edge <span class="math inline">\((v_i,\,v_j)\)</span>, set<span class="math inline">\(A[v_i][v_j]\)</span> to <code>true</code>(i.e. <code>1</code>);</li><li>Otherwise the entry in the array is <code>false</code> (i.e.<code>0</code>).</li></ul><p><strong>Edges With Weight</strong></p><ul><li>For edges with weight associated, set <span class="math inline">\(A[v_i][v_j]\)</span> equal to the weight;</li><li>Use either a very large (i.e. <span class="math inline">\(+\infty\)</span>) or a very small weight (orsimply <span class="math inline">\(0\)</span>) as a sentinel to indicatenonexistent edges.</li></ul><p><strong>Features</strong></p><ol type="1"><li>The adjacency matrix of undirected graph is <em>symmetric</em>;</li><li>The degree of vertex <span class="math inline">\(v_i\)</span> is thesummation of the i-th row (column).</li></ol><table><thead><tr class="header"><th style="text-align: center;">Directed Graph</th><th style="text-align: center;">Adjacency Matrix</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><img class="post-gallery-images" oncontextmenu="return false;" id="img-adjmat_1" src="/img/post_gallery/14e0db42d09363a6774504c54ea40fcb/adjmat_1.svg"></td><td style="text-align: center;"><span class="math inline">\(\begin{array}{c}\begin{array}{c}\\v_1\\v_2\\v_3\\v_4\\\end{array}\begin{array}{c}\begin{matrix}v_1&amp;v_2&amp;v_3&amp;v_4\end{matrix}\\\begin{pmatrix}\,0\,&amp;\,1\,&amp;\,1\,&amp;\,0\,\\0&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;1\\1&amp;0&amp;0&amp;0\end{pmatrix}\end{array}\end{array}\)</span></td></tr></tbody></table><ul><li>The i-th row: arc ended with <span class="math inline">\(v_i\)</span> (outdegree edge)</li><li>The j-th column: arc started with <span class="math inline">\(v_j\)</span> (indegree edge)</li></ul><p><strong>Pros versus Cons</strong></p><ul><li><p>Pros</p><ol type="1"><li>Easy to check whether there exists an edge between twovertices;</li><li>Easy to calculate degrees of any vertex.</li></ol></li><li><p>Cons</p><ol type="1"><li>High Space Requirement <span class="math inline">\(\Theta\left(\left|V\right|^2\right)\)</span>(where <span class="math inline">\(\left|V\right|\)</span> stands forthe <a href="../Note_Of_Discrete_Mathematics/#cardinality">cardinality</a> ofthe set of vertices);</li><li>Only suitable when the graph is <strong><em>dense</em></strong>:<span class="math inline">\(\left|E\right|=\Theta\left(\left|V\right|^2\right)\)</span>(otherwise it is called <strong><em>sparse</em></strong> and most ofthese entries would contain zero.);</li><li>Hard to insert and remove vertices;</li><li>Time-costly to calculate how many edges in the graph <span class="math inline">\(O\left(\left|V\right|^2\right)\)</span>.</li></ol></li></ul><p><strong>Implementation</strong> (C++) </p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MVN 100 <span class="hljs-comment">// Maximum Vertices Number</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> VertexType, <span class="hljs-keyword">typename</span> ArcType&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AdjacencyMatrix</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">AdjacencyMatrix</span>() {<br>        std::cin &gt;&gt; vertices_count &gt;&gt; arcs_count;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; vertices_count; ++i)<br>            std::cin &gt;&gt; vertices[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; vertices_count; ++i)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; vertices_count; ++j)<br>                matrix[i][j] = INT_MAX; <span class="hljs-comment">// INT_MAX stands for infinity</span><br>        VertexType v1, v2;<br>        <span class="hljs-type">int</span> weight, i, j;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; arcs_count; ++k) {<br>            std::cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; weight;<br>            i = <span class="hljs-built_in">locate</span>(v1);<br>            j = <span class="hljs-built_in">locate</span>(v2);<br>            matrix[j][i] = matrix[i][j] = weight;<br>        }<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">locate</span><span class="hljs-params">(<span class="hljs-type">const</span> VertexType &amp;vertex)</span> <span class="hljs-type">const</span> </span>{<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; vertices_count; ++i)<br>            <span class="hljs-keyword">if</span>(vertex == vertices[i]) <span class="hljs-keyword">return</span> i;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br><br><span class="hljs-keyword">private</span>:<br>    VertexType vertices[MVN];<br>    ArcType matrix[MVN][MVN];<br>    <span class="hljs-type">int</span> vertices_count, arcs_count;<br>};<br></code></pre></td></tr></tbody></table></figure><p></p><h3 id="adjacency-list">Adjacency List</h3><table><thead><tr class="header"><th style="text-align: center;">Graph</th><th style="text-align: center;">Corresponding Adjacency List</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><img class="post-gallery-images" oncontextmenu="return false;" id="img-adjmat_adjlist" src="/img/post_gallery/14e0db42d09363a6774504c54ea40fcb/adjmat.svg"></td><td style="text-align: center;"><img class="post-gallery-images" oncontextmenu="return false;" id="img-adjlist" src="/img/post_gallery/14e0db42d09363a6774504c54ea40fcb/adjlist.svg"></td></tr></tbody></table><p><strong>Features</strong></p><ol type="1"><li>Adjacency lists are not unique;</li><li>Undirected graphs double the space usage (if it has <span class="math inline">\(e\)</span> edges, then it has to store <span class="math inline">\(2e\)</span> nodes) and are thus suitable forstoring sparse graphs;</li><li>Less space is needed: <span class="math inline">\(O\left(\left|E\right|+\left|V\right|\right)\)</span></li></ol><p><strong>Implementation</strong> (C++) </p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AdjacencyList</span>;<br><br><span class="hljs-comment">// Nodes in blue in the diagram above</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArcNode</span> {<br>    <span class="hljs-keyword">friend</span> AdjacencyList;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> vertex_index; <span class="hljs-comment">// adjacency vertex index</span><br>    <span class="hljs-type">int</span> weight; <span class="hljs-comment">// Arc weight</span><br>    ArcNode* next_arc; <span class="hljs-comment">// pointer to the next ArcNode</span><br>};<br><br><span class="hljs-comment">// Nodes in red in the diagram above</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> VertexType&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VertexNode</span> {<br>    <span class="hljs-keyword">friend</span> AdjacencyList;<br><span class="hljs-keyword">private</span>:<br>    VertexType data; <span class="hljs-comment">// store the data of the vertex</span><br>    ArcNode* first_arc; <span class="hljs-comment">// pointer to the first adjacency vertex</span><br>};<br><br><span class="hljs-comment">// Graph stored as adjacency list</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> VertexType&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AdjacencyList</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">AdjacencyList</span>() {<br>        std::cin &gt;&gt; vertices_count &gt;&gt; arc_count;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; vertices_count; ++i) {<br>            std::cin &gt;&gt; vertices[i].data;<br>            vertices[i].first_arc = <span class="hljs-literal">nullptr</span>;<br>        }<br>        VertexType v1, v2;<br>        <span class="hljs-type">int</span> i, j;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; arc_count; ++k) {<br>            std::cin &gt;&gt; v1 &gt;&gt; v2;<br>            i = <span class="hljs-built_in">locate</span>(v1);<br>            j = <span class="hljs-built_in">locate</span>(v2);<br>            ArcNode* p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArcNode</span>();<br>            p1-&gt;vertex_index = j;<br>            p1-&gt;next_arc = vertices[i].first_arc;<br>            vertices[i].first_arc = p1;<br><br>            ArcNode* p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArcNode</span>();<br>            p2-&gt;vertex_index = i;<br>            p2-&gt;next_arc = vertices[j].first_arc;<br>            vertices[j].first_arc = p2;<br>        }<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">locate</span><span class="hljs-params">(<span class="hljs-type">const</span> VertexType &amp;vertex)</span> <span class="hljs-type">const</span> </span>{<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; vertices_count; ++i)<br>            <span class="hljs-keyword">if</span>(vertex == vertices[i]) <span class="hljs-keyword">return</span> i;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br><br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;VertexNode&lt;VertexType&gt;&gt; vertices;<br>    <span class="hljs-type">int</span> vertices_count, arc_count;<br>};<br></code></pre></td></tr></tbody></table></figure><p></p><p><strong>Improvements</strong> </p><pre><code class=" mermaid">flowchart LR;adjlist(Adjacency List)---udg(Undirected Graph) &amp; dg(Directed Graph)udg --&gt;|Hard to calculate the degrees of vertices| ol(Orthogonal List)dg --&gt;|Each edge doubles the storage| am(Adjacency Multilist)</code></pre><p></p><h2 id="iteration">Iteration</h2><h3 id="depth-first-search">Depth First Search</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> VERTEX_NUM</span><br><br><span class="hljs-type">bool</span> visited[VERTEX_NUM] = {<span class="hljs-literal">false</span>};<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">const</span> AdjacencyMatrix &amp;graph, <span class="hljs-type">int</span> vertex_index)</span> </span>{<br>    <span class="hljs-comment">// Visit the vertex at the given index</span><br>    visited[vertex_index] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// Check the row of the given vertex</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; graph.<span class="hljs-built_in">vertexCount</span>(); ++i) {<br>        <span class="hljs-keyword">if</span>(!graph.<span class="hljs-built_in">at</span>(vertex_index, i) &amp;&amp; !visited[i])<br>            <span class="hljs-built_in">DFS</span>(graph, i);<br>        <span class="hljs-comment">// i is the adjacency vertex of the given vertex</span><br>        <span class="hljs-comment">// if i has not been visited yet, call DFS itself</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>Time complexity: <span class="math inline">\(O(n^2)\)</span> sincerows of every vertex would be iterated.</p><h3 id="breadth-first-search">Breadth First Search</h3><h2 id="applications-1">Applications</h2><h3 id="minimum-spanning-tree-mst">Minimum Spanning Tree (MST)</h3><blockquote><p>A <strong><em>spanning tree</em></strong> is a sub-graph of anundirected connected graph, which includes <u>all the vertices</u> (thereason why it is called spanning) of the graph with a minimum possiblenumber of edges. If a vertex is missed or the graph is not<u>acyclic</u>, then it is not a spanning tree.</p><p><strong><em>Minimum Spanning Tree</em></strong> (<em>MST</em>) of anundirected graph is a spanning tree with the lowest total cost among allthe spanning trees.</p></blockquote><p><strong>Properties</strong>:</p><p>Let <span class="math inline">\(N=\left(V,\,E\right)\)</span> denotea connected network (i.e. graph with weights), and <span class="math inline">\(U\)</span> denote a non-empty subset of the set ofvertices <span class="math inline">\(V\)</span>. There must exist a MSTthat includes the edge <span class="math inline">\(\left(u,\,v\right)\)</span> where <span class="math inline">\(u\in U,\;v\in V-U\)</span>.</p><p>In other words, during the process of constructing spanning trees,the vertices:</p><ul><li>Either in the vertex set <span class="math inline">\(U\)</span> thathas already been in the spanning tree (i.e. visited);</li><li>Or in the vertex set <span class="math inline">\(V-U\)</span> thathas not been in the spanning tree yet (i.e. not visited).</li></ul><table class="md-centering-table table markdown-body" style="overflow-x: auto; overflow-y: hidden;"><thead><tr><th></th><th style="text-align: center;">Prim's Algorithm</th><th style="text-align: center;">Kruskal's Algorithm</th></tr></thead><tbody><tr><td style="text-align: center;">Flow<br>Chart</td><td style="text-align: center;"><img class="post-gallery-images" oncontextmenu="return false;" id="img-Prim_algo_flow_chart" src="/img/post_gallery/14e0db42d09363a6774504c54ea40fcb/Prim_algo_flow_chart.svg"></td><td style="text-align: center;"><img class="post-gallery-images" oncontextmenu="return false;" id="img-Kruskal_algo_flow_chart" src="/img/post_gallery/14e0db42d09363a6774504c54ea40fcb/Kruskal_algo_flow_chart.svg"></td></tr><tr class="even" style="text-align: center;"><td>Key<br>Point</td><td>Select vertices</td><td>Select edges</td></tr><tr class="odd" style="text-align: center;"><td>Time<br>Complexity</td><td><math><mrow><mi>O</mi><mrow><mo fence="true" form="prefix">(</mo><msup><mrow><mo fence="true" form="prefix">|</mo><mi>V</mi><mo fence="true" form="postfix">|</mo></mrow><mn>2</mn></msup><mo fence="true" form="postfix">)</mo></mrow></mrow></math></td><td><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>O</mi><mrow><mo fence="true" form="prefix">(</mo><mrow><mo fence="true" form="prefix">|</mo><mi>E</mi><mo fence="true" form="postfix">|</mo></mrow><mrow><mspace width="0.1667em"></mspace><mi>log</mi><mo>⁡</mo><mspace width="0.1667em"></mspace></mrow><mrow><mo fence="true" form="prefix">|</mo><mi>E</mi><mo fence="true" form="postfix">|</mo></mrow><mo fence="true" form="postfix">)</mo></mrow></mrow></math></td></tr></tbody></table><h3 id="shortest-path-algorithms">Shortest-Path Algorithms</h3><pre><code class=" mermaid">flowchart LR;  spa(Shortest-Path) --- apsp(All-pairs shortest-path) --&gt; f(Floyd's)  spa --- spsp(Single pair shortest-path) --&gt; d(Dijkstra's)</code></pre><h4 id="dijkstras-algorithm">Dijkstra's Algorithm</h4><p>Dijkstra (/<em>ˈdikstrɑ</em>/ or /<em>ˈdɛikstrɑ</em>/)</p><ul><li><strong>Version 1</strong>: Brutal Force Implemented<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> Infinity = <span class="hljs-number">0x3f3f3f3f</span>; <span class="hljs-comment">// Represent ∞</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-type">index_t</span>; <span class="hljs-comment">// Index type</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> VertexType, <span class="hljs-keyword">typename</span> ArcType&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-type">const</span> AdjacencyMatrix&lt;VertexType, ArcType&gt; &amp;graph</span></span><br><span class="hljs-params"><span class="hljs-function">             <span class="hljs-type">const</span> <span class="hljs-type">index_t</span>&amp; source)</span> </span>{<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        Preparation for searching</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-type">unsigned</span> vertices = graph.<span class="hljs-built_in">vertexCount</span>();<br>    <span class="hljs-comment">// The array that holds the shortest distance from source to i</span><br>    <span class="hljs-type">int</span>* distances = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[vertices];<br>    <span class="hljs-comment">// Indicate whether the vertex i has been visited</span><br>    <span class="hljs-type">bool</span>* visited = <span class="hljs-keyword">new</span> <span class="hljs-type">bool</span>[vertices];<br>    <span class="hljs-comment">// Initialize all the elements in the array with default values</span><br>    <span class="hljs-built_in">memset</span>(distances, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(distances));<br>    <span class="hljs-built_in">memset</span>(visited, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(visited));<br>    <span class="hljs-comment">// Distance of source vertex from itself is always 0</span><br>    distances[source] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        Utility function</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// Utility function to find the minimum distance value</span><br>    <span class="hljs-keyword">auto</span> mimimumDistance = [&amp;distances, &amp;visited, vertices] -&gt; <span class="hljs-built_in">index_t</span> () {<br>        <span class="hljs-type">unsigned</span> min = Infinity;<br>        <span class="hljs-type">index_t</span> min_index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; vertices; ++i) {<br>            <span class="hljs-keyword">if</span>(!visited[i] &amp;&amp; distances[i] &lt; min) {<br>                min = distances[i];<br>                min_index = i;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> min_index;<br>    };<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        Core body of Dijkstra's Algorithm</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">index_t</span> i = <span class="hljs-number">0</span>; i &lt; vertices - <span class="hljs-number">1</span>; ++i) {<br>        <span class="hljs-comment">// Select the minimum distance vertex</span><br>        <span class="hljs-type">index_t</span> vertex_index = <span class="hljs-built_in">mimimumDistance</span>();<br>        <span class="hljs-comment">// Mark the vertex at given index as visited</span><br>        visited[vertex_index] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">// Update the distance value of the adjacent vertices</span><br>        <span class="hljs-comment">// of the selected vertex</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">index_t</span> j = <span class="hljs-number">0</span>; j &lt; vertices; ++j)<br>            <span class="hljs-keyword">if</span>(<br>                <span class="hljs-comment">// The vertex has not been visited yet</span><br>                !distances[j] &amp;&amp; <br>                <span class="hljs-comment">// There exists an arc from the selected to j</span><br>                <span class="hljs-comment">// since 0 represents a non-existent edge</span><br>                graph.<span class="hljs-built_in">at</span>(vertex_index, j) &amp;&amp;<br>                <span class="hljs-comment">// Infinity stands for a unreachable vertex</span><br>                distances[vertex_index] != Infinity &amp;&amp;<br>                <span class="hljs-comment">// The total cost from source to j through the</span><br>                <span class="hljs-comment">// selected vertex is smaller than the current</span><br>                <span class="hljs-comment">// cost of vertex at j</span><br>                distances[vertex_index] +<br>                graph[vertex_index][j] &lt; distances[j]<br>            )<br>                distances[j] = distances[vertex_index] +<br>                               graph[vertex_index][j];<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure></li></ul><h4 id="floyds-algorithm">Floyd's Algorithm</h4><h3 id="directed-acycline-graph">Directed Acycline Graph</h3><p>A <strong><em>directed acyclic graph</em></strong> (<em>DAG</em>) isoften used to describe the process of a project or system; a project canbe divided into a number of sub-projects, and once these sub-projectsare completed, the entire project can be completed.</p><p>According to whether vertices or arcs are used to represent a DAG, itcan be categorized into:</p><ul><li>AOV nets (<em>Activity On Vertex</em>)</li><li>AOE Nets (<em>Activity On Edge</em>)</li></ul><p>If there exists a directed path from <span class="math inline">\(i\)</span> to <span class="math inline">\(j\)</span>, then <span class="math inline">\(i\)</span> is the<strong><em>predecessor</em></strong> of <span class="math inline">\(j\)</span> and <span class="math inline">\(j\)</span> is the<strong><em>successor</em></strong> of <span class="math inline">\(i\)</span>. If <span class="math inline">\((i,\,j)\)</span> is a directed edge of the net,then <span class="math inline">\(i\)</span> is the <strong><em>immediatepredecessor</em></strong> of <span class="math inline">\(j\)</span> and<span class="math inline">\(j\)</span> is the <strong><em>immediatesuccessor</em></strong> of <span class="math inline">\(i\)</span>.</p><h4 id="topological-sorting">Topological Sorting</h4><p>Under the premise that there are no loops in the AOV net, we arrangeall the activities into a linear sequence such that if an arc <span class="math inline">\((i,j)\)</span> exists in the AOV network, then<span class="math inline">\(i\)</span> must come before <span class="math inline">\(j\)</span> in the sequence, and linear sequenceswith this property are known as topologically ordered sequences, and thecorresponding algorithm for topologically ordered sequences is known as<strong><em>topological sorting</em></strong>.</p><p><strong>Algorithm</strong></p><ol type="1"><li>Select a vertex without any predecessors and then print it out;</li><li>Remove the selected vertex and arcs that end with it;</li><li>Unless all vertices are printed or there is no vertex that do nothave a predecessor, repeat the process 1 and 2.</li></ol><p><span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <u>Note that the topological sorted sequences are notunique!</u></p><p><strong>Application of topological sorting</strong></p><p>Construct a topologically ordered sequence of its vertices for adirected graph, and if all the vertices in the net are in itstopologically ordered sequence, then the AOV network must be free ofloops.</p><h1 id="algorithm-design-techniques">Algorithm Design Techniques</h1><h1 id="amortized-analysis">Amortized Analysis</h1>]]></content>
    
    
    <summary type="html">针对《数据结构与算法》这门课的全英文学习笔记，对重要的、基础性的算法都以 C++ 的形式完成其实现，并辅以图表的多种形式对知识点作整理、归纳。</summary>
    
    
    
    <category term="学习笔记" scheme="https://devexzh.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机" scheme="https://devexzh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>离散数学笔记</title>
    <link href="https://devexzh.github.io/2023/Note_Of_Discrete_Mathematics/"/>
    <id>https://devexzh.github.io/2023/Note_Of_Discrete_Mathematics/</id>
    <published>2023-05-29T14:30:00.000Z</published>
    <updated>2023-07-24T06:30:31.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="logic-of-compound-statements">Logic of Compound Statements</h1><h2 id="concepts">Concepts</h2><table><thead><tr class="header"><th style="text-align: center;">Concept</th><th style="text-align: left;">Meaning</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>Statement</strong> orProposition</td><td style="text-align: left;">A sentence that is true or false but notboth.</td></tr><tr class="even"><td style="text-align: center;"><strong>Argument</strong></td><td style="text-align: left;">A sequence of statements aimed atdemonstrating the truth of an assertion</td></tr><tr class="odd"><td style="text-align: center;"><strong>Tautology</strong></td><td style="text-align: left;">Statement form that is always<strong><em>true</em></strong> regardless of the truth values ofindividual statements</td></tr><tr class="even"><td style="text-align: center;"><strong>Contradiction</strong></td><td style="text-align: left;">Statement form that is always<strong><em>false</em></strong> regardless of the truth values of theindividual statements</td></tr></tbody></table><p>If <span class="math inline">\(t\)</span> is a tautology and <span class="math inline">\(c\)</span> is a contradiction, then <span class="math inline">\(p\wedge t\equiv p\)</span> and <span class="math inline">\(p\wedge c\equiv c\)</span></p><h2 id="conditional">Conditional</h2><blockquote><p>If <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> are statement variables, theconditional of <span class="math inline">\(q\)</span> by <span class="math inline">\(p\)</span> is “If <span class="math inline">\(p\)</span> then <span class="math inline">\(q\)</span>” or “<span class="math inline">\(p\)</span> implies <span class="math inline">\(q\)</span>” and is denoted <span class="math inline">\(p\rightarrow q\)</span>.</p></blockquote><p>It is false when <span class="math inline">\(p\)</span> is true and<span class="math inline">\(q\)</span> is false; otherwise it istrue.</p><p>A conditional statement that is true by virtue of the fact that itshypothesis is false is often called <strong><em>vacuouslytrue</em></strong> or <strong><em>true by default</em></strong>.</p><h2 id="valid-argument-forms">Valid Argument Forms</h2><p>Argument is <strong><em>valid</em></strong> if the conclusion is truewhenever the premises are all true (A row of the truth table in whichall premises are true is called a <strong><em>criticalrow</em></strong>)</p><h1 id="number-theory-method-of-proof">Number Theory &amp; Method ofProof</h1><h2 id="unique-factorization-of-integers">Unique Factorization ofIntegers</h2><p>Given any integer <span class="math inline">\(n &gt; 1\)</span>,there exist a positive integer <span class="math inline">\(k\)</span>,distinct prime numbers <span class="math inline">\(p_1,\,p_2,\,\cdots,\,p_k\)</span>, and positiveintegers <span class="math inline">\(e_1,\,e_2,\,\cdots,\,e_k\)</span>such that <span class="math display">\[n=p_1^{e_1}p_2^{e_2}p_3^{e_3}\cdotsp_k^{e_k}\]</span> <span class="math inline">\(n\)</span> is called<strong>standard factored form</strong> of <span class="math inline">\(n\)</span> when <span class="math inline">\(p_1&lt;p_2&lt;\cdots&lt;p_k\)</span></p><h2 id="the-quotient-remainder-theorem">The Quotient-RemainderTheorem</h2><p>Given any integer <span class="math inline">\(n\)</span> and positiveinteger <span class="math inline">\(d\)</span>, there exist uniqueintegers <span class="math inline">\(q\)</span> and <span class="math inline">\(r\)</span> such that <span class="math inline">\(n= dq + r\)</span> and <span class="math inline">\(0 \leq r &lt;d\)</span></p><h2 id="euclidean-algorithm">Euclidean Algorithm</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{ <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b, a % b); }<br></code></pre></td></tr></tbody></table></figure><ul><li>If <span class="math inline">\(r\)</span> is a positive integer,then <span class="math inline">\(\gcd(r,\,0) = r\)</span></li><li>If <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are any non-zero integers, and if <span class="math inline">\(q\)</span> and <span class="math inline">\(r\)</span> are any integers such that <span class="math inline">\(a = bq + r\)</span>, then <span class="math inline">\(\gcd(a,\,b) = \gcd(b,\,r)\)</span></li></ul><h1 id="sequences-mathematical-induction-and-recursion">Sequences,Mathematical Induction, and Recursion</h1><h2 id="second-order-linear-homogeneous-recurrence-relation-with-constant-coefficients">Second-orderlinear homogeneous recurrence relation with constant coefficients</h2><p><span class="math inline">\(a_k = Aa_{k−1} + Ba_{k−2}\)</span> <span class="math inline">\(\forall\)</span> integers <span class="math inline">\(k\ge\)</span> some fixed integer, <span class="math inline">\(A,\,B\)</span> are fixed real numbers with <span class="math inline">\(B \neq 0\)</span></p><h3 id="characteristic-equation">Characteristic Equation</h3><p>Suppose a sequence <span class="math inline">\(a_0,\,a1,\,a_2,\,\cdots\)</span> satisfies arecurrence relation <span class="math inline">\(a_k = Aa_{k−1} +Ba_{k−2}\)</span> for some real numbers <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> with <span class="math inline">\(B \neq0\)</span> and all integers k ≥ 2. If the characteristic equation <span class="math inline">\(t^2 − At − B = 0\)</span> has</p><ul><li>Two distinct roots <span class="math inline">\(r\)</span> and <span class="math inline">\(s\)</span>, then <span class="math inline">\(a_n=Cr^n+Ds^n\)</span></li><li>A single (real) root <span class="math inline">\(r\)</span>, then<span class="math inline">\(a_n=Cr^n+Dnr^n\)</span></li></ul><p>where <span class="math inline">\(C\)</span> and <span class="math inline">\(D\)</span> are the numbers whose values aredetermined by the values <span class="math inline">\(a_0\)</span> and<span class="math inline">\(a_1\)</span></p><h1 id="set-theory">Set Theory</h1><h2 id="subset">Subset</h2><p><strong>Notation</strong> <span class="math inline">\(A=\left\{x\inS|P\left(x\right)\right\}\)</span></p><p><strong>Subset</strong>  <span class="math inline">\(A\subseteqB\Leftrightarrow\forall x,\,\mathrm{if}\;x\in A\;\mathrm{then}\;x\inB\)</span></p><ul><li><p><strong>Proper Subset</strong>: <span class="math inline">\(A\subseteq B\)</span> and there is at least oneelement in <span class="math inline">\(B\)</span> that is not in <span class="math inline">\(A\)</span>.</p></li><li><p>Method for proving one set is a subset of another</p><ol type="1"><li><strong>Suppose</strong> that <span class="math inline">\(x\)</span>is a particular but arbitrarily chosen element of <span class="math inline">\(X\)</span></li><li><strong>Show</strong> that <span class="math inline">\(x\)</span> isan element of <span class="math inline">\(Y\)</span></li></ol></li></ul><p><strong>Set Equality</strong> Given sets <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, <span class="math inline">\(A\)</span>equals <span class="math inline">\(B\)</span>, written <span class="math inline">\(A = B\)</span> if and only if every element of<span class="math inline">\(A\)</span> is in <span class="math inline">\(B\)</span> and every element of <span class="math inline">\(B\)</span> is in <span class="math inline">\(A\)</span>.</p><h2 id="operations-on-sets">Operations on Sets</h2><p>Let <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> be subsets of a universal set <span class="math inline">\(U\)</span>.</p><table><thead><tr class="header"><th style="text-align: center;">Operation</th><th style="text-align: left;">Definition</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Union</td><td style="text-align: left;"><span class="math inline">\(A\cupB=\left\{x\in U\,\vert\,x\in A\;\mathrm{or}\;x\inB\right\}\)</span></td></tr><tr class="even"><td style="text-align: center;">Intersection</td><td style="text-align: left;"><span class="math inline">\(A\capB=\left\{x\in U\,\vert\,x\in A\;\mathrm{and}\;x\inB\right\}\)</span></td></tr><tr class="odd"><td style="text-align: center;">Difference</td><td style="text-align: left;"><span class="math inline">\(A-B=\left\{x\in U\,\vert\,x\inA\;\mathrm{and}\;x\notin B\right\}\)</span></td></tr><tr class="even"><td style="text-align: center;">Complement</td><td style="text-align: left;"><span class="math inline">\(A^c=\left\{x\in U\,\vert\,x\notinA\right\}\)</span></td></tr><tr class="odd"><td style="text-align: center;">Cartesian Product</td><td style="text-align: left;"><span class="math inline">\(A_1\timesA_2\times\cdots\timesA_n=\left\{\left(a_1,\,a_2,\cdots,\,a_n\right)\vert a_i\inA_i\right\}\)</span></td></tr></tbody></table><h2 id="partitions-of-sets">Partitions of Sets</h2><p><strong>Disjoint</strong> Two sets are called disjoint if and only ifthey have no elements in common: <span class="math inline">\(A\capB=\emptyset\)</span>.</p><p><strong>Partition</strong> A finite or infinite collection ofnonempty sets <span class="math inline">\(\left\{A_1,A_2,\,A_3,\,\cdots\right\}\)</span> is a <strong>partition</strong> of aset <span class="math inline">\(A\)</span> if and only if:</p><ul><li><span class="math inline">\(A\)</span> is the union of all the <span class="math inline">\(A_i\)</span></li><li><span class="math inline">\(A_1, A_2,\,A_3,\,\cdots\)</span> aremutually disjoint</li></ul><h1 id="functions">Functions</h1><p>Categories of functions:</p><ul><li>One-to-one function: <span class="math inline">\(\forallx_1\;\mathrm{and}\;x_2\in X,\;\mathrm{if}\;F(x_1)=F(x_2),\;\mathrm{then}\;x_1=x_2\)</span></li><li>Onto function: <span class="math inline">\(\forall y\in Y,\;\existsx\in X\;\mathrm{such\,that}\;F(x)=y\)</span></li></ul><p>A <strong>one-to-one correspondence</strong> (or bijection) from aset <span class="math inline">\(X\)</span> to a set <span class="math inline">\(Y\)</span> is a function <span class="math inline">\(F:X\rightarrow Y\)</span> that is both one-to-oneand onto.</p><h3 id="cardinality">Cardinality</h3><p><em>Definition</em> The size of the set, denoted by <span class="math inline">\(|A|\)</span> for a set <span class="math inline">\(A\)</span>.</p><ul><li>Finite set is <span class="math inline">\(\emptyset\)</span> or aset <span class="math inline">\(\textcolor{orange}{\mathrm{can}}\)</span> be putinto one-to-one correspondence with <span class="math inline">\(\mathbf{Z}^+\)</span></li><li>Infinite set is a nonempty or a set <span class="math inline">\(\textcolor{orange}{\mathrm{cannot}}\)</span> beput into one-to-one correspondence with <span class="math inline">\(\mathbf{Z}^+\)</span></li></ul><p>Set <span class="math inline">\(A\)</span> has the same cardinalityas set <span class="math inline">\(B\)</span>, if and only if there is aone-to-one correspondence from <span class="math inline">\(A\)</span> to<span class="math inline">\(B\)</span>.</p><ul><li><p>A set is called <strong>countable</strong>, if and only if it isfinite or countably infinite.</p><ul><li>A set is called <strong>countably infinite</strong>, if and only ifit has the same cardinality as the set of <span class="math inline">\(\mathbf{Z}^+\)</span>.</li></ul></li><li><p>A set that is not countable is called uncountable.</p></li></ul><h1 id="relations">Relations</h1><h2 id="relation">Relation</h2><p>Partial Order Relation: denoted by <span class="math inline">\(\preceq\)</span></p><h3 id="reflexive">Reflexive</h3><p><strong>Explained in simpler way</strong>: Related to itself.</p><h3 id="antisymmetric">Antisymmetric</h3><p><strong>Definition</strong>: <span class="math inline">\(a\;\mathrm{R}\;b\,\wedge\,b\;\mathrm{R}\;a\rightarrowa=b\)</span></p><p><strong>Explained in simpler way</strong>: Never returns back.</p><h3 id="transitive">Transitive</h3><h3 id="hasse-diagrams">Hasse Diagrams</h3><p>Every vertex is always transitive ("goes up") and if all redundantdirections are eliminated, then the Hasse Diagram is obtained.</p><h3 id="partially-and-totally-ordered-sets">Partially and TotallyOrdered Sets</h3><p><strong>Definition</strong> Comparable: Suppose <span class="math inline">\(\preceq\)</span> is a partial order relation on aset <span class="math inline">\(A\)</span> and elements <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> of <span class="math inline">\(A\)</span> are <em>comparable</em> if and only ifeither <span class="math inline">\(a\preceq b\)</span> or <span class="math inline">\(b\preceq a\)</span>.</p><p>Every element is comparable in the set should be called totallyordered sets.</p><h3 id="maximal-minimal-elements">Maximal, Minimal Elements</h3><pre><code class=" mermaid">flowchart LR;a &amp; b --&gt; c --&gt; d --&gt; e</code></pre><p><span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are minimal but not least (since <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are not comparable)</p><p>Upper bound: <span class="math inline">\(\exists u\in S\subseteqA,\,\forall a\in A,\,a\preceq u\)</span></p><p>Lower bound:</p><h2 id="congruence-modulo">Congruence Modulo</h2><p>has exactly same remainder. e.g. <span class="math display">\[\begin{array}{c}5 \,\mathrm{mod}\, 2 = 1\\3\,\mathrm{mod}\, 2 = 1\end{array}\Rightarrow 5 \equiv 3\left(\mathrm{mod}\, 2\right)\]</span></p><ol type="1"><li><span class="math inline">\(n|(a-b)\)</span> (Usually employed inproving)</li><li><span class="math inline">\(a\equivb\,(\mathrm{mod}\,n)\)</span></li><li><span class="math inline">\(a\,\mathrm{mod}\,n=b\,\mathrm{mod}\,n\)</span></li></ol><h3 id="modular-arithmetic">Modular Arithmetic</h3><p>Let <span class="math inline">\(a,\,b,\,c,\,d\)</span> and <span class="math inline">\(n\)</span> be integers with <span class="math inline">\(n\gt1\)</span> and suppose <span class="math inline">\(a\equiv c\left(\mathrm{mod}\, n\right)\)</span>and <span class="math inline">\(a\equiv c\left(\mathrm{mod}\,n\right)\)</span></p><table><thead><tr class="header"><th style="text-align: center;">Operation</th><th style="text-align: center;">Expression</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Addition</td><td style="text-align: center;"><span class="math inline">\(\left(a+b\right)\equiv\left(c+d\right)\left(\mathrm{mod}\,n\right)\)</span></td></tr><tr class="even"><td style="text-align: center;">Subtraction</td><td style="text-align: center;"><span class="math inline">\(\left(a-b\right)\equiv\left(c-d\right)\left(\mathrm{mod}\,n\right)\)</span></td></tr><tr class="odd"><td style="text-align: center;">Multiplication</td><td style="text-align: center;"><span class="math inline">\(ab\equivcd\left(\mathrm{mod}\, n\right)\)</span></td></tr><tr class="even"><td style="text-align: center;">Power</td><td style="text-align: center;"><span class="math inline">\(a^m\equivc^m\left(\mathrm{mod}\, n\right)\)</span></td></tr><tr class="odd"><td style="text-align: center;"><strong>Modulo</strong></td><td style="text-align: center;"><span class="math inline">\(ab\equiv\left(\left(a\,\mathrm{mod}\,n\right)\left(b\,\mathrm{mod}\, n\right)\right)\left(\mathrm{mod}\,n\right)\)</span></td></tr><tr class="even"><td style="text-align: center;">Cancellation</td><td style="text-align: center;"><span class="math inline">\(ac\equivbc\left(\mathrm{mod}\, n\right)\Rightarrow a\equiv b\left(\mathrm{mod}\,n\right)\)</span><br><span class="math inline">\(\gcd\left(c,\,n\right)=1\)</span></td></tr></tbody></table><h2 id="bézouts-identity">Bézout's identity</h2><p>Let <span class="math inline">\(S=\left\{x\vert x=as+bt,\,x\inZ^+\right\}\)</span></p><p>(REVIEW: Euclid algorithm for calculating GCD <span class="math inline">\(d=\gcd\left(a,\,b\right)=\gcd\left(b,\,a\,\mathrm{mod}\,b\right),\quad a=bq+r\)</span>)</p><p>Proof: 1. <span class="math inline">\(S\)</span> is non-empty (bychoosing exact <span class="math inline">\(a\)</span>) 2. By WOP, <span class="math inline">\(S\)</span> has a least element <span class="math inline">\(c=as+bt\)</span> 3. Prove that <span class="math inline">\(c=d\)</span> via <span class="math inline">\(c\geqd\)</span> and <span class="math inline">\(d\geq c\)</span></p><ul><li><p><span class="math inline">\(c\geq d\)</span></p><ul><li><span class="math inline">\(d\vert a\)</span> and <span class="math inline">\(d\vert b\)</span> since <span class="math inline">\(d\)</span> is the GCD of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>.</li><li><span class="math inline">\(a=kd,\,b=ld\)</span></li><li><span class="math inline">\(c=as+bt=s\cdot kd+t\cdotld=d(ks+lt)\)</span></li></ul></li><li><p><span class="math inline">\(d\geq c\)</span></p><ul><li><p><span class="math inline">\(c\vert d\Rightarrow c\vert a\wedgec\vert b\)</span></p><ul><li><p>Quotinent-Remainder Theorem <span class="math inline">\(a=cq+r,\;0\leq r\lt c\)</span></p><ul><li><span class="math inline">\(r=a-cq=a-(as+bt)q=a(1-sq)+b(-tq)\)</span> is alsoa combination of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span></li><li><span class="math inline">\(c\)</span> is the least element, <span class="math inline">\(r\)</span> cannot be greater than <span class="math inline">\(c\)</span> so it contradicts with <span class="math inline">\(r\gt 0\)</span></li><li><span class="math inline">\(r=0\)</span> leads to <span class="math inline">\(a=cq\Rightarrow c\vert a\)</span></li></ul></li></ul></li></ul></li></ul><p>Application: 1. Express GCD in linear combination</p><h2 id="inverse-modulo">Inverse Modulo</h2><p>For all integers <span class="math inline">\(a\)</span> and <span class="math inline">\(n\)</span>, if <span class="math inline">\(\gcd\left(a,\,n\right)=1\)</span> (i.e. <span class="math inline">\(a\)</span> and <span class="math inline">\(n\)</span> are relatively prime) then there existsan integer <span class="math inline">\(a^{-1}\)</span> such that <span class="math inline">\(aa^{-1}\equiv 1\)</span></p><h2 id="rsa">RSA</h2><ol type="1"><li>Select two prime number <span class="math inline">\(p,\,q\)</span></li><li><span class="math inline">\(e\)</span> relatively prime to <span class="math inline">\((p-1)(q-1)\)</span></li><li>Encryption: Cipher text <span class="math inline">\(C=M^e\,\mathrm{mod}\, pq\)</span> where <span class="math inline">\(e,\,pq\)</span> are public keys</li><li>Decrpytion: Plain text <span class="math inline">\(M=C^d\,\mathrm{mod}\,pq\)</span> where <span class="math inline">\(d\)</span> is a positive inverse to <span class="math inline">\(e\)</span> modulo <span class="math inline">\((p-1)(q-1)\)</span></li></ol><h2 id="fermats-little-theorem">Fermat's Little Theorem</h2><blockquote><p>If <span class="math inline">\(p\)</span> is any prime number and<span class="math inline">\(a\)</span> is any integer such that <span class="math inline">\(p\not\vert a\)</span>, then <span class="math inline">\(a^{p-1}\equiv 1\left(\mathrm{mod}\,p\right)\)</span></p></blockquote><p>Proof:</p><p>The whole set of residues <span class="math inline">\(S=\left\{1,\,2,\,3,\,\cdots,\,p-1\right\}\)</span>,multiplied by <span class="math inline">\(a\)</span> then <span class="math inline">\(aS=\left\{a,\,2a,\,3a,\,\cdots,\,(p-1)a\right\}\)</span></p><p>Cardinality of <span class="math inline">\(S\)</span>, i.e. <span class="math inline">\(|S|=p-1=|aS|\)</span></p><p>Since any element <span class="math inline">\(x\in aS\)</span>, <span class="math inline">\(x\,\mathrm{mod}\,p\in S\)</span> as well.</p><p>Suppose <span class="math inline">\(ra=sa\left(\mathrm{mod}\,p\right)\quad 1\leq r\lts\leq (p-1)\)</span></p><p><span class="math inline">\(p\vert (s-r)a\Rightarrowp\vert(s-r)\)</span> by Euclid's Lemma, which implies <span class="math inline">\(s-r\geq p\)</span>, contradicting against thecondition</p><p>Thus <span class="math inline">\(ra\not\equivsa\left(\mathrm{mod}\,p\right)\)</span></p><p><span class="math inline">\(aS\)</span> to <span class="math inline">\(S\)</span> is one-to-one correspondance so <span class="math inline">\(a\cdot 2a\cdot 3a\cdots (p-1)a\equiv1\cdot2\cdot3\cdots(p-1)\;(\mathrm{mod}\,p)\)</span></p><p>and <span class="math inline">\(\gcd\left(p,\,(p-1)!\right)=1\)</span> wouldcancel the <span class="math inline">\((p-1)!\)</span></p><p>Hence, <span class="math inline">\(a^{p-1}\equiv1(\mathrm{mod}\,p)\)</span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;logic-of-compound-statements&quot;&gt;Logic of Compound Statements&lt;/h1&gt;
&lt;h2 id=&quot;concepts&quot;&gt;Concepts&lt;/h2&gt;
&lt;table&gt;

&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://devexzh.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数学" scheme="https://devexzh.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>NCRE 三级 网络技术 笔记</title>
    <link href="https://devexzh.github.io/2023/Note_Of_Computer_Network_Technology/"/>
    <id>https://devexzh.github.io/2023/Note_Of_Computer_Network_Technology/</id>
    <published>2023-05-29T05:30:00.000Z</published>
    <updated>2023-07-24T06:30:56.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络系统结构与设计的基本原则">网络系统结构与设计的基本原则</h1><ol type="1"><li><p>以太网速率分类</p><ul><li>传统以太网：传输速率为 10Mbit/s 的以太网；</li><li>快速以太网(<em>Fast Ethernet</em>), 即FE：传输速率为 100Mbit/s的以太网；</li><li>吉比特以太网简称为 GE ：传输速率为 10Gbit/s 的以太网简称为10GE。</li></ul></li><li><p>CSMA/CD 与 CSMA/CA</p><ul><li>CSMA/CD (<em>Carrier Sense Multiple Access/Collision Detection</em>,带有冲突检测的载波侦听多路存取)。是子网内部所采用的介质访问控制方法。</li><li>CSMA/CA(Carrier Sense Multiple Access with Collision Avoidance,带有冲突检测的载波监听的多路访问)。利用ACK信号来避免冲突的发生。</li></ul></li><li><p>构成广域网的典型网络类型和技术</p><p>有综合业务数字网 (ISDN), 公共电话交换网 (PSTN), 数字数据网 (DDN),X.25分组交换网, 帧中继 (<em>Frame Replay</em>, FR) 网, 异步传输模式(<em>Asynchronous Transfer Mode</em>, ATM) 网, 吉比特以太网 (<em>GigabitEthernet</em>, GE) 与 10Gbit/s 的光以太网 (<em>OpticalEthernet</em>)。</p></li><li><p>光纤分布式数据接口 (FDDI)</p><ul><li>FDDI 可以实现高速、高可靠性和大范围内局域网的连接。</li><li>FDDI 以光纤为传输介质, 传输速率为 100 Mbit/s, 可以用于 100 km范围内的局域网互联。</li><li>支持双环结构, 具备快速环自愈能力,</li></ul></li><li><p>城域网概念及宽带城域网</p><ul><li><p>城域网的基本概念</p><p>城域网是指网络运营商在城市内部提供的基于各种信息服务业务的所有网络,它以 TCP/IP 协议为基础, 以宽带光传输网络为开放平台,借助各种网络互联设备, 实现语音、数据、图像、多媒体视频、IP 电话、IP接入和各种增值服务业务与智能业务,并与广域网、广播电视网、电话交换网互联互通,形成城市本地内部的综合业务网。</p></li><li><p>宽带城域网的结构完整的宽带城域网主要包括网络平台、业务平台、管理平台3个平台与1个城市宽带出口。</p></li></ul></li><li><p>“数字会聚” “三网融合” 与接入技术</p><ol type="1"><li><p>“数字会聚”“三网融合”</p><ul><li>数字会聚：通信、计算机、广播电视等产业的会聚,出现经营业务相互融合现象, 进而促进这些产业的重组,同时开辟大量新的信息服务市场。</li><li>三网融合：计算机网络、电信通信网与广播电视网</li></ul></li><li><p>宽带接入技术特征</p><ul><li>宽带接入技术主要有：数字用户线 (xDSL) 技术、光纤同轴电缆混合网 (HFC)技术、光纤接入技术、局域网接入技术以及无线接入技术。</li><li>无线接入分为：无线局域网接入、无线城域网接入与无线 Ad hoc接入。</li><li>xDSL 技术根据上行 (用户到交换局) 和下行 (交换局到用户)的速率是否相同分为：速率对称型和速率非对称型两种。</li></ul></li><li><p>xDSL 技术</p><ul><li>非对称数字用户线 (<em>Asymmetric Digital Subscriber Line</em>,ADSL)。 上行速率在 64～640kbit/s, 下行速率在 500kbit/s～7Mbit/s。</li><li>高比特率数字用户线 (<em>High bit rate DSL</em>, HDSL)。</li><li>速率自适应数字用户线 (<em>Rate adaptive DSL</em>, RADSL)。</li><li>甚高比特率数字用户线 (<em>Very high bit rate DSL</em>, VDSL)。</li></ul><p>xDSL 技术的上行与下行速率等参数特征 |xDSL|上/下行速率 (距离 5.5km)|上/下行速率 (距离 3.6 km)|是否对称|线对数||:--:|:--:|:--:|:--:|:--:| |ADSL|64 kbit/s / 1.5 Mbit/s|640 kbit/s / 6Mbit/s|否|1| |HDSL|1.544 Mbit/s|1.544 Mbit/s|是|2| |ADSL|2.3 Mbit/s / 51Mbit/s|2.3 Mbit/s / 51 Mbit/s|否|2| |RADSL|64 kbit/s / 1.5 Mbit/s|640kbit/s / 6 Mbit/s|否|1|</p></li><li><p>光纤同轴电缆混合网 (HFC)</p><ul><li>HFC 是一个双向传输系统。</li><li>HFC 为有线电视用户提供了一种 Internet 接入方式。</li><li>HFC 光纤节点通过同轴电缆下引线为用户提供服务。</li><li>HFC接入方式采用共享式的传输方式，所有电缆调制解调器信号的发送、接收使用同一个上行和下行信道。</li><li>HFC 通过 Cable Modem 连接了用户计算机与有线电视同轴电缆。</li><li>Cable Modem利用<strong>频分复用</strong>的方法将双向信道分为：上行信道和下行信道</li><li>从传输方式上, Cable Modem 可以分为双向对称式传输和非对称式传输两类。<ul><li>对称式传输速率：2～4 Mbit/s，最高能达到 10 Mbit/s。</li><li>非对称式传输：下行速率为 30 Mbit/s，上行速率为 500 kbit/s～2.56Mbit/s。</li></ul></li></ul></li><li><p>光纤接入概念</p><ul><li>光纤到路边 (Fiber to the Curb，FTTC)</li><li>光纤至小区 (Fiber to the Zone，FTTZ)</li><li>光纤到大楼 (Fiber to the Building，FTTB)</li><li>光纤到办公室 (Fiber to the Office，FTTO)</li><li>光纤到户 (Fiber to the Home，FTTH)。</li></ul></li><li><p>无源光纤网(PON)</p><p>无源光纤网按 ITU 标准可分为两个部分：</p><ol type="1"><li>OC-3，155.520Mbit/s 的对称业务。</li><li>上行 OC-3，155.520Mbit/s; 下行 OC-12，622.080Mbit/s的不对称业务。</li></ol></li></ol><p><strong>OC-n: Optical Carrier level <span class="math inline">\(n\)</span>（光载体等级）。“OC”是 Optical Carrier的缩写，这是光纤传输的一种单位，它通常表示为 OC-n, 其中 <span class="math inline">\(n\)</span> 是多路传输技术中基本速率 51.84Mbit/s的倍数。</strong></p><ol start="7" type="1"><li><p>APON</p><p>APON 在 PON 的网络上，实现基于信元的 ATM传输，它允许接入网中的多个用户共享整个带宽。PON为多个用户提供廉价的共享传输媒介，ATM技术则为从低速到高速的各种多媒体业务提供可靠的接口。</p><p>APON优点：系统稳定、可靠；可以适应不同带宽、传输质量的需求；每个用户可占用独立的带宽，不会发生拥塞；接入距离可以达到20～30km。</p></li></ol></li></ol><h1 id="中小型网络系统总体规划与设计">中小型网络系统总体规划与设计</h1><ol type="1"><li><p>网络系统层次比</p><ul><li>不同层次之间的上联与下联带宽之比为1∶20。</li><li>同层次之间的上联与下联带宽之比一般为1∶1。</li></ul></li><li><p>路由器关键技术指标</p><ul><li><p>吞吐量</p><p>路由器的吞吐量是指它的包转发能力,涉及两个方面的内容：端口吞吐量与整机吞吐量。端口吞吐量是指路由器的某一个端口的包转发能力,而整机吞吐量是指路由器整机的包转发能力。路由器的吞吐量与路由器的端口数量和速率、包类型、包长度关系密切。</p></li><li><p>背板能力</p><p>背板是路由器输入端与输出端之间的物理通道,它决定了路由器的吞吐量。高性能路由器一般采用交换式结构,而传统的路由器采用的是共享背板的结构。</p></li><li><p>延时与延时抖动</p><p>从数据包的第一个字节进入路由器,到该帧的最后一个字节离开路由器所经历的时间就是延时。延时与包长度、链路传输速率有关,它标志着路由器转发包的处理时间。延时的变化量就是延时抖动。语音、视频业务对延时抖动要求较高。</p></li><li><p>丢包率</p><p>丢包率是指在持续的、稳定的负荷情况下,由于包转发能力的限制而造成的包丢失的概率。它常被用作路由器超负荷工作时的性能衡量指标。</p></li><li><p>突发处理能力</p><p>常以最小帧间隔发送数据包而不引起丢失的最大发送速率来衡量突发处理能力。</p></li><li><p>服务质量</p><p>路由器的服务质量主要表现在队列管理机制、端口硬件队列管理和支持 QoS协议上。</p></li><li><p>路由表容量</p><p>路由表是路由器用来决定包转发路径的主要依据。路由表容量是指路由器可以存储的最多的路由表项的数量。</p></li><li><p>可靠性与可用性。</p><p>典型的高端路由器的可靠性与可用性指标：</p><ol type="1"><li>无故障连续工作时间 (MTBF) 大于 10 万小时,且系统故障恢复时间小于30min。</li><li>系统具有自动保护切换功能, 主备用切换时间小于 50 ms。</li><li>SDH 与 ATM 接口自动保护切换功能, 切换时间小于 50 ms。</li><li>路由器系统内部不存在单故障点。</li><li>主处理器、主存储器、交换矩阵、电源、总线管理器与网络管理接口等主要部件需要有热拔插冗余备份,线卡要求有备份, 并提供远程测试诊断能力。</li></ol></li><li><p>网管能力。</p><p>路由器的网络管理能力表现在网络管理员可以通过网络管理程序和通用的网络管理协议SNMPv2等, 对网络资源进行集中管理与操作。</p></li></ul></li><li><p>交换机的主要技术指标</p><p>交换机的主要技术指标包括：背板带宽、全双工端口总带宽、交换方式、帧转发速率、延时、模块式或固定端口配置、支持VLAN 能力等。</p><ul><li><p>背板带宽</p><p>指交换机输入端与输出端之间的物理通道。背板带宽越宽,交换机的数据处理能力就越快, 数据包转发延迟就越小,性能也就越优越。</p></li><li><p>全双工端口带宽</p><p>全双工端口带宽的计算方法如下：</p><p>全双工端口带宽 = 端口数<span class="math inline">\(\times\)</span>端口速率<span class="math inline">\(\times 2\)</span></p><p>如果一种交换机具有 24个 10／100BASE-TX 端口与 1 个可扩展的 1000BASE-X端口, 那么在交换机满配置的情况下, 其全双工端口的总带宽为(24×100×2)+(1×1000×2)=6.8(Gbit/s)。交换机背板带宽的选择应该大于这个值,例如, 选取背板带宽为 8Gbit/s。</p><p>背板带宽／全双工端口的总带宽的比值越高,交换机就越趋近于高性能线速无阻塞交换机, 性能越好, 造价越高。</p></li><li><p>帧转发速率。</p><p>帧转发速率是指交换机每秒能够转发的帧的最大数量。延时是指从帧的第一个字节进入交换机,到该帧最后一个字节离开交换机输出端口的时间。</p></li><li><p>支持VLAN能力。</p><p>除了部分支持 Cisco 专用的组管理协议 (CGMP) 的交换机外,大部分交换机都支持 802.1Q 协议。VLAN 的划分可以基于端口、MAC地址或IP地址。</p></li><li><p>模块式交换机 (机箱式交换机) 的扩张能力。</p><p>可扩展性是模块式交换机的主要特点。</p></li></ul></li><li><p>网络服务器分类</p><p>按照网络服务器主机的硬件角度来看：</p><ul><li><p>基于复杂指令集 CISC 处理器的 Intel 结构的 PC 服务器</p><ul><li>优点：配置简单且通用性好, 第三方支持软件丰富, 系统维护方便,性价比高。</li><li>缺点：CPU 处理能力与系统 I/O 能力较差,不适宜作为高并发应用和大型数据库服务器。</li></ul></li><li><p>基于精简指令集 RISC 结构处理器的服务器；</p><p>与相应的 PC 服务器相比, CPU 处理能力提高了50%~75%。各种大型、中型计算机和超级服务器都采用RISC结构处理器,操作系统采用 UNIX, 所以通常将此类服务器称作 UNIX 服务器。</p></li></ul></li></ol><ul><li><p>小型机服务器。</p><p>小型机服务器一般用于大型企业级服务器或数据密集型的应用。</p></li></ul><ol start="5" type="1"><li><p>服务器技术描述</p><ul><li><p>热拔插技术。</p><p>热拔插技术可以实现用户在不断电的情况下进行故障硬盘、板卡等部件的更换(备用电源也可更换) , 所以使得系统应对突发事件能力大大提高。</p></li><li><p>集群(Cluster)技术。</p><p>集群技术大大提高了系统的数据处理能力。如果其中某台主机出现故障,该主机所运行的程序将立即转移到其他主机运行。不影响系统正常服务。</p></li><li><p>高性能存储与智能 I/O 技术。</p><p>磁盘容量和存取 I/O 速度是评价高性能存储技术的主要指标。</p><p>解决硬盘的存取速度问题：存储系统总线必须采用小型机系统接口(SCSI)标准,同时采用独立磁盘冗余阵列(RAID)技术, 将若干个硬盘驱动器组成一个整体,由阵列管理器管理；在提高磁盘容量的基础上, 通过改善并行读写能力,提高磁盘的存取速度和吞吐量；通过磁盘容错处理来解决系统的可靠性。</p></li><li><p>对称多处理(SMP)技术。</p><p>对称多处理(SMP)技术可以实现多 CPU 结构的服务器中的均衡负荷,从而提高系统效率。</p></li><li><p>应急管理端口(EMP)技术。</p></li><li><p>非一致内存访问(NUMA)技术。</p><p>非一致内存访问(NUMA)技术是在多达 64 个或更多CPU 的服务器之中,将集群技术与对称多处理技术结合起来应用, 以求获得较高的性价比。</p></li><li><p>服务处理器与 Intel 服务器控制(ISC)技术。</p><p>高性能服务器一般利用专用的服务处理器,对服务器系统的运行状况进行监控。</p></li></ul></li><li><p>停机时间 &amp; 系统可用性</p><ul><li><p>系统高可用性</p><p><span class="math display">\[\dfrac{MTBF}{MTBF+MTBR}\]</span> 其中,MTBF 为平均无故障时间；MTBR 为平均修复时间。 <span class="math display">\[MTBF+MTBR=365\times24\times60\]</span></p></li><li><p>如果系统高可用性达到 <span class="math inline">\(99.9\%\)</span>,那么每年的停机时间 <span class="math inline">\(\leq8.8h\)</span>；系统高可用性达到 <span class="math inline">\(99.99\%\)</span>, 每年的停机时间 <span class="math inline">\(\leq53 min\)</span>；系统高可用性达到 <span class="math inline">\(99.999\%\)</span>, 每年的停机时间 <span class="math inline">\(\leq5min\)</span>。</p></li></ul></li><li><p>B/S (浏览器／服务器) 模式应用服务器特点</p><ul><li>应用服务器将网络应用建立在 Web 服务的基础上,在客户与服务器之间采用浏览器／服务器模式进行软件系统的设计。</li><li>无须用户进行专门配置, 使用方便,性价比高。应用服务器产品提供商安装专用的应用软件、选择适合的硬件平台来满足具体应用需求。</li><li>采用三层体系结构。应用服务器使用中间件与通用数据库接口技术,客户计算机利用 Web 浏览器访问应用服务器,而应用服务器的后端连接的是数据库服务器。</li></ul></li><li><p>服务器集群接入核心层的两种方案</p><p>目前应用于核心层网络的技术标准主要是 GE/10GE,核心设备是高性能交换路由器, 连接核心路由器的是具有冗余链路的光纤。</p><p>核心层网络中存在着为整个网络服务的服务器集群的连接,从提高服务器集群可用性的角度, 连接方案有两种：</p><ul><li>采取链路冗余的办法直接连接两台核心路由器,其特点是直接利用了核心路由器的带宽, 但是占用的核心路由器端口较多,而高端路由器的端口价格很高, 所以设备成本会上升；</li><li>采取专用服务器交换机,在两台核心路由器之上再增加一台连接服务器集群的交换机,同时采用链路冗余的办法, 间接地连接到两台核心路由器,其优点是可以分担核心路由器的带宽, 缺点是会形成带宽瓶 颈,存在单点故障的潜在危险。</li></ul></li><li><p>网络需求分析内容</p><p>网络需求详细分析主要包括：网络总体需求分析、结构化布线需求分析、网络可用性与可靠性分析、网络安全性需求分析,以及分析网络工程造价估算几个方面。</p></li></ol><h1 id="ip-地址规划技术">IP 地址规划技术</h1><ol type="1"><li><p>IP 地址</p><p>IPv4 的地址长度为 32 bit, 每 8 位为一组，用点分十进制表示。</p><p>每 8 位为一组，每组最大取值为 <span class="math inline">\(28-1=255\)</span>，每组取值范围为 <span class="math inline">\([0,\,255]\)</span>。</p><table><thead><tr class="header"><th style="text-align: center;">地址类型</th><th style="text-align: center;">主机地址范围</th><th style="text-align: center;">可分配网络数</th><th style="text-align: center;">每个网络内可分配的最大主机数</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">A 类</td><td style="text-align: center;">1.0.0.0 ~ 127.255.255.255</td><td style="text-align: center;"><span class="math inline">\(2^7=128\)</span></td><td style="text-align: center;"><span class="math inline">\(2^{24}-2\)</span></td></tr></tbody></table></li></ol><h1 id="路由设计技术基础">路由设计技术基础</h1><h1 id="局域网技术基础及应用">局域网技术基础及应用</h1><h1 id="交换机及其配置">交换机及其配置</h1><h1 id="路由器配置及使用">路由器配置及使用</h1><h1 id="无线局域网设备安装与调试">无线局域网设备安装与调试</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络系统结构与设计的基本原则&quot;&gt;网络系统结构与设计的基本原则&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;以太网速率分类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传统以太网：传输速率为 10Mbit/s 的以太网；&lt;/li&gt;
&lt;li&gt;快速以太网(&lt;em&gt;Fast Eth</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://devexzh.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机" scheme="https://devexzh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="网络" scheme="https://devexzh.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>ACM/ICPC 竞赛笔记</title>
    <link href="https://devexzh.github.io/2023/Note_Of_ACM_ICPC_Contest/"/>
    <id>https://devexzh.github.io/2023/Note_Of_ACM_ICPC_Contest/</id>
    <published>2023-04-22T17:20:00.000Z</published>
    <updated>2023-07-24T06:33:20.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="acmicpc-概览">ACM/ICPC 概览</h1><h2 id="online-judge-oj">Online Judge (OJ)</h2><table><thead><tr class="header"><th style="text-align: left;">返回结果</th><th style="text-align: center;">含义</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">Accept (AC)</td><td style="text-align: center;">答案正确，被系统接受</td></tr><tr class="even"><td style="text-align: left;">Wrong Answer (WA)</td><td style="text-align: center;">答案错误</td></tr><tr class="odd"><td style="text-align: left;">Runtime Error (RE)</td><td style="text-align: center;">运行时错误</td></tr><tr class="even"><td style="text-align: left;">Compile Error (CE)</td><td style="text-align: center;">编译错误</td></tr><tr class="odd"><td style="text-align: left;">Presentation Error (PE)</td><td style="text-align: center;">答案格式错误</td></tr><tr class="even"><td style="text-align: left;">Time Limit Exceeded (TLE)</td><td style="text-align: center;">超时</td></tr><tr class="odd"><td style="text-align: left;">Memory Limit Exceeded (MLE)</td><td style="text-align: center;">超内存</td></tr><tr class="even"><td style="text-align: left;">Output Limit Exceeded (OLE)</td><td style="text-align: center;">超输出</td></tr><tr class="odd"><td style="text-align: left;">Restrict Function Call (RFC)</td><td style="text-align: center;">使用不允许的API</td></tr><tr class="even"><td style="text-align: left;">System Error</td><td style="text-align: center;">系统错误</td></tr><tr class="odd"><td style="text-align: left;">Queuing</td><td style="text-align: center;">排队等待系统测评</td></tr><tr class="even"><td style="text-align: left;">Judging</td><td style="text-align: center;">评测中</td></tr></tbody></table><h2 id="基本输入">基本输入</h2><ol type="1"><li><p>输入不说明有多少个 Input Block, 以 EOF 为结束标志。</p><ul><li><p>C 版本</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;a, &amp;b) != EOF) {<br>   <span class="hljs-comment">// 在这处理数据</span><br>}<br></code></pre></td></tr></tbody></table></figure></li><li><p>C++ 版本</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(cin &gt;&gt; a &gt;&gt; b) {<br>   <span class="hljs-comment">// 在这处理数据</span><br>} <br></code></pre></td></tr></tbody></table></figure></li></ul></li><li><p>输入说明了有多少个</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">while</span>(--n) {<br>   <span class="hljs-comment">// 在这处理数据</span><br>}<br></code></pre></td></tr></tbody></table></figure></li></ol><h2 id="确保代码效率">确保代码效率</h2><ol type="1"><li><p>除了循环控制变量以外，变量全部和标准 C一样先声明好再使用，能赋初值的赋初值初始化</p></li><li><p>数组不要反复开，用的时候直接用<code>memset(array_pointer, 0, sizeof(array_pointer));</code>清空数组</p></li><li><p>不混用 C 和 C++ 的输入输出流时，直接禁用运行时流同步</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br></code></pre></td></tr></tbody></table></figure></li><li><p>禁用流绑定</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br></code></pre></td></tr></tbody></table></figure></li></ol><h1 id="基本算法">基本算法</h1><h2 id="字符串">字符串</h2><h3 id="c-标准库函数">C 标准库函数</h3><p>头文件：<code>#include &lt;string.h&gt;</code> 或<code>#include &lt;cstring&gt;</code></p><h4 id="赋值">赋值</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 函数原型 strcpy(destination, str);</span><br><span class="hljs-type">char</span> str[<span class="hljs-number">40</span>];<br><span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">"C Programming Language"</span>);<br><span class="hljs-comment">// 把字符串赋给 str 字符数组</span><br></code></pre></td></tr></tbody></table></figure><p>将字符串复制到字符数组中。如果字符串的长度小于数组的长度，其余部分用<code>'\0'</code> 填补。返回处理完成的字符串。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 函数原型 strncpy(destination, str, length);</span><br><span class="hljs-type">char</span> str[<span class="hljs-number">20</span>]; <br><span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">"C Programming Language"</span>, <span class="hljs-number">13</span>);<br><span class="hljs-comment">// 把字符串至多前 n 个字符的子串赋给 str 字符数组</span><br></code></pre></td></tr></tbody></table></figure><p>将字符串中至多前 <em>n</em>个字符，复制到字符数组中。如果字符串的长度小于数组的长度，其余部分用<code>'\0'</code> 填补。返回处理完成的字符串。（有点类似于 Python 中对<code>str</code> 类型取 slice：<code>str = string[:n]</code>）</p><h4 id="长度">长度</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 函数原型 strlen(str);</span><br><span class="hljs-built_in">strlen</span>(<span class="hljs-string">"Hello"</span>); <span class="hljs-comment">// 结果是 5（不是 6）</span><br></code></pre></td></tr></tbody></table></figure><p>返回字符串的有效字符数（除空字符以外的的字符个数）。</p><p><span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>注意</strong></p><p><code>strlen()</code> 和 <code>sizeof()</code>是有区别的，<code>sizeof("Hello")</code> 的值是 6。</p><h3 id="c-标准库函数-1">C++ 标准库函数</h3><p>头文件：<code>#include &lt;string&gt;</code></p><h3 id="子串匹配">子串匹配</h3><h2 id="排序">排序</h2><h3 id="c-标准库函数-2">C++ 标准库函数</h3><p>头文件：<code>#include &lt;algorithm&gt;</code></p><p>排序函数：<code>std::sort(first, last, compare_function)</code></p><p>二分查找：</p><p><code>std::upper_bound</code></p><p><code>std::lower_bound</code></p><h2 id="高精度">高精度</h2><h3 id="高精度加法">高精度加法</h3><pre><code class=" mermaid">flowchart TB;input(输入字符串)--&gt;reverse(倒序字符串, 使得个位对齐方便计算)--&gt;add(逐位相加)--&gt;carry(逐位处理进位问题)--&gt;highest(根据最高位处理前导 0 问题)</code></pre><h3 id="高精度减法">高精度减法</h3><h3 id="高精度乘法">高精度乘法</h3><h3 id="高精度除法">高精度除法</h3><h1 id="杂谈">杂谈</h1><h2 id="无穷大的表示问题">无穷大的表示问题</h2><p>C++ 中整型 <code>int</code> 最大能表示的值是 <span class="math inline">\(2^{31} - 1\)</span> 换成十六进制就是<code>0x7fffffff</code>，除以 2 后即得到 <code>0x3fffffff</code>，也是<span class="math inline">\(10^9\)</span>这个量级的了，基本上不大可能会超过这个值。为了初始化的方便，也就是调用<code>memset</code> 这个函数的时候写起来方便，将 4 个字节全部置为<code>0x3f</code>，也就是用 <code>0x3f3f3f3f</code>这个值来近似地表示无穷大。</p><h2 id="位操作">位操作</h2><table><thead><tr class="header"><th style="text-align: center;">位操作</th><th style="text-align: center;">意义</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>(number &gt;&gt; x) &amp; 1</code></td><td style="text-align: center;">检查第 <span class="math inline">\(x\)</span> 位</td></tr><tr class="even"><td style="text-align: center;"><code>number \| (1 &lt;&lt; x)</code></td><td style="text-align: center;">设置第 <span class="math inline">\(x\)</span> 位</td></tr><tr class="odd"><td style="text-align: center;"><code>number ^ (1 &lt;&lt; x)</code></td><td style="text-align: center;">翻转第 <span class="math inline">\(x\)</span> 位</td></tr><tr class="even"><td style="text-align: center;"><code>number &amp; ~(1 &lt;&lt; x)</code></td><td style="text-align: center;">清除第 <span class="math inline">\(x\)</span> 位</td></tr></tbody></table><h3 id="brian-kernighan-算法">Brian Kernighan 算法</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> NumberLikeType, <br>         <span class="hljs-keyword">typename</span> enable_if&lt;is_integral&lt;NumberLikeType&gt;::value, <span class="hljs-type">int</span>&gt;::type = <span class="hljs-number">0</span>&gt;<br><span class="hljs-type">unsigned</span> <span class="hljs-built_in">setBitsCount</span>(NumberLikeType number) {<br>    <span class="hljs-type">unsigned</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(number) {<br>        number = number &amp; (number - <span class="hljs-number">1</span>);<br>        ++count;<br>    }<br>    <span class="hljs-keyword">return</span> count;<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;acmicpc-概览&quot;&gt;ACM/ICPC 概览&lt;/h1&gt;
&lt;h2 id=&quot;online-judge-oj&quot;&gt;Online Judge (OJ)&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th style=&quot;text-ali</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://devexzh.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机" scheme="https://devexzh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    <category term="程序设计" scheme="https://devexzh.github.io/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>概率论笔记</title>
    <link href="https://devexzh.github.io/2023/Note_Of_Probability_And_Statistics/"/>
    <id>https://devexzh.github.io/2023/Note_Of_Probability_And_Statistics/</id>
    <published>2023-04-16T07:20:00.000Z</published>
    <updated>2023-07-24T06:34:08.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="随机事件及其概率">随机事件及其概率</h1><hr><p><strong>考试要求</strong></p><ol type="1"><li>了解样本空间 (基本事件空间)的概念，理解随机事件的概念，掌握事件的关系及运算。</li><li>理解概率、条件概率的概念，掌握概率的基本性质，会计算古典型概率和几何型概率，掌握概率的加法公式、减法公式、乘法公式、全概率公式以及贝叶斯(Bayes) 公式。</li><li>理解事件独立性的概念，掌握用事件独立性进行概率计算；理解独立重复试验的概念，掌握计算有关事件概率的方法。</li></ol><hr><pre><code class=" mermaid">flowchart LR;  cf(条件概率公式)--&gt;|变形|mf(乘法公式)--&gt;|相加|tf(全概率公式)  bf(Bayes 公式)  tf--&gt;bf  cf--&gt;bf  mf--&gt;bf  click cf href "https://devexzh.github.io/2023/Note_Of_Probability_And_Statistics/#条件概率公式"  click mf href "https://devexzh.github.io/2023/Note_Of_Probability_And_Statistics/#乘法公式"  click tf href "https://devexzh.github.io/2023/Note_Of_Probability_And_Statistics/#全概率公式"</code></pre><h2 id="样本空间与随机事件">样本空间与随机事件</h2><details><summary>随机试验的基本概念</summary><table><thead><tr><th>名词</th><th>释义</th></tr></thead><tbody><tr><td>确定性现象</td><td>结果呈确定性的现象</td></tr><tr><td>随机现象</td><td>在个别试验中呈现不确定性，在大量重复实验中表现出统计规律性的现象</td></tr><tr><td>随机试验</td><td>对随机现象的实现或对其观察 (e.g. 投币观察向上的面)</td></tr></tbody></table><p><strong>随机试验的特点</strong></p><ol type="1"><li>相同条件下<strong>可重复</strong></li><li>试验<strong>结果明确可知</strong>，且一般不止一个</li><li>试验前<strong>不能确定</strong>哪个结果出现</li></ol></details><table><thead><tr class="header"><th style="text-align: center;">名词</th><th style="text-align: left;">释义</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">样本空间</td><td style="text-align: left;">将随机试验 <span class="math inline">\(E\)</span> 所有可能的结果组成的集合称为 <span class="math inline">\(E\)</span> 的样本空间 (Sample Space)</td></tr><tr class="even"><td style="text-align: center;">样本点</td><td style="text-align: left;">样本空间的元素即为样本点</td></tr><tr class="odd"><td style="text-align: center;">随机事件</td><td style="text-align: left;"><span class="math inline">\(E\)</span>的样本空间的子集为 <span class="math inline">\(E\)</span>的随机事件</td></tr></tbody></table><h3 id="事件的关系">事件的关系</h3><table><thead><tr class="header"><th style="text-align: center;">关系</th><th style="text-align: center;">记号</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(A\)</span>发生必定导致 <span class="math inline">\(B\)</span> 发生</td><td style="text-align: center;"><span class="math inline">\(A\subsetB\)</span></td></tr><tr class="even"><td style="text-align: center;">同一事件</td><td style="text-align: center;"><span class="math inline">\(A=B\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(A,\,B\)</span> 至少一个发生</td><td style="text-align: center;"><span class="math inline">\(A\cupB\)</span> 或 <span class="math inline">\(A+B\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(A,\,B\)</span> 都发生</td><td style="text-align: center;"><span class="math inline">\(A\capB\)</span> 或 <span class="math inline">\(AB\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(A\)</span>不发生</td><td style="text-align: center;"><span class="math inline">\(\bar{A}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(A\)</span>发生但 <span class="math inline">\(B\)</span> 不发生</td><td style="text-align: center;"><span class="math inline">\(A-B=A\bar{B}=A-AB\)</span></td></tr></tbody></table><h3 id="概率">概率</h3><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">频率</th><th style="text-align: center;">概率</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">定义</td><td style="text-align: center;">事件发生的频数与试验总数之间的比值</td><td style="text-align: center;">事件发生的可能性大小</td></tr></tbody></table><p>概率的基本性质：</p><ol type="1"><li>非负性：任一事件 <span class="math inline">\(A\)</span>，<span class="math inline">\(P(A)\geq 0\)</span></li><li>规范性：必然事件 <span class="math inline">\(S\RightarrowP(S)=1\)</span>（反之不对）</li><li>可列可加性：设 <span class="math inline">\(A_1,\,A_2,\,\cdots,\,A_n\)</span>两两互不相容，则必有 <span class="math inline">\(P\left(A_1\cupA_2\cup\cdots \cup A_n\right)=P(A_1)+P(A_2)+\cdots+P(A_n)\)</span></li></ol><p>重要性质：</p><ol type="1"><li><span class="math inline">\(P(\emptyset)=0\)</span>：不可能事件的概率为0，反之不对</li><li>若 <span class="math inline">\(A\subset B\)</span>，则 <span class="math inline">\(P(A)\leq P(B)\)</span>（当且仅当 <span class="math inline">\(A=B\)</span> 时等号成立）<ul><li>特别地，<span class="math inline">\(ABC\subset AB\)</span></li></ul></li><li><span class="math inline">\(P\left(A\cupB\right)=P(A)+P(B)-P(AB)\)</span><ul><li>推广：<span class="math inline">\(P\left(A\cup B\cupC\right)=P(A)+P(B)+P(C)-P(AB)-P(BC)-P(AC)+P(ABC)\)</span></li><li>容斥原理：所有奇数个事件积的概率减去所有偶数个事件积的概率</li></ul></li></ol><h2 id="条件概率公式">条件概率公式</h2><p>【例】将一枚硬币抛掷两次，观察其出现正反面的情况。设事件 <span class="math inline">\(A\)</span> 为 “至少有一次是 <span class="math inline">\(H\)</span>”，事件 <span class="math inline">\(B\)</span> 为 “两次掷出同一面”，求事件 <span class="math inline">\(A\)</span> 已经发生的条件下事件 <span class="math inline">\(B\)</span> 发生的概率。<br>【解】<span class="math inline">\(\begin{array}{l}S=\left\{HH,\,HT,\,TH,\,TT\right\}\\A=\left\{HH,\,HT,\,TH\right\}\\B=\left\{HH,\,TT\right\}\\AB=\left\{HH\right\}\end{array}\Rightarrow\begin{array}{l}P(A)=\frac34\\P(B)=\frac24\\P(AB)=\frac14\end{array}\)</span>，事件<span class="math inline">\(A\)</span> 发生且 <span class="math inline">\(B\)</span> 发生，只有 <span class="math inline">\(HH\)</span> 符合要求；而由于是 <span class="math inline">\(A\)</span> 已经发生，故事件 <span class="math inline">\(A\)</span> 已经发生的条件下事件 <span class="math inline">\(B\)</span> 发生的概率就是集合 <span class="math inline">\(A\)</span> 中 <span class="math inline">\(HH\)</span> 发生的概率，即 <span class="math inline">\(\frac13\)</span>。易发现 <span class="math inline">\(P(B|A)=\frac{P(BA)}{P(A)}\)</span>。</p><blockquote><p>设事件 <span class="math inline">\(A\)</span> 的概率 <span class="math inline">\(P(A)\gt 0\)</span>，则在事件 <span class="math inline">\(A\)</span> 发生的情况下，事件 <span class="math inline">\(B\)</span> 发生的条件概率 (<em>ConditionalProbability</em>) 记为 <span class="math inline">\(P(B|A)\)</span>，且<span class="math inline">\(\displaystyleP(B|A)=\frac{P(BA)}{P(A)}\)</span></p></blockquote><h2 id="乘法公式">乘法公式</h2><p>根据条件概率公式即可推得乘法公式 (<em>The Multiplication Rule forConditional Probabilities</em>)：<span class="math inline">\(P(AB)=P(A)\cdot P(B|A)\)</span></p><p>推广：<span class="math inline">\(P(ABCD)=P(A)\cdot P(B|A)\cdotP(C|AB)\cdot P(D|ABC)\)</span></p><h2 id="全概率公式">全概率公式</h2><p>样本空间的划分：设样本空间 <span class="math inline">\(S\)</span>，<span class="math inline">\(B_1,\,B_2,\,\cdots,\,B_n\)</span>是一组事件，若：</p><ol type="1"><li><span class="math inline">\(B_iB_j=\emptyset\quad(i\neqj,\;i,\,j\in[1,\,n])\)</span></li><li><span class="math inline">\(\displaystyle\bigcup^n_{i=1}B_i=S\)</span></li></ol><p>则 <span class="math inline">\(B_1,\,B_2,\,\cdots,\,B_n\)</span> 为<span class="math inline">\(S\)</span> 的一个<strong>划分</strong>(<em>partition</em>)。</p><blockquote><p>设 <span class="math inline">\(E\)</span> 的样本空间为 <span class="math inline">\(S\)</span>，<span class="math inline">\(A\)</span>是 <span class="math inline">\(E\)</span> 的一个事件，<span class="math inline">\(B_1,\,B_2,\,\cdots,\,B_n\)</span> 为 <span class="math inline">\(S\)</span> 的一个划分，且 <span class="math inline">\(P(B_i)\gt 0\quad(i=1,\,2,\,\cdots,\,n)\)</span>，则： <span class="math display">\[P(A)=P(B_1)P(A|B_1)+P(B_2)P(A|B_2)+\cdots+P(B_n)P(A|B_n)\]</span></p></blockquote><p>【证明】<span class="math inline">\(A=A\cap S=A\cap\left(B_1\cupB_2\cup\cdots\cup B_n\right)=AB_1\cup AB_2\cup\cdots\cupAB_n\)</span>，因为 <span class="math inline">\(B_i\)</span> 和 <span class="math inline">\(B_j\)</span> 互不相容，故 <span class="math inline">\(AB_i\)</span> 和 <span class="math inline">\(AB_j\)</span> 也互不相容（<span class="math inline">\(AB_i\subsetB_i\)</span>）。根据互斥事件的可列可加性，故 <span class="math inline">\(\newcommand\b[1]{\left(#1\right)}P\b{A}=P\b{AB_1\cupAB_2\cup\cdots\cup AB_n}=\)</span> <span class="math inline">\(\newcommand\b[1]{\left(#1\right)}P\b{AB_1}+P\b{AB_2}+\cdots+P\b{AB_n}\)</span><span class="math inline">\(=\newcommand\b[1]{\left(#1\right)}P\b{B_1}P\b{A|B_1}+P\b{B_2}P\b{A|B_2}+\cdots+P\b{B_n}P\b{A|B_n}\)</span>。</p><h2 id="bayes-公式"><span class="math inline">\(Bayes\)</span> 公式</h2><blockquote><p>设试验 <span class="math inline">\(E\)</span> 的样本空间 <span class="math inline">\(S\)</span>，<span class="math inline">\(A\)</span>是 <span class="math inline">\(E\)</span> 的一个事件，<span class="math inline">\(B_1,\,B_2,\,\cdots,\,B_n\)</span> 为 <span class="math inline">\(S\)</span> 的一个划分，且 <span class="math inline">\(P(A)\gt 0\)</span>，<span class="math inline">\(P(B_i)\gt 0\quad(i=1,\,2,\,\cdots,\,n)\)</span>，则： <span class="math display">\[P\left(B_i|A\right)=\frac{P\left(B_i\right)\cdotP\left(A|B_i\right)}{\displaystyle\sum^n_{j=1}P\left(B_j\right)\cdotP\left(A|B_j\right)}\]</span></p></blockquote><p>【推导】<span class="math inline">\(P\left(B_i|A\right)\xlongequal{条件概率公式}\frac{P\left(B_iA\right)}{P\left(A\right)}\xlongequal[全概率公式]{乘法公式}\frac{P\left(B_i\right)\cdotP\left(A|B_i\right)}{\sum^n_{j=1}P\left(B_j\right)\cdotP\left(A|B_j\right)}\)</span></p><h2 id="事件的关系-1">事件的关系</h2><h3 id="事件的独立性">事件的独立性</h3><p><strong>〔定义〕</strong> 设 <span class="math inline">\(A,\,B\)</span> 为两事件，若满足 <span class="math inline">\(P(AB)=P(A)\cdot P(B)\)</span>，则称 <span class="math inline">\(A,\,B\)</span> 相互独立。</p><hr><h1 id="随机变量及其分布">随机变量及其分布</h1><pre><code class=" mermaid">flowchart TB;title(随机变量及其分布) --- rv(随机变量) &amp; drv(离散型随机变量及其分布律) &amp; pf(随机变量的分布函数) &amp; crv(连续型随机变量及其概率密度) &amp; dist(随机变量的函数的分布)</code></pre><p>随机变量 (Random Variable, <em>r.v.</em>)：随机试验 <span class="math inline">\(E\)</span> 的样本空间 <span class="math inline">\(S={e},\,X=X(e)\)</span> （<span class="math inline">\(e\)</span> 为样本点）是定义在 <span class="math inline">\(S\)</span> 上的<strong>实值单值</strong>函数，则称<span class="math inline">\(X=X(e)\)</span> 是随机变量（每个样本点 <span class="math inline">\(e\)</span> 都对应了一个实数 <span class="math inline">\(X\)</span>）</p><h2 id="离散型随机变量及其分布">离散型随机变量及其分布</h2><p>离散型随机变量的取值是有限多个或者可列无穷多个的随机变量</p><table><thead><tr class="header"><th style="text-align: center;">分布</th><th style="text-align: center;">背景</th><th style="text-align: center;">分布律</th><th style="text-align: center;">记号</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0-1 Distribution</td><td style="text-align: center;">描述一次 Bernoulli 试验中发生的概率</td><td style="text-align: center;"><span class="math inline">\(P\left\{X=1\right\}=p\)</span><span class="math inline">\(P\left\{X=0\right\}=1-p\)</span></td><td style="text-align: center;"><span class="math inline">\(X\simB(1,\,p)\)</span></td></tr><tr class="even"><td style="text-align: center;">Binomial Distribution</td><td style="text-align: center;">描述 <span class="math inline">\(n\)</span> 重 Bernoulli 试验中发生 <span class="math inline">\(k\)</span> 次的概率</td><td style="text-align: center;"><span class="math inline">\(P\left\{X=k\right\}=C^k_np^k\left(1-p\right)^{n-k}\)</span></td><td style="text-align: center;"><span class="math inline">\(X\simB(n,\,p)\)</span></td></tr><tr class="odd"><td style="text-align: center;">Geometric Distribution</td><td style="text-align: center;">Bernoulli 试验第 <span class="math inline">\(k\)</span> 次才发生</td><td style="text-align: center;"><span class="math inline">\(P\left\{X=k\right\}=\left(1-p\right)^{k-1}p\)</span></td><td style="text-align: center;"><span class="math inline">\(X\simG(p)\)</span></td></tr><tr class="even"><td style="text-align: center;">Poisson Distribution</td><td style="text-align: center;">近似求解二项分布</td><td style="text-align: center;"><span class="math inline">\(P\left\{X=k\right\}=\frac{\lambda^k}{k!}e^{-\lambda}\)</span></td><td style="text-align: center;"><span class="math inline">\(X\simP(\lambda)\)</span></td></tr><tr class="odd"><td style="text-align: center;">Hypergeometric Distribution</td><td style="text-align: center;"><span class="math inline">\(N\)</span>件产品中有 <span class="math inline">\(M\)</span> 件不合格品，从中随机抽<span class="math inline">\(n\)</span> 件，其中有 <span class="math inline">\(k\)</span> 件不合格的概率</td><td style="text-align: center;"><span class="math inline">\(P\left\{X=k\right\}=\displaystyle\frac{C_M^kC_{N-M}^{n-k}}{C_N^n}\)</span></td><td style="text-align: center;"><span class="math inline">\(X\simH(N,\,M,\,n)\)</span></td></tr></tbody></table><ul><li>Poisson Limit Theorem: <span class="math inline">\(n\)</span>很大，<span class="math inline">\(p\)</span> 很小时，Poisson分布可用于近似求解二项分布，参数 <span class="math inline">\(\lambda=np\)</span></li></ul><h3 id="随机变量的分布函数">随机变量的分布函数</h3><p><strong>〔定义〕</strong> 设 <span class="math inline">\(X\)</span>是随机变量，<span class="math inline">\(x\)</span> 是任意实数，则 <span class="math display">\[F\left(x\right)=P\left\{X\leq x\right\},\quad-\infty\lt x\lt +\infty\]</span> 是 <span class="math inline">\(X\)</span> 的分布函数。</p><p><strong>性质</strong></p><ol type="1"><li><span class="math inline">\(0\leq F\left(x\right)\leq1\)</span></li><li>单调不减性：对于 <span class="math inline">\(\forall x_1\ltx_2\)</span>，有 <span class="math inline">\(F\left(x_1\right)\leqF\left(x_2\right)\)</span></li><li>规范性：<span class="math inline">\(F\left(-\infty\right)=0,\quadF\left(+\infty\right)=1\)</span></li><li>右连续性：<span class="math inline">\(\displaystyle\lim_{x\tox_0^+}F\left(x\right)=F\left(x_0\right)\)</span></li></ol><h2 id="连续型随机变量及其分布">连续型随机变量及其分布</h2><pre><code class=" mermaid">flowchart LR;  pdf(概率密度函数&lt;br/&gt;&lt;i&gt;p.d.f&lt;/i&gt;)--&gt;|变上限积分|cdf(分布函数&lt;br/&gt;&lt;i&gt;c.d.f&lt;/i&gt;)</code></pre><p><strong>〔定义〕</strong> 设随机变量 <span class="math inline">\(X\)</span> 的累积分布函数 (Cumulative DistributionFunction, <em>c.d.f</em>) 为 <span class="math inline">\(F(x)\)</span>，若存在连续、可积的函数 <span class="math inline">\(f(x)\)</span> 使得任意 <span class="math inline">\(x\)</span> 都有 <span class="math display">\[P\left\{X\leqx\right\}=F\left(x\right)=\int_{-\infty}^x{f\left(t\right)dt}\]</span>则 <span class="math inline">\(f(x)\)</span> 为随机变量 <span class="math inline">\(X\)</span> 的概率密度函数 (Probability DensityFunction, <em>p.d.f</em>)。</p><h3 id="分布">分布</h3><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">均匀分布</th><th style="text-align: center;">指数分布</th><th style="text-align: center;">正态分布</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">英文</td><td style="text-align: center;">Uniform Distribution</td><td style="text-align: center;">Exponential Distribution</td><td style="text-align: center;">Normal Distribution</td></tr><tr class="even"><td style="text-align: center;">概率密度函数 <span class="math inline">\(f\left(x\right)\)</span></td><td style="text-align: center;"><span class="math inline">\(\left\{\begin{array}{cl}\dfrac{1}{b-a}&amp;a\ltx\lt b\\0&amp;\mathrm{otherwise}\end{array}\right.\)</span></td><td style="text-align: center;"><span class="math inline">\(\left\{\begin{array}{cl}\lambda e^{-\lambdax}&amp;x\gt 0\\0&amp;x\leq 0\end{array}\right.\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{\left(x-\mu\right)^2}{2\sigma^2}}\)</span></td></tr><tr class="odd"><td style="text-align: center;">记号</td><td style="text-align: center;"><span class="math inline">\(X\simU(a,\,b)\)</span></td><td style="text-align: center;"><span class="math inline">\(X\simE(\lambda)\)</span></td><td style="text-align: center;"><span class="math inline">\(X\simN\left(\mu,\,\sigma^2\right)\)</span></td></tr></tbody></table><h4 id="指数分布的无记忆性">指数分布的无记忆性</h4><p>若 <span class="math inline">\(s\gt 0,\,t\gt 0\)</span>，则 <span class="math inline">\(P\left\{x\gt s+t\vert x\gt s\right\}=P\left\{x\gtt\right\}\)</span></p><h4 id="正态分布的性质">正态分布的性质</h4><p><span class="github-emoji"><span>📓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4d3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 当 <span class="math inline">\(\mu=0,\,\sigma=1\)</span>时，为标准正态分布 <span class="math inline">\(\varphi\left(x\right)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}\)</span></p><ol type="1"><li>在 <span class="math inline">\(x=\mu\)</span>时，正态分布的概率密度函数取到最大值：<span class="math inline">\(f\left(x\right)_{\mathrm{max}}=f\left(\mu\right)=\frac{1}{\sqrt{2\pi}\sigma}\)</span></li><li>标准正态分布函数的对称性：<span class="math inline">\(\Phi\left(x\right)+\Phi\left(-x\right)=1\)</span></li><li>在计算中常常可以通过凑正态分布计算 <span class="math inline">\(\displaystyle\int_{-\infty}^{+\infty}e^{-\frac{t^2}{2}}dt=\sqrt{\pi}\)</span></li></ol><hr><h1 id="多维随机变量及其分布">多维随机变量及其分布</h1><pre><code class=" mermaid">flowchart TB;title(多维随机变量及其分布) --- trv(二维随机变量) &amp; mdist(边缘分布) &amp; cdist(条件分布) &amp; indeptrv(相互独立的随机变量) &amp; trvdist(两个随机变量的函数的分布)</code></pre><h2 id="边缘分布">边缘分布</h2><p>边缘密度函数 <span class="math display">\[\begin{array}{}\displaystylef_X(x)=\int_{-\infty}^{+\infty}f(x,\,y)dy\\[12pt] \displaystylef_Y(y)=\int_{-\infty}^{+\infty}f(x,\,y)dx\end{array}\]</span></p><p>条件密度函数：联合密度函数比边缘密度函数 <span class="math display">\[f_{Y|X}\left(y|x\right)=\dfrac{f(x,\,y)}{f_X(x)}\]</span></p><p>二维随机变量 <span class="math inline">\((X,\,Y)\)</span>的联合概率密度函数 <span class="math inline">\(f(x,\,y)\)</span>、联合分布函数 <span class="math inline">\(F(x,\,y)\)</span>。则边缘分布函数为： <span class="math display">\[F_X(x)=F(x,\,+\infty)=\int_{-\infty}^{x}f_X(x)dx=\int_{-\infty}^{x}\int_{-\infty}^{+\infty}{f(x,\,y)dy}dx\]</span><span class="math display">\[F_Y(y)=F(+\infty,\,y)=\int_{-\infty}^{y}f_Y(y)dy=\int_{-\infty}^{y}\int_{-\infty}^{+\infty}{f(x,\,y)dx}dy\]</span></p><p>判断两个随机变量是否独立：两个边缘概率密度相乘是否等于联合概率密度</p><h2 id="二维随机变量的分布">二维随机变量的分布</h2><ol type="1"><li><p>分布函数法</p><p><span class="math inline">\(Z=g(X,\,Y)\)</span></p><p><span class="math display">\[F_z(z)=P\{Z\leq z\}=P\{g(X,\,Y)\leqz\}=\iint\limits_{g(x,\,Y)\leq z}{f(x,\,y)dxdy}=0\]</span></p></li><li><p><span class="math inline">\(U=\max\{X,\,Y\}\)</span> 与 <span class="math inline">\(V=\min\{X,\,Y\}\)</span> 的分布</p><ol type="1"><li><span class="math inline">\(F_U(x)\xlongequal{X,\,Y\,独立}F_X(x)F_Y(x)\xlongequal{X,\,Y\,同分布}F_X^2(x)\)</span></li><li><span class="math inline">\(F_V(x)\xlongequal{X,\,Y\,独立}{1-\left(1-F_X(x)\right)\left(1-F_Y(x)\right)}\xlongequal{X,\,Y\,同分布}1-\left(1-F_X(x)\right)^2\)</span></li></ol></li></ol><p>若 <span class="math inline">\(X\sim N(\mu_1,\,\sigma^2_1),\;Y\simN(\mu_2,\,\sigma^2_2)\)</span> 则 <span class="math display">\[aX+bY+c\simN(a\mu_1+b\mu_2+c,\,a^2\sigma^2_1+b^2\sigma^2_2)\]</span></p><p>若 <span class="math inline">\(X\sim E(\lambda_1),\;Y\simE(\lambda_2)\)</span> 则 <span class="math display">\[\min\left\{X,\,Y\right\}\simE(\lambda_1+\lambda_2)\]</span></p><h1 id="随机变量的数字特征">随机变量的数字特征</h1><h2 id="数学期望">数学期望</h2><p><span class="math display">\[E(X)=\int_{-\infty}^{+\infty}xf(x)dx\]</span></p><h3 id="数学期望的性质">数学期望的性质</h3><ol type="1"><li><span class="math inline">\(E\left(c\right)=c\)</span></li><li><span class="math inline">\(E\left(aX\right)=aE\left(X\right)\)</span></li><li><span class="math inline">\(E\left(X+Y\right)=E\left(X\right)+E\left(Y\right)\)</span></li><li>若 <span class="math inline">\(X,\,Y\)</span> 独立，则 <span class="math inline">\(E\left(XY\right)=E\left(X\right)E\left(Y\right)\)</span></li><li><span class="math inline">\(X\geq c\Rightarrow E\left(X\right)\geqc\)</span></li></ol><h2 id="方差">方差</h2><p><span class="math display">\[D(X)=E\left(X-EX\right)^2=E(X^2)-E^2(X)\]</span></p><h3 id="方差的性质">方差的性质</h3><ol type="1"><li><span class="math inline">\(D\left(c\right)=0\)</span></li><li><span class="math inline">\(D\left(aX\right)=a^2D\left(X\right)\)</span></li><li>若 <span class="math inline">\(X,\,Y\)</span> 独立，则 <span class="math inline">\(D\left(X\pmY\right)=D\left(X\right)+D\left(Y\right)\)</span></li></ol><h2 id="常见分布的期望与方差">常见分布的期望与方差</h2><table><thead><tr class="header"><th style="text-align: center;">分布</th><th style="text-align: center;">期望</th><th style="text-align: center;">方差</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Binomial Distribution <br>二项分布</td><td style="text-align: center;"><span class="math inline">\(np\)</span></td><td style="text-align: center;"><span class="math inline">\(np(1-p)\)</span></td></tr><tr class="even"><td style="text-align: center;">Poisson Distribution <br> 泊松分布</td><td style="text-align: center;"><span class="math inline">\(\lambda\)</span></td><td style="text-align: center;"><span class="math inline">\(\lambda\)</span></td></tr><tr class="odd"><td style="text-align: center;">Geometric Distribution <br>几何分布</td><td style="text-align: center;"><span class="math inline">\(\dfrac{1}{p}\)</span></td><td style="text-align: center;"><span class="math inline">\(\dfrac{1-p}{p^2}\)</span></td></tr><tr class="even"><td style="text-align: center;">Hypergeometric Distribution <br>超几何分布</td><td style="text-align: center;"><span class="math inline">\(n\cdot\dfrac{M}{N}\)</span></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">Uniform Distribution <br> 均匀分布</td><td style="text-align: center;"><span class="math inline">\(\dfrac{a+b}{2}\)</span></td><td style="text-align: center;"><span class="math inline">\(\dfrac{(b-a)^2}{12}\)</span></td></tr><tr class="even"><td style="text-align: center;">Exponential Distribution <br>指数分布</td><td style="text-align: center;"><span class="math inline">\(\dfrac{1}{\lambda}\)</span></td><td style="text-align: center;"><span class="math inline">\(\dfrac{1}{\lambda^2}\)</span></td></tr><tr class="odd"><td style="text-align: center;">Normal Distribution <br> 正态分布</td><td style="text-align: center;"><span class="math inline">\(\mu\)</span></td><td style="text-align: center;"><span class="math inline">\(\sigma^2\)</span></td></tr></tbody></table><h2 id="协方差">协方差</h2><p><span class="math display">\[\begin{align*}\mathrm{Cov}\left(X,\,Y\right)&amp;=E\left[\left(X-EX\right)\left(Y-EY\right)\right]\\\mathrm{Cov}\left(X,\,X\right)&amp;=E\left(X-EX\right)^2=DX\end{align*}\]</span></p><p>计算：<span class="math inline">\(\mathrm{Cov}\left(X,\,Y\right)=E(XY)-EX\cdotEY=\rho_{XY}\sqrt{DX}\sqrt{DY}\)</span></p><h3 id="协方差的性质">协方差的性质</h3><ol type="1"><li><span class="math inline">\(\mathrm{Cov}\left(X,\,c\right)=0\)</span></li><li><span class="math inline">\(\mathrm{Cov}\left(X,\,Y\right)=\mathrm{Cov}\left(Y,\,X\right)\)</span></li><li><span class="math inline">\(\mathrm{Cov}\left(aX,\,bY\right)=ab\,\mathrm{Cov}\left(X,\,Y\right)\)</span></li><li><span class="math inline">\(\mathrm{Cov}\left(X_1+X_2,\,Y\right)=\mathrm{Cov}\left(X_1,\,Y\right)+\mathrm{Cov}\left(X_2,\,Y\right)\)</span></li><li><span class="math inline">\(D(X,\,Y)=D(X)+D(Y)+2\,\mathrm{Cov}\left(X,\,Y\right)\)</span></li></ol><h2 id="相关系数">相关系数</h2><p><span class="math display">\[\rho_{XY}=\mathrm{Cov}\left(\dfrac{X-EX}{\sqrt{DX}},\,\dfrac{Y-EY}{\sqrt{DY}}\right)=\dfrac{\mathrm{Cov}\left(X,\,Y\right)}{\sqrt{DX}\sqrt{DY}}\]</span></p><p>相关系数反映了随机变量之间的线性关系</p><ol type="1"><li><p><span class="math inline">\(\rho_{XY}=0\)</span> 则 <span class="math inline">\(X,\,Y\)</span> 不相关</p><ul><li><span class="math inline">\(\mathrm{Cov}\left(X,\,Y\right)=0\)</span></li><li><span class="math inline">\(D(X\pm Y)=DX+DY\)</span></li><li><span class="math inline">\(E(XY)=EX\cdot EY\)</span></li></ul></li><li><p><span class="math inline">\(\left|\rho_{XY}\right|=1\)</span> 则<span class="math inline">\(P\left\{Y=aX+b,\,a\neq0\right\}=1\)</span></p><ul><li><span class="math inline">\(a\gt 0,\;\rho_{XY}=1\)</span></li><li><span class="math inline">\(a\lt 0,\;\rho_{XY}=-1\)</span></li></ul></li></ol><h1 id="大数定律与中心极限定理">大数定律与中心极限定理</h1><p><strong>依概率收敛</strong>  设 <span class="math inline">\(X_1,\,X_2,\,\cdots,\,X_n,\,\cdots\)</span>是相互独立的一列随机变量，<span class="math inline">\(X\)</span>是一个随机变量，若对任意正数 <span class="math inline">\(\varepsilon\)</span>，有 <span class="math inline">\(\displaystyle\lim_{n\to\infty}P\left(\left|X_n-X\right|\lt\varepsilon\right)=1\)</span>，则称<span class="math inline">\(X_1,\,X_2,\,\cdots,\,X_n,\,\cdots\)</span>依概率收敛于<span class="math inline">\(X\)</span>，通常记作 <span class="math inline">\(X_n\xrightarrow{P}X\)</span>。</p><p><span class="github-emoji"><span>📓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4d3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 人话：做的次数足够大的时候，<span class="math inline">\(X_n\)</span> 和 <span class="math inline">\(X\)</span> 无限接近</p><h2 id="大数定律-law-of-large-numbers">大数定律 Law of LargeNumbers</h2><p>本质：算术平均依概率收敛于统计平均 <span class="math inline">\(\frac{1}{n}\sum_{i=1}^{n}X_i\xrightarrow{P}E\left(\frac{1}{n}\sum_{i=1}^{n}X_i\right)\)</span></p><h2 id="中心极限定理-central-limit-theorem">中心极限定理 Central LimitTheorem</h2><p>本质：<span class="math inline">\(n\)</span>个独立同分布的随机变量之和近似服从正态分布。</p><p><strong>Chebyshev 不等式</strong> <span class="math display">\[P\left\{\left|X-E(X)\right|\geq\varepsilon\right\}\leq\frac{D(X)}{\varepsilon^2}\]</span></p><h1 id="估计">估计</h1><h2 id="常用统计量">常用统计量</h2><table><thead><tr class="header"><th style="text-align: center;">概念</th><th style="text-align: center;">表达式</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">样本均值</td><td style="text-align: center;"><span class="math inline">\(\displaystyle\bar{X}=\dfrac{1}{n}\sum_{i=1}^{n}X_i\)</span></td></tr><tr class="even"><td style="text-align: center;">样本方差</td><td style="text-align: center;"><span class="math inline">\(\displaystyleS^2=\dfrac{1}{n-1}\sum_{i=1}^{n}\left(X_i-\bar{X}\right)^2\)</span></td></tr><tr class="odd"><td style="text-align: center;">样本的 <span class="math inline">\(k\)</span> 阶原点矩</td><td style="text-align: center;"><span class="math inline">\(\displaystyleA_k=\dfrac{1}{n}\sum_{i=1}^{n}X_i^k\)</span></td></tr><tr class="even"><td style="text-align: center;">样本的 <span class="math inline">\(k\)</span> 阶中心矩</td><td style="text-align: center;"><span class="math inline">\(\displaystyleB_k=\dfrac{1}{n}\sum_{i=1}^{n}\left(X_i-\bar{X}\right)^k\)</span></td></tr></tbody></table><h3 id="样本均值与样本方差的性质">样本均值与样本方差的性质</h3><p>总体 <span class="math inline">\(X\)</span> 数字特征 <span class="math inline">\(E(X)=\mu,\;D(X)=\sigma^2\)</span>，若 <span class="math inline">\(X_1,\,X_2,\,\cdots,\,X_n\)</span> 是取自总体 <span class="math inline">\(X\)</span> 的一个样本，则</p><ol type="1"><li><span class="math inline">\(E(\bar{X})=E(X)=\mu,\;D(\bar{X})=\dfrac{D(X)}{n}=\dfrac{\sigma^2}{n}\)</span></li><li><span class="math inline">\(E(S^2)=D(X)=\sigma^2\)</span></li></ol><h2 id="三个抽样分布">三个抽样分布</h2><h3 id="chi2-分布"><span class="math inline">\(\chi^2\)</span> 分布</h3><blockquote><p>设总体 <span class="math inline">\(X\sim N(0,\,1)\)</span>，<span class="math inline">\(X_1,\,X_2,\,\cdots,\,X_n\)</span> 为样本，则统计量<span class="math display">\[\chi^2=X_1+X_2+\cdots+X_n\]</span>服从的分布成为 <span class="math inline">\(\chi^2\)</span> 分布，记为<span class="math inline">\(\chi^2\sim\chi^2(n)\)</span>，其中 <span class="math inline">\(n\)</span> 称为自由度</p></blockquote><table><thead><tr class="header"><th style="text-align: center;">期望</th><th style="text-align: center;">方差</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(n\)</span></td><td style="text-align: center;"><span class="math inline">\(2n\)</span></td></tr></tbody></table><h3 id="t-分布"><span class="math inline">\(t\)</span> 分布</h3><p>设 <span class="math inline">\(X\simN(0,\,1),\;Y\sim\chi^2(n)\)</span>，且 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 相互独立，则随机变量 <span class="math inline">\(T=\cfrac{X}{\sqrt{\cfrac{Y}{n}}}\simt(n)\)</span>，服从于自由度为 <span class="math inline">\(n\)</span> 的<span class="math inline">\(t\)</span> 分布。</p><h3 id="f-分布"><span class="math inline">\(F\)</span> 分布</h3><p>设 <span class="math inline">\(X\sim\chi^2(n_1),\,Y\sim\chi^2(n_2)\)</span>，且<span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 相互独立，则统计量 <span class="math inline">\(F=\cfrac{\cfrac{X}{n_1}}{\cfrac{Y}{n_2}}\)</span>服从 <span class="math inline">\(F(n_1,\,n_2)\)</span> 分布。</p><p>性质： 1. <span class="math inline">\(F\simF\left(n_1,\,n_2\right)\Rightarrow\dfrac{1}{F}\simF\left(n_2,\,n_1\right)\)</span> 2. <span class="math inline">\(T\simt(n)\Rightarrow T^2\sim F\left(1,\,n\right)\Rightarrow\dfrac{1}{T^2}\sim F\left(n,\,1\right)\)</span></p><h3 id="分位点">分位点</h3><h3 id="单正态总体下样本均值与样本方差的分布">单正态总体下样本均值与样本方差的分布</h3><h2 id="矩估计">矩估计</h2><p>矩估计 (<em>Moment Estimation</em>)</p><h2 id="最大似然估计">最大似然估计</h2><p>最大似然估计 (<em>Maximum Likelihood Estimation</em>,<strong>MLE</strong>)</p><ol type="1"><li><p>写出含参数的 MLE 函数 <span class="math inline">\(L(\theta)=\displaystyle\prod_{i=1}^nP\left(x_i;\,n\right)\)</span>，其中 <span class="math inline">\(\theta\)</span> 为参数</p></li><li><p>等式两边取对数 <span class="math inline">\(\lnL(\theta)=\displaystyle\sum_{i=1}^n\lnP\left(x_i;\,n\right)\)</span></p></li><li><p>对参数求导 <span class="math inline">\(\dfrac{d}{d\theta}\lnL(\theta)\)</span></p></li><li><p>寻找最大似然估计量（值）</p><ul><li>驻点存在且唯一：驻点</li><li>驻点不存在：边界点</li></ul></li></ol><h2 id="置信区间">置信区间</h2><p>置信区间 (<em>Confidence Interval</em>)</p><h1 id="假设检验">假设检验</h1><h1 id="线性回归">线性回归</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;随机事件及其概率&quot;&gt;随机事件及其概率&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;考试要求&lt;/strong&gt;&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;了解样本空间 (基本事件空间)
的概念，理解随机事件的概念，掌握事件的关系及运算。&lt;/li&gt;
&lt;li&gt;理解概率、</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://devexzh.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数学" scheme="https://devexzh.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Remarques pour le français</title>
    <link href="https://devexzh.github.io/2023/Remarques_Pour_Le_Francais/"/>
    <id>https://devexzh.github.io/2023/Remarques_Pour_Le_Francais/</id>
    <published>2023-04-13T12:45:00.000Z</published>
    <updated>2023-07-24T06:34:52.365Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冠词">冠词</h1><h2 id="不定冠词">不定冠词</h2><table><thead><tr class="header"><th style="text-align: center;">阴性</th><th style="text-align: center;">阳性</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">une</td><td style="text-align: center;">un</td></tr></tbody></table><h2 id="定冠词">定冠词</h2><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">阴性</th><th style="text-align: center;">阳性</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">单数</td><td style="text-align: center;">la</td><td style="text-align: center;">le</td></tr><tr class="even"><td style="text-align: center;">复数</td><td style="text-align: center;">les</td><td style="text-align: center;">les</td></tr></tbody></table><h1 id="疑问句">疑问句</h1><h2 id="一般疑问句">一般疑问句</h2><p><strong>格式</strong>：Est-ce que + (主语) + (谓语) ?</p><h2 id="特殊疑问句">特殊疑问句</h2><p><strong>格式</strong> - Que/Quel + (谓语) + (主语) ? - (主语) +(谓语) + quoi ?</p><p>Que 和 Quel 的区别</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">que</th><th style="text-align: center;">quel</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">词性</td><td style="text-align: center;">疑问代词，从不跟名词</td><td style="text-align: center;">疑问形容词，跟名词（当动词是être的时候除外，隐含从有限个东西里选择的意思）</td></tr><tr class="even"><td style="text-align: center;">提问对象</td><td style="text-align: center;">主谓宾结构</td><td style="text-align: center;">主系表结构</td></tr><tr class="odd"><td style="text-align: center;">例文</td><td style="text-align: center;">Que fait Marie?</td><td style="text-align: center;">Quel est ton nom?</td></tr></tbody></table><p>Que 和 Qu'est-ce que 的区别</p><table><caption>notebook: Qu'est-ce que 主要用于口语中</caption><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">Que</th><th style="text-align: center;">Qu'est-ce que</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">是否倒装</td><td style="text-align: center;">倒装</td><td style="text-align: center;">不倒装</td></tr><tr class="even"><td style="text-align: center;">例文</td><td style="text-align: center;">Que fais-tu ici?</td><td style="text-align: center;">Qu'est-ce que tu fais ici?</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;冠词&quot;&gt;冠词&lt;/h1&gt;
&lt;h2 id=&quot;不定冠词&quot;&gt;不定冠词&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th style=&quot;text-align: center;&quot;&gt;阴性&lt;/th&gt;
&lt;th style=&quot;text-alig</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://devexzh.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="语言学习" scheme="https://devexzh.github.io/tags/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>LaTeX 常用符号速查手册</title>
    <link href="https://devexzh.github.io/2023/LaTeX_Reference_Manual/"/>
    <id>https://devexzh.github.io/2023/LaTeX_Reference_Manual/</id>
    <published>2023-02-20T13:40:00.000Z</published>
    <updated>2023-07-24T06:35:18.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考手册">参考手册</h1><p>Ti<em>k</em>Z 和 PGF 绘图包：<a href="https://github.com/pgf-tikz/pgf/releases/latest">TikZ/PGF</a></p><p>2D/3D <span class="math inline">\(\LaTeX\)</span> 绘图包: <a href="https://github.com/pgf-tikz/pgfplots/releases/latest">PGFPlots</a></p><h1 id="希腊字母">希腊字母</h1><p>大写的希腊字母一般是正体，带有 \var命令的则是斜体样式，即下表中标注蓝色的字母，需要在导言区加载 amsmath宏包。</p><p>小写的直立希腊字母，需要 upgreek 或类似字体包，然后前缀加上 “up”即可，如 , 即小写的直立希腊字母。</p><table style="width:100%;"><thead><tr class="header"><th style="text-align: center;">符号</th><th style="text-align: center;"><span class="math inline">\(\LaTeX\)</span></th><th style="text-align: center;">符号</th><th style="text-align: center;"><span class="math inline">\(\LaTeX\)</span></th><th style="text-align: center;">符号</th><th style="text-align: center;"><span class="math inline">\(\LaTeX\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\alpha\)</span></td><td style="text-align: center;">\alpha</td><td style="text-align: center;"><span class="math inline">\(\theta\)</span></td><td style="text-align: center;">\theta</td><td style="text-align: center;"><span class="math inline">\(\omicron\)</span></td><td style="text-align: center;">o</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\beta\)</span></td><td style="text-align: center;">\beta</td><td style="text-align: center;"><span class="math inline">\(\vartheta\)</span></td><td style="text-align: center;">\artheta</td><td style="text-align: center;"><span class="math inline">\(\pi\)</span></td><td style="text-align: center;">\pi</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\gamma\)</span></td><td style="text-align: center;">\gamma</td><td style="text-align: center;"><span class="math inline">\(\iota\)</span></td><td style="text-align: center;">\iota</td><td style="text-align: center;"><span class="math inline">\(\varpi\)</span></td><td style="text-align: center;">\varpi</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\delta\)</span></td><td style="text-align: center;">\delta</td><td style="text-align: center;"><span class="math inline">\(\kappa\)</span></td><td style="text-align: center;">\kappa</td><td style="text-align: center;"><span class="math inline">\(\rho\)</span></td><td style="text-align: center;">\rho</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\epsilon\)</span></td><td style="text-align: center;">\epsilon</td><td style="text-align: center;"><span class="math inline">\(\lambda\)</span></td><td style="text-align: center;">\lambda</td><td style="text-align: center;"><span class="math inline">\(\varrho\)</span></td><td style="text-align: center;">\varrho</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\varepsilon\)</span></td><td style="text-align: center;">\varepsilon</td><td style="text-align: center;"><span class="math inline">\(\mu\)</span></td><td style="text-align: center;">\mu</td><td style="text-align: center;"><span class="math inline">\(\sigma\)</span></td><td style="text-align: center;">\sigma</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\zeta\)</span></td><td style="text-align: center;">\zeta</td><td style="text-align: center;"><span class="math inline">\(\nu\)</span></td><td style="text-align: center;">\nu</td><td style="text-align: center;"><span class="math inline">\(\varsigma\)</span></td><td style="text-align: center;">\varsigma</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\eta\)</span></td><td style="text-align: center;">\eta</td><td style="text-align: center;"><span class="math inline">\(\xi\)</span></td><td style="text-align: center;">\xi</td><td style="text-align: center;"><span class="math inline">\(\tau\)</span></td><td style="text-align: center;">\tau</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\Delta\)</span></td><td style="text-align: center;">\Delta</td><td style="text-align: center;"><span class="math inline">\(\Xi\)</span></td><td style="text-align: center;">\Xi</td><td style="text-align: center;"><span class="math inline">\(\Upsilon\)</span></td><td style="text-align: center;">\Upsilon</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\Theta\)</span></td><td style="text-align: center;">\Theta</td><td style="text-align: center;"><span class="math inline">\(\Pi\)</span></td><td style="text-align: center;">\Pi</td><td style="text-align: center;"><span class="math inline">\(\Phi\)</span></td><td style="text-align: center;">\Phi</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\varGamma\)</span></td><td style="text-align: center;">\varGamma</td><td style="text-align: center;"><span class="math inline">\(\varLambda\)</span></td><td style="text-align: center;">\varLambda</td><td style="text-align: center;"><span class="math inline">\(\varSigma\)</span></td><td style="text-align: center;">\varSigma</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\varDelta\)</span></td><td style="text-align: center;">\varDelta</td><td style="text-align: center;"><span class="math inline">\(\varXi\)</span></td><td style="text-align: center;">\varXi</td><td style="text-align: center;"><span class="math inline">\(\varUpsilon\)</span></td><td style="text-align: center;">\varUpsilon</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\varTheta\)</span></td><td style="text-align: center;">\varTheta</td><td style="text-align: center;"><span class="math inline">\(\varPi\)</span></td><td style="text-align: center;">\varPi</td><td style="text-align: center;"><span class="math inline">\(\varPhi\)</span></td><td style="text-align: center;">\varPhi</td></tr></tbody></table><h1 id="二元关系符">二元关系符</h1><p>所有的二元关系符都可以加 \not 前缀得到相反意义的关系符，例如 \not=就得到不等号（同 \ne）</p><table style="width:100%;"><thead><tr class="header"><th style="text-align: center;">符号</th><th style="text-align: center;"><span class="math inline">\(\LaTeX\)</span></th><th style="text-align: center;">符号</th><th style="text-align: center;"><span class="math inline">\(\LaTeX\)</span></th><th style="text-align: center;">符号</th><th style="text-align: center;"><span class="math inline">\(\LaTeX\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\lt\)</span></td><td style="text-align: center;">\lt</td><td style="text-align: center;"><span class="math inline">\(\gt\)</span></td><td style="text-align: center;">\gt</td><td style="text-align: center;"><span class="math inline">\(=\)</span></td><td style="text-align: center;">=</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\le\)</span></td><td style="text-align: center;">\le or \lep</td><td style="text-align: center;"><span class="math inline">\(\ge\)</span></td><td style="text-align: center;">\ge or \geq</td><td style="text-align: center;"><span class="math inline">\(\equiv\)</span></td><td style="text-align: center;">\equiv</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\ll\)</span></td><td style="text-align: center;">\ll</td><td style="text-align: center;"><span class="math inline">\(\gg\)</span></td><td style="text-align: center;">\gg</td><td style="text-align: center;"><span class="math inline">\(\doteq\)</span></td><td style="text-align: center;">\doteq</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\prec\)</span></td><td style="text-align: center;">\prec</td><td style="text-align: center;"><span class="math inline">\(\succ\)</span></td><td style="text-align: center;">\succ</td><td style="text-align: center;"><span class="math inline">\(\sim\)</span></td><td style="text-align: center;">\sim</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\preceq\)</span></td><td style="text-align: center;">\preceq</td><td style="text-align: center;"><span class="math inline">\(\succeq\)</span></td><td style="text-align: center;">\succeq</td><td style="text-align: center;"><span class="math inline">\(\simeq\)</span></td><td style="text-align: center;">\simeq</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\subset\)</span></td><td style="text-align: center;">\subset</td><td style="text-align: center;"><span class="math inline">\(\supset\)</span></td><td style="text-align: center;">\supset</td><td style="text-align: center;"><span class="math inline">\(\approx\)</span></td><td style="text-align: center;">\approx</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\subseteq\)</span></td><td style="text-align: center;">\subseteq</td><td style="text-align: center;"><span class="math inline">\(\supseteq\)</span></td><td style="text-align: center;">\supseteq</td><td style="text-align: center;"><span class="math inline">\(\cong\)</span></td><td style="text-align: center;">\cong</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\sqsubset\)</span></td><td style="text-align: center;">\sqsubset</td><td style="text-align: center;"><span class="math inline">\(\sqsupset\)</span></td><td style="text-align: center;">\sqsupset</td><td style="text-align: center;"><span class="math inline">\(\Join\)</span></td><td style="text-align: center;">\Join</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\sqsubseteq\)</span></td><td style="text-align: center;">\sqsubseteq</td><td style="text-align: center;"><span class="math inline">\(\sqsupseteq\)</span></td><td style="text-align: center;">\sqsupseteq</td><td style="text-align: center;"><span class="math inline">\(\bowtie\)</span></td><td style="text-align: center;">\bowtie</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\in\)</span></td><td style="text-align: center;">\in</td><td style="text-align: center;"><span class="math inline">\(\ni\)</span></td><td style="text-align: center;">\ni, \owns</td><td style="text-align: center;"><span class="math inline">\(\propto\)</span></td><td style="text-align: center;">\propto</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\vdash\)</span></td><td style="text-align: center;">\vdash</td><td style="text-align: center;"><span class="math inline">\(\dashv\)</span></td><td style="text-align: center;">\dashv</td><td style="text-align: center;"><span class="math inline">\(\models\)</span></td><td style="text-align: center;">\models</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\mid\)</span></td><td style="text-align: center;">\mid</td><td style="text-align: center;"><span class="math inline">\(\parallel\)</span></td><td style="text-align: center;">\parallel</td><td style="text-align: center;"><span class="math inline">\(\perp\)</span></td><td style="text-align: center;">\perp</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\smile\)</span></td><td style="text-align: center;">\smile</td><td style="text-align: center;"><span class="math inline">\(\frown\)</span></td><td style="text-align: center;">\frown</td><td style="text-align: center;"><span class="math inline">\(\asymp\)</span></td><td style="text-align: center;">\asymp</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(:\)</span></td><td style="text-align: center;">:</td><td style="text-align: center;"><span class="math inline">\(\notin\)</span></td><td style="text-align: center;">\notin</td><td style="text-align: center;"><span class="math inline">\(\ne\)</span></td><td style="text-align: center;">\ne or \neq</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考手册&quot;&gt;参考手册&lt;/h1&gt;
&lt;p&gt;Ti&lt;em&gt;k&lt;/em&gt;Z 和 PGF 绘图包：&lt;a href=&quot;https://github.com/pgf-tikz/pgf/releases/latest&quot;&gt;TikZ/PGF&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2D/3D &lt;span</summary>
      
    
    
    
    <category term="参考手册" scheme="https://devexzh.github.io/categories/%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/"/>
    
    
    <category term="参考手册" scheme="https://devexzh.github.io/tags/%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/"/>
    
    <category term="LaTeX" scheme="https://devexzh.github.io/tags/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title>Electric Circuits</title>
    <link href="https://devexzh.github.io/2023/Note_Of_Electric_Circuits/"/>
    <id>https://devexzh.github.io/2023/Note_Of_Electric_Circuits/</id>
    <published>2023-02-19T04:00:00.000Z</published>
    <updated>2023-07-24T06:39:36.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="preface">Preface</h1><p>The post is the note based on the textbook <em>Fundamentals ofElectric Circuits</em> written Charles K. Alexander and Matthew N. O.Sadiku (ISBN: 978-1-260-57079-3)</p><p>Some particular symbols are introduced to describe some properties,as listed below.</p><p><strong>Symbol Table</strong></p><table><thead><tr class="header"><th style="text-align: center;">Symbol</th><th style="text-align: center;">Meaning</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="github-emoji"><span>🎒</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f392.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td style="text-align: center;">Already learned in middle school</td></tr><tr class="even"><td style="text-align: center;"><span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td style="text-align: center;">Key point of some contents</td></tr></tbody></table><p>The post is done individually by <em>Ryker Zhu</em> from <em>NanjingUniversity of Information Science and Technology</em>, published underthe license <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CCBY-NC-SA</a>.<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="CC BY-NC-SA" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"></a></p><h1 id="dc-circuits">DC Circuits</h1><h2 id="basic-concepts">Basic Concepts</h2><h3 id="charge-current">Charge &amp; Current</h3><p><strong><em>Electric Charge</em></strong>: an electrical property ofthe atomic particles of which matter consists, measured in coulombs(<span class="math inline">\(C\)</span>).</p><ul><li>The charge <span class="math inline">\(e\)</span> on an electron isnegative and equal in magnitude to <span class="math inline">\(1.602\times 10^{−19}C\)</span>, while a protoncarries a positive charge of the same magnitude as the electron.</li><li>The only charges that occur in nature are integral multiples of theelectronic charge <span class="math inline">\(e=1.602\times10^{−19}C\)</span></li><li><strong><em>Law of conservation of charge</em></strong> states thatcharge can neither be created nor destroyed, only transferred. Thus, thealgebraic sum of the electric charges in a system does not change.</li></ul><p><strong><em>Electric current</em></strong>: the time rate of changeof charge, measured in amperes (<span class="math inline">\(A\)</span>).The relationship between current <span class="math inline">\(i\)</span>,charge <span class="math inline">\(q\)</span>, and time <span class="math inline">\(t\)</span>&nbsp;is: <span class="math display">\[i\triangleq\frac{dq}{dt}\]</span> The chargetransferred between time <span class="math inline">\(t_0\)</span> and<span class="math inline">\(t\)</span> is obtained by integrating bothsides: <span class="math display">\[Q\triangleq\int^t_{t_0}i\,dt\]</span></p><p>Classification:</p><ul><li><strong><em>Direct Current</em></strong>: a current that flows onlyin one direction and can be constant or time varying. (e.g. <span class="math inline">\(i\left(t\right)=\left|5\sin\left(377t\right)\right|\)</span>whereas <span class="math inline">\(i\left(t\right)\)</span> keepspositive all the time)</li><li><strong><em>Alternating Current</em></strong>: a current thatchanges direction with respect to time. (e.g. <span class="math inline">\(i\left(t\right)=5\sin\left(377t\right)\)</span>)</li></ul><p>Convention:</p><ul><li><span class="math inline">\(I\)</span> - Constant current</li><li><span class="math inline">\(i\)</span> - Current varies with respectto time</li></ul><h3 id="voltage">Voltage</h3><p><strong><em>Voltage</em></strong> (or <strong><em>potentialdifference</em></strong>): the energy required to move a unit&nbsp;chargefrom a reference point (<span class="math inline">\(−\)</span>) toanother point (<span class="math inline">\(+\)</span>), measured&nbsp;in<strong>volts</strong> (<span class="math inline">\(V\)</span>).</p><p><strong><em>Power</em></strong> is the time rate of expending orabsorbing energy, measured in <strong>watts</strong> (<span class="math inline">\(W\)</span>). <span class="math display">\[p\triangleq\frac{dw}{dt}\]</span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;preface&quot;&gt;Preface&lt;/h1&gt;
&lt;p&gt;The post is the note based on the textbook &lt;em&gt;Fundamentals of
Electric Circuits&lt;/em&gt; written Charles K. Al</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://devexzh.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="电路" scheme="https://devexzh.github.io/tags/%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>IELTS Notes</title>
    <link href="https://devexzh.github.io/2023/IELTS_Learning/"/>
    <id>https://devexzh.github.io/2023/IELTS_Learning/</id>
    <published>2023-02-06T12:15:00.000Z</published>
    <updated>2023-07-24T06:36:39.274Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">纸笔</th><th style="text-align: center;">机考</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">听力</td><td style="text-align: center;">有10分钟填答题卡</td><td style="text-align: center;">只有2分钟检查答案</td></tr><tr class="even"><td style="text-align: center;">阅读</td><td style="text-align: center;">传统阅读做题方法</td><td style="text-align: center;">机考左半边屏幕是文章，右半边是题目，要用鼠标上下滑动</td></tr><tr class="odd"><td style="text-align: center;">口语</td><td style="text-align: center;">和考官面对面（疫情期间也是和机考一样视频通话）</td><td style="text-align: center;">视频通话，和听力/阅读/写作是同一天</td></tr><tr class="even"><td style="text-align: center;">写作</td><td style="text-align: center;"></td><td style="text-align: center;">字丑的可以机考；打字速度快的同学可以省更多的时间；机考实时显示字数</td></tr><tr class="odd"><td style="text-align: center;">出分时间</td><td style="text-align: center;">13 天后出成绩（周六笔试，下下周周五中午12 点出）</td><td style="text-align: center;">考后第三天下午 14:00 出成绩</td></tr></tbody></table><h1 id="listening">Listening</h1><h2 id="part-1">Part 1</h2><h2 id="part-2">Part 2</h2><h3 id="diagram-labeling">Diagram Labeling</h3><table><thead><tr class="header"><th style="text-align: center;">Element</th><th style="text-align: center;">Level</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>Frequency</em></td><td style="text-align: center;"><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td></tr><tr class="even"><td style="text-align: center;"><em>Difficulty</em></td><td style="text-align: center;"><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td></tr></tbody></table><h1 id="speaking">Speaking</h1><h2 id="part-1-1">Part 1</h2><h2 id="part-2-1">Part 2</h2><h2 id="part-3">Part 3</h2><p><em>Method</em>: Combination of functions listed below.</p><h3 id="functions">Functions</h3><pre><code class=" mermaid">flowchart TB  Functions --- Comparison &amp; Assessment &amp; Explanation &amp; Prediction &amp; Suggestion  Comparison --- Length &amp; Depth &amp; Grammar</code></pre><h4 id="comparison">Comparison</h4><ul><li>Past versus Now<ul><li>used to be... (more/-er), rather than...</li></ul></li><li>Universal<ul><li>There's a big difference...</li></ul></li></ul><h4 id="assessment">Assessment</h4><h4 id="explanation">Explanation</h4><h4 id="prediction">Prediction</h4><ul><li>We will see normal people like you and me / ... becoming</li><li>The chance of ... is slim</li><li>There's every/no possibility that... in xxx years' time.</li></ul><h4 id="suggestion">Suggestion</h4><ul><li>.... seems like it could be a good idea</li><li>it would be great if they/we could...</li></ul><h3 id="steps">Steps</h3><ol type="1"><li>Comment on the question<ul><li>Well, it's a tough question. I've never thought about it.</li></ul></li><li>Locate the keywords (nouns)</li><li>Add more functions (especially<strong><em>Comparison</em></strong>)</li><li>Refer back to the question</li></ol><h2 id="topics">Topics</h2><h3 id="food">Food</h3><pre><code class=" mermaid">classDiagram   class Food{    Color appearance    Taste how    Flavor specified    void cook(methodType)    bool isAffordable()    bool isEasyAccess()    int timeCanBeStored()   }</code></pre><h2 id="practical-sentences">Practical Sentences</h2><table><thead><tr class="header"><th style="text-align: center;">Issue</th><th style="text-align: center;">Answer</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">听不懂</td><td style="text-align: center;">Sorry, could you please rephrase that/say that in other words?</td></tr><tr class="even"><td style="text-align: center;">反应不过来/没听清</td><td style="text-align: center;">I'm sorry, I didn't get/ catch that.Could you say that again/ repeat it?</td></tr><tr class="odd"><td style="text-align: center;">单词不认识</td><td style="text-align: center;">What do you mean by...?</td></tr><tr class="even"><td style="text-align: center;">懂了但是不是很确定</td><td style="text-align: center;">Excuse me, I just want to make sure Iunderstand you fully, do you mean....?</td></tr><tr class="odd"><td style="text-align: center;">听懂</td><td style="text-align: center;">Well, It's a tough question... Let mesee...</td></tr></tbody></table><p>|Agree|Disagree| |||</p><h1 id="reading">Reading</h1><h2 id="fill-in-the-blanks">Fill in the Blanks</h2><h2 id="true-or-false">True or False</h2><h2 id="choice">Choice</h2><p><em>Features</em></p><ol type="1"><li>Sequential</li><li>Details orientated</li></ol><p><em>Testing Points</em></p><ol type="1"><li>Quantity - abstract / concrete</li><li>Time - before, after, today</li><li>Absolute words - all, must, only, every</li><li>Relationship<ul><li>Comparison</li><li>Reasons &amp; Results</li><li>Tendency</li></ul></li></ol><h2 id="matching">Matching</h2><p><em>Categories</em></p><ul><li>Proper noun (Name, Theory)</li><li>Normal noun</li></ul><h3 id="list-of-heading">List of Heading</h3><table><caption>warning: <em>Features</em> 1. 题目顺序</caption><thead><tr class="header"><th style="text-align: center;">Symbol</th><th style="text-align: center;"></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Roman number</td><td style="text-align: center;">Summary of paragraphs/sections</td></tr><tr class="even"><td style="text-align: center;">Matching options</td><td style="text-align: center;">1.5x ~ 2x summaries</td></tr></tbody></table><table><thead><tr class="header"><th style="text-align: center;">纸笔考试</th><th style="text-align: center;">机考</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">题在文<strong>前</strong></td><td style="text-align: center;">左文章右题目</td></tr></tbody></table><ol start="2" type="1"><li>分为 Section 或 Paragraph</li><li>不<strong>复选</strong></li><li>题目可能从<strong>任意段</strong>开始</li></ol><h4 id="steps-1">Steps</h4><ol type="1"><li><em>审题</em>：注意段落<strong>序号</strong>和是否<strong>有例子</strong>（划去）</li><li><em>配对</em><ul><li>关键词对应，通常是出现频率较高的词（可能同义复现或者同义替换）</li><li>主题句对应，前两句 + 末尾句</li><li><span class="github-emoji"><span>💡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 如果看不出，需要阅读全段</li></ul></li></ol><h1 id="writing">Writing</h1><h2 id="format">Format</h2><h2 id="task-1">Task 1</h2><table><thead><tr class="header"><th style="text-align: center;">Item</th><th style="text-align: center;">Requirement</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>Time Limit</em></td><td style="text-align: center;">20 min</td></tr><tr class="even"><td style="text-align: center;"><em>Word Count</em></td><td style="text-align: center;">150 ~ 200 words</td></tr><tr class="odd"><td style="text-align: center;"><em>Score</em></td><td style="text-align: center;">1/3</td></tr></tbody></table><h3 id="dynamic-charts">Dynamic Charts</h3><ol type="1"><li><p>上升</p><ul><li><strong><em>Verb</em></strong>: go up / rise (rose) / increase /grow / climb / ascend</li><li><strong><em>Noun</em></strong>: rise / increase / growth / climb /ascent</li></ul></li><li><p>下降</p><ul><li><strong><em>Verb</em></strong>: go down/ drop (dropped)/ decrease/decline/ fall (fell)/ descend</li><li><strong><em>Noun</em></strong>: drop/ decrease/ decline/ fall/descent</li></ul></li><li><p>急剧地</p><ul><li><strong><em>Adverb</em></strong>: rapidly / sharply / significantly/ dramatically / drastically</li><li><strong><em>Adjective</em></strong>: dramatic/ drastic</li></ul></li><li><p>平缓地</p><ul><li><strong><em>Adverb</em></strong>: insignificantly / slightly /smoothly / modestly</li></ul></li><li><p>急剧地上升</p><p><strong><em>Comparison</em></strong>: soar &amp; surge|Word|Meaning|中文| |:---:|:----:|:---:| |soar|If the amount, value,level, or volume of something soars, it quickly increases by a greatdeal.|急剧增加| |surge|If something surges, it increases suddenly andgreatly, after being steady or developing only slowly|剧增|</p></li><li><p>趋势</p><ul><li><strong><em>Noun</em></strong>: trend/ tendency<ul><li>上升的趋势: an increasing / upward trend</li><li>下降的趋势: a decreasing / downward trend</li></ul></li></ul></li><li><p>稳定</p><ul><li><strong><em>Adjective</em></strong>: stable / steady /unchanged</li><li><strong><em>Verb</em></strong>: stabilize<br></li><li><strong><em>level off / level out</em></strong>: If a changingnumber or amount levels off or levels out, it stops increasing ordecreasing at such a fast speed. 趋向稳定</li></ul></li><li><p>顶点（最大值）</p><ul><li><strong><em>Noun</em></strong>: top / peak / the highest point /maximum<ul><li>达到顶点 reach the peak at + 数据</li></ul></li><li><strong><em>Verb</em></strong>: peak at + 数据</li></ul></li><li><p>底部（最小值）</p></li></ol><ul><li><strong><em>Noun</em></strong>: bottom / minimum / the lowest point<ul><li>达到底部 reach the bottom at + 数据</li></ul></li><li><strong><em>Verb</em></strong>: bottom out (at + 数据)<ul><li>to reach the lowest point and level out 达到最低点并持平</li></ul></li></ul><ol start="11" type="1"><li>超过</li></ol><ul><li><strong><em>Verb</em></strong>: overtake (overtook) / exceed</li></ul><h4 id="line-graphs">Line Graphs</h4><h3 id="static-charts">Static Charts</h3><p>静态图数据描述原则</p><ul><li>从大到小</li><li>相同相近</li><li>倍数关系</li></ul><h4 id="pie-charts">Pie Charts</h4><h3 id="maps-flow-charts">Maps &amp; Flow Charts</h3><h2 id="task-2">Task 2</h2><table><thead><tr class="header"><th style="text-align: center;">Item</th><th style="text-align: center;">Requirement</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>Time Limit</em></td><td style="text-align: center;">40 min</td></tr><tr class="even"><td style="text-align: center;"><em>Word Count</em></td><td style="text-align: center;">250+ words</td></tr><tr class="odd"><td style="text-align: center;"><em>Score</em></td><td style="text-align: center;">2/3</td></tr></tbody></table><h3 id="criteria">Criteria</h3><table><thead><tr class="header"><th style="text-align: center;">Abbr.</th><th style="text-align: center;">Perspective</th><th style="text-align: center;"></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>TR</em></td><td style="text-align: center;">Task Response</td><td style="text-align: center;">切题</td></tr><tr class="even"><td style="text-align: center;"><em>CC</em></td><td style="text-align: center;">Coherence and Cohesion</td><td style="text-align: center;">逻辑</td></tr><tr class="odd"><td style="text-align: center;"><em>LR</em></td><td style="text-align: center;">Lexical Resource</td><td style="text-align: center;">词汇</td></tr><tr class="even"><td style="text-align: center;"><em>GRA</em></td><td style="text-align: center;">Grammatical Range and Accuracy</td><td style="text-align: center;">语法</td></tr></tbody></table><h4 id="lr">LR</h4><ul><li>Sophistication</li><li>Variation - Employ more paraphrasing</li></ul><h4 id="gra">GRA</h4><ul><li>Less grammatical errors</li><li>A variety of complex structures</li></ul><h3 id="argument">Argument</h3><h4 id="agree-or-disagree">Agree or Disagree</h4><table><thead><tr class="header"><th style="text-align: center;">观点 A 与 B 的合理性</th><th style="text-align: center;">我的观点选择</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">矛盾且都合理</td><td style="text-align: center;">A 或 B</td></tr><tr class="even"><td style="text-align: center;">不矛盾且都合理</td><td style="text-align: center;">A 和 B</td></tr><tr class="odd"><td style="text-align: center;">都不合理</td><td style="text-align: center;">C</td></tr><tr class="even"><td style="text-align: center;">只有一方合理</td><td style="text-align: center;">合理的一方</td></tr></tbody></table><h4 id="both-views">Both Views</h4><h4 id="mixed">Mixed</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;

&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th style=&quot;text-align: center;&quot;&gt;&lt;/th&gt;
&lt;th style=&quot;text-align: center;&quot;&gt;纸笔&lt;/th&gt;
&lt;th style=&quot;text-align: ce</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://devexzh.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="英语" scheme="https://devexzh.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>物理笔记</title>
    <link href="https://devexzh.github.io/2023/Note_Of_Physics/"/>
    <id>https://devexzh.github.io/2023/Note_Of_Physics/</id>
    <published>2023-02-02T13:30:00.000Z</published>
    <updated>2023-07-24T06:38:04.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="preface">Preface</h1><p>The post is the note based on the textbook <em>Fundamentals ofPhysics</em> written by David Halliday, Robert Resnick and Jearl Walker(ISBN: 978-1-118-23072-5)</p><p>Some particular symbols are introduced to describe some properties,as listed below.</p><p><strong>Symbol Table</strong></p><table><thead><tr class="header"><th style="text-align: center;">Symbol</th><th style="text-align: center;">Meaning</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="github-emoji"><span>🎒</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f392.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td style="text-align: center;">Already learned in middle school</td></tr><tr class="even"><td style="text-align: center;"><span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td style="text-align: center;">Key point of some contents</td></tr></tbody></table><p>The post is done individually by <em>Ryker Zhu</em> from <em>NanjingUniversity of Information Science and Technology</em>, published underthe license <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CCBY-NC-SA</a>.<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="CC BY-NC-SA" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"></a></p><h1 id="measurement">Measurement</h1><table><caption>school_satchel: <strong>International System of Units</strong>(Français: Système international d'unités) (Abbr. <strong>SI</strong>),i.e. <strong>metric system</strong>.</caption><thead><tr class="header"><th style="text-align: center;">Symbol</th><th style="text-align: center;">Name</th><th style="text-align: center;">Quantity</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(s\)</span></td><td style="text-align: center;">second</td><td style="text-align: center;">time</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(m\)</span></td><td style="text-align: center;">meter</td><td style="text-align: center;">length</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(kg\)</span></td><td style="text-align: center;">kilogram</td><td style="text-align: center;">mass</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(A\)</span></td><td style="text-align: center;">ampere</td><td style="text-align: center;">electric current</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(K\)</span></td><td style="text-align: center;">kelvin</td><td style="text-align: center;">thermodynamic temperature</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(mol\)</span></td><td style="text-align: center;">mole</td><td style="text-align: center;">amount of substance</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(cd\)</span></td><td style="text-align: center;">candela</td><td style="text-align: center;">luminous intensity</td></tr></tbody></table><h1 id="motion">Motion</h1><h2 id="vector-scalar">Vector &amp; Scalar</h2><pre><code class=" mermaid">flowchart LR  A(Physical Quantities) --- B(Vector Quantities) &amp; C(Scalars)  B --- D(Magnitude) &amp; E(Direction)</code></pre><p><span class="github-emoji"><span>🎒</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f392.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong><em>Component</em></strong>: Projection ofthe vector on an axis.</p><ul><li>Vector component : <span class="math inline">\(a_x\hat{i},\,a_y\hat{j}\)</span></li><li>(Scalar) component : <span class="math inline">\(a_x,\,a_y\)</span></li></ul><p><span class="github-emoji"><span>🎒</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f392.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong><em>Scalar Product</em></strong> or<strong><em>Dot Product</em></strong>: spoken as "a dot b" <span class="math display">\[\vec{a}\cdot\vec{b}=a\cdot b \cos\phi\]</span><span class="math inline">\(a\)</span> - magnitude of the vector <span class="math inline">\(\vec{a}\)</span>;<br><span class="math inline">\(\phi\)</span> - angle between <span class="math inline">\(\vec{a}\)</span> and <span class="math inline">\(\vec{b}\)</span>.</p><p><strong><em>Vector Product</em></strong> or <strong><em>CrossProduct</em></strong>: spoken as "a cross b"</p><ul><li><p>Magnitude</p><p><span class="math display">\[c=a\cdot b \sin\phi\]</span> <span class="math inline">\(c\)</span> - magnitude of the vector <span class="math inline">\(\vec{c}\)</span>;<br><span class="math inline">\(\phi\)</span> - <em>smaller</em> of the twoangles between <span class="math inline">\(\vec{a}\)</span> and <span class="math inline">\(\vec{b}\)</span>.</p></li><li><p>Direction</p><p>Perpendicular to the plane containing <span class="math inline">\(\vec{a}\)</span> and <span class="math inline">\(\vec{b}\)</span>.<br>Determine with <strong>right-hand rule</strong>, right-hand fingers swap<span class="math inline">\(\vec{a}\)</span> into <span class="math inline">\(\vec{b}\)</span>.</p></li></ul><h2 id="position-and-displacement">Position and Displacement</h2><p><span class="github-emoji"><span>🎒</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f392.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong><em>Kinematics</em></strong>:(<em>/,kɪnɪ'mætɪks/</em> or <em>/kaɪnə'mætɪks]/</em>) Classification andcomparison of motions.</p><p><span class="github-emoji"><span>🎒</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f392.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong><em>Particle</em></strong>: Point-likeobject</p><h3 id="projectile-motion">Projectile Motion</h3><blockquote><p>A particle moves in a vertical plane with some initial velocity, butits acceleration is always the free-fall acceleration, which isdownward.</p><p>Such a particle is called <strong><em>projectile</em></strong><em>/prəˈdʒektaɪl/</em> and its motion is called <strong><em>projectilemotion</em></strong>.</p></blockquote><p>Horizontal Motion: <span class="math display">\[x-x_0=v_{0x}t=\left(v_0\cos\theta_0\right)t\]</span>Vertical Motion: <span class="math display">\[y-y_0=v_{0y}-\frac{1}{2}gt^2\]</span></p><p>The Equation of the Path (<strong><em>Trajectory</em></strong><em>/trəˈdʒektəri/</em>): <span class="math display">\[y=\left(\tan\theta_0\right)x-\frac{g}{2\left(v_0\cos\theta_0\right)^2}x^2\]</span>The equation is also the one of <strong><em>parabola</em></strong><em>/pəˈræbələ/</em> so the path is parabolic.</p><h1 id="force">Force</h1><blockquote><p><strong><em>Newtonian Mechanics</em></strong>: The relation between aforce and the acceleration it causes</p></blockquote><h2 id="school_satchel-newtons-three-primary-laws-of-motion"><span class="github-emoji"><span>🎒</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f392.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>Newton's three primary laws of motion</h2><p><strong><em>Net Force</em></strong> or <strong><em>ResultantForce</em></strong>: Adding all forces acted on the same body</p><p><strong><em>Principle of superposition for forces</em></strong>: Asingle force that has the same magnitude and direction as the calculatednet force would then have the same effect as all the individualforces.</p><p><span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> Newton's laws is not always true unless in<strong><em>inertial</em></strong> <em>/ɪˈnɜːʃl/</em><strong><em>reference frames</em></strong>.</p><h3 id="newtons-first-law">Newton’s First Law</h3><blockquote><p>If no net force acts on a body (<span class="math inline">\(\overrightarrow{F_\mathrm{net}}=0\)</span>), thebody’s velocity cannot change; that is, the body cannot accelerate.</p></blockquote><h3 id="newtons-second-law">Newton’s Second Law</h3><blockquote><p>The net force on a body is equal to the product of the body’s massand its acceleration.</p><p><span class="math display">\[\overrightarrow{F_\mathrm{net}}=m\vec{a}\]</span></p></blockquote><p><span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> The acceleration component along a given axis is causedonly by the sum of the force components along that same axis, and not byforce components along any other axis.</p><p><strong><em>Forces in Equilibrium</em></strong>: Any forces on thebody balance one another, and both the forces and the body are said tobe in <strong><em>equilibrium</em></strong> (<em>/ˌiːkwɪˈlɪbriəm/</em>or <em>/ˌekwɪˈlɪbriəm/</em>).</p><h3 id="newtons-third-law">Newton’s Third Law</h3><blockquote><p>When two bodies interact, the forces on the bodies from each otherare always equal in magnitude and opposite in direction.</p></blockquote><h3 id="particular-forces">Particular Forces</h3><h4 id="school_satchel-normal-force"><span class="github-emoji"><span>🎒</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f392.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong><em>NormalForce</em></strong></h4><p>When a body presses against a surface, the surface (even a seeminglyrigid one) deforms and pushes on the body with a normal force <span class="math inline">\(\overrightarrow{F_N}\)</span> that isperpendicular to the surface.</p><h4 id="school_satchel-frictional-force"><span class="github-emoji"><span>🎒</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f392.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong><em>Frictional force</em></strong></h4><p>The force on a body when the body slides or attempts to slide along asurface. The force is always parallel to the surface and directed so asto oppose the sliding. On a frictionless surface, the frictional forceis negligible.</p><ul><li>If the body does not slide, the frictional force <span class="math inline">\(f_s\)</span> is a <strong><em>static frictionalforce</em></strong>.<ul><li>The magnitude of <span class="math inline">\(f_s\)</span> has amaximum value <span class="math inline">\(f_{s,max}\)</span> given by<span class="math display">\[f_{s,max}=\mu_sF_N\]</span><ul><li><span class="math inline">\(\mu_s\)</span> - <strong><em>coefficientof static friction</em></strong></li><li><span class="math inline">\(F_N\)</span> - magnitude of the normalforce.</li></ul></li></ul></li><li>If there is sliding, the frictional force is a <strong><em>kineticfrictional force</em></strong>.<ul><li>The magnitude of the frictional force rapidly decreases to aconstant value <span class="math inline">\(f_k\)</span> given by <span class="math display">\[f_k=\mu_kF_N\]</span><ul><li><span class="math inline">\(\mu_k\)</span> - <strong><em>coefficientof kinetic friction</em></strong></li></ul></li></ul></li></ul><h4 id="drag-force"><strong><em>Drag Force</em></strong></h4><p>When there is relative motion between air (or some other fluid) and abody, the body experiences a drag force <span class="math inline">\(\vec{D}\)</span> that opposes the relative motionand points in the direction in which the fluid flows relative to thebody.</p><p>The magnitude of D: <span class="math display">\[D=\frac{1}{2}C\rhoAv^2\]</span> - <span class="math inline">\(C\)</span> - anexperimentally determined drag coefficient - <span class="math inline">\(\rho\)</span> - the fluid density (mass per unitvolume) - <span class="math inline">\(A\)</span> - the effectivecross-sectional area of the body (the area of a cross section takenperpendicular to the relative velocity <span class="math inline">\(\vec{v}\)</span>).</p><h1 id="energy-work">Energy &amp; Work</h1><h1 id="center-of-mass-linear-momentum">Center of Mass &amp; LinearMomentum</h1><h1 id="rotation-angular-momentum">Rotation &amp; Angular Momentum</h1><h1 id="gravitation">Gravitation</h1><h1 id="oscillations">Oscillations</h1><h1 id="waves">Waves</h1><h1 id="the-kinetic-theory-of-gases">The Kinetic Theory of Gases</h1><h1 id="the-law-of-thermodynamics">The Law of Thermodynamics</h1><h1 id="electricity">Electricity</h1><h1 id="gausss-law">Gauss's Law</h1><h1 id="dc-circuits">DC Circuits</h1><h1 id="magnetic-fields">Magnetic Fields</h1><h1 id="magnetic-fields-due-to-currents">Magnetic Fields Due toCurrents</h1><h1 id="induction-inductance">Induction &amp; Inductance</h1><h1 id="electromagnetic-oscillations-alternating-current">ElectromagneticOscillations &amp; Alternating Current</h1><h1 id="maxwells-equations-magnetism-of-matter">Maxwell's Equations;Magnetism of Matter</h1><h1 id="electromagnetic-waves">Electromagnetic Waves</h1><h1 id="optics">Optics</h1><h1 id="relativity">Relativity</h1><h1 id="quantum-physics">Quantum Physics</h1><h1 id="conduction-of-electricity-in-solids">Conduction of Electricityin Solids</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;preface&quot;&gt;Preface&lt;/h1&gt;
&lt;p&gt;The post is the note based on the textbook &lt;em&gt;Fundamentals of
Physics&lt;/em&gt; written by David Halliday, Robe</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://devexzh.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="物理" scheme="https://devexzh.github.io/tags/%E7%89%A9%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>高等数学笔记</title>
    <link href="https://devexzh.github.io/2023/Note_Of_Advanced_Mathematics/"/>
    <id>https://devexzh.github.io/2023/Note_Of_Advanced_Mathematics/</id>
    <published>2023-01-31T06:25:00.000Z</published>
    <updated>2023-07-24T06:40:18.593Z</updated>
    
    <content type="html"><![CDATA[<p>对于考研数学（数学一）而言，高等数学约占60%，考研数学整张卷子一共10个选择题、6个填空题、6个解答题。</p><h1 id="极限">极限</h1><p>极限（Limit）研究函数在 <strong>某一个小区间</strong>上的各种性质。</p><blockquote><p>趋向常数时的函数极限：<span class="math inline">\(\forall\varepsilon&gt;0,\,\exists\delta&gt;0,\,0&lt;\left|x-x_0\right|&lt;\delta,\,\left|f\left(x\right)-A\right|&lt;\varepsilon\Rightarrow\displaystyle\lim_{x\to{x_0}}{f\left(x\right)}=A\)</span></p></blockquote><blockquote><p>趋向无穷时的函数极限：<span class="math inline">\(\forall\varepsilon&gt;0,\,\exists{X}&gt;0,\,\left|x\right|&gt;X,\,\left|f\left(x\right)-A\right|&lt;\varepsilon\Rightarrow\displaystyle\lim_{x\to{\infty}}{f\left(x\right)}=A\)</span></p></blockquote><p><span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>注意</strong></p><ul><li><p><span class="math inline">\(\displaystyle\lim_{x\to{x_0}}{f\left(x\right)}\)</span>是否存在与<span class="math inline">\(f\left(x_0\right)\)</span>无关</p></li><li><p>充要条件：左右极限相等时，函数极限存在；反之亦然</p><p><span class="math inline">\(\displaystyle\lim_{x\to{x_0^+}}{f\left(x\right)}=\lim_{x\to{x_0^-}}{f\left(x\right)}=A\Leftrightarrow\lim_{x\to{x_0}}{f\left(x\right)}=A\)</span></p><p><span class="math inline">\(\displaystyle\lim_{x\to{+\infty}}{f\left(x\right)}=\lim_{x\to{-\infty}}{f\left(x\right)}=A\Leftrightarrow\lim_{x\to{\infty}}{f\left(x\right)}=A\)</span></p></li><li><p>极限定义的变体</p><ul><li>更改极限定义中的小于号为小于等于号 <strong>不影响</strong>最终极限的表达，即以下两种是可以相互替换的：<ul><li><span class="math inline">\(0&lt;\left|x-x_0\right|&lt;\delta\Leftrightarrow0&lt;\left|x-x_0\right|\leq\delta\)</span></li><li><span class="math inline">\(\left|f\left(x\right)-A\right|&lt;\varepsilon\Leftrightarrow\left|f\left(x\right)-A\right|\leq\varepsilon\)</span></li></ul></li><li>极限定义中的<span class="math inline">\(\varepsilon\)</span>可以换成任意表达式，只要<ol type="1"><li>表达式 <strong>结果为正</strong>（例如： <span class="math inline">\(\forall{\gamma&gt;0},\,\left|f\left(x\right)-A\right|&lt;\frac1{\gamma}\)</span>）</li><li>表达式可以 <strong>取到任意小的正数</strong></li></ol></li></ul></li></ul><h2 id="极限的性质">极限的性质</h2><ol type="1"><li><p>唯一性 （常常用来证明）</p><p>函数极限存在，则只能存在唯一的值，否则就是不存在。</p></li><li><p>局部有界性</p><p>在某个小区域内，函数有界。</p><blockquote><p><span class="math inline">\(\displaystyle\lim_{x\to{x_0}}{f\left(x\right)}=A\Rightarrow\exists{\delta,M&gt;0},\,0&lt;\left|x-x_0\right|&lt;\delta,\,\left|f\left(x\right)\right|\leq{M}\)</span></p></blockquote></li><li><p>局部保号性（可以用来证明 <span class="math inline">\(Fermat\)</span> 引理，经常与极值、拐点结合）</p><p>在某个小区域内，函数值的符号与极限值的符号一致。</p><blockquote><p><span class="math inline">\(\displaystyle\lim_{x\to{x_0}}{f\left(x\right)}=A\Rightarrow\exists{\delta&gt;0},\,0&lt;\left|x-x_0\right|&lt;\delta,\)</span><span class="math inline">\(\left \{\begin{array}{l}A&gt;0\Rightarrow{f\left(x\right)&gt;0}\\f\left(x\right)\geq0\Rightarrow{A\geq0}\end{array}\right.\)</span></p></blockquote></li></ol><h2 id="极限的求法">极限的求法</h2><h3 id="夹逼准则">夹逼准则</h3><blockquote><p>设函数 <span class="math inline">\(f\left(x\right),\,g\left(x\right),\,h\left(x\right)\)</span>满足：</p><ol type="1"><li><span class="math inline">\(\exists{\mathring{U}\left(x_0,\delta\right)}\)</span>，有<span class="math inline">\(g\left(x\right)\leq f\left(x\right)\leqh\left(x\right)\)</span></li><li><span class="math inline">\(\displaystyle\lim_{x\tox_0}g\left(x\right)=\lim_{x\to x_0}h\left(x\right)=A\)</span></li></ol><p>则 <span class="math inline">\(\displaystyle\lim_{x\tox_0}f\left(x\right)=A\)</span></p></blockquote><p>特点：不好求极限但是好放缩（如 <span class="math inline">\(x^2+y^2\geq2xy\)</span>）<br>当式子放大之后为0，则要想到给式子加绝对值</p><h3 id="单调有界收敛准则">单调有界收敛准则</h3><p>单调有界数列必有极限（单调增数列有上界必收敛）</p><p>证明数列单调的常用方法：</p><ul><li><p><span class="math inline">\(x_{n+1}-x_n\geq 0\;\left(\leq0\right)\)</span></p></li><li><p><span class="math inline">\(\displaystyle\frac{x_{n+1}}{x_n}\geq1\;\left(\leq 1\right)\)</span></p></li><li><p>数学归纳法</p></li><li><p><span class="math inline">\(x_{n+1}=f\left(x_n\right)\)</span></p><pre><code class=" mermaid">flowchart TB  函数可导 ---|导函数| 恒大于零 &amp; 恒小于零  恒小于零 --- 数列不具有单调性   恒大于零 ---|前两个元素| 单调增 &amp; 单调减</code></pre></li></ul><h2 id="无穷小">无穷小</h2><h3 id="无穷小的运算性质">无穷小的运算性质</h3><ol type="1"><li>有限个无穷小的乘积仍为无穷小</li><li>有限个无穷小的和仍为无穷小</li><li>有界函数与无穷小的乘积仍为无穷小</li></ol><h3 id="等价无穷小">等价无穷小</h3><p><span class="math inline">\(\begin{array}{l}\sin{x} \sim x&amp;\tan{x} \sim x \\[0.5em] \arcsin{x} \sim x &amp;\arctan{x} \sim x\\[0.5em] \ln{\left(x+\sqrt{1+x^2}\right)} \sim x&amp;\ln{\left(1+x\right)} \sim x &amp;e^x-1 \sim x \\[0.5em] \\\left(1+x\right)^\alpha \sim \alpha x+1 &amp;\log_a{(1+x)} \sim\frac{x}{\ln{a}} \\[0.5em] \\ x-\ln{\left(1+x\right)} \sim\frac{1}{2}x^2 &amp;1-\cos{x} \sim \frac{1}{2}x^2 \\[0.5em] \\\tan{x}-\sin{x} \sim \frac{1}{2}x^3 \\[0.5em] \tan{x}-x \sim\frac{1}{3}x^3 &amp; x-\arctan{x} \sim \frac{1}{3}x^3 \\[0.5em]x-\sin{x} \sim \frac{1}{6}x^3 &amp;\arcsin{x}-x \sim\frac{1}{6}x^3\end{array}\)</span></p><h2 id="极限的运算">极限的运算</h2><h3 id="无穷小的运算性质-1">无穷小的运算性质</h3><ol type="1"><li>有限个无穷小之和/积仍为无穷小</li><li>有界函数与无穷小的积仍为无穷小</li></ol><h3 id="多项式比值的极限求法">多项式比值的极限求法</h3><blockquote><p><span class="math inline">\(\displaystyle\lim_{x\to\infty}{\frac{a_0x^m+a_1x^{m-1}+\cdots+a_{m-1}x+a_m}{b_0x^n+b_1x^{n-1}+\cdots+b_{n-1}x+b_n}}\left(a_0,b_0\neq0\right)=\lim_{x\to\infty}{\frac{a_0x^m}{b_0x^n}}\)</span><span class="math inline">\(=\left\{\begin{array}{ll}\frac{a_0}{b_0}&amp;m=n\\\infty&amp;m&gt;n\\0&amp;m&lt;n\end{array}\right.\)</span></p></blockquote><h3 id="未定式极限的求法">未定式极限的求法</h3><ul><li><p><span class="math inline">\(\frac{\infty}{\infty}\)</span>、<span class="math inline">\(\frac{0}{0}\)</span> 型 利用 <span class="math inline">\(L'H\hat{o}pital\)</span> 法则</p></li><li><p><span class="math inline">\(0\cdot\infty\)</span> 型</p></li><li><p><span class="math inline">\(\infty-\infty\)</span> 型</p></li><li><p><span class="math inline">\({f\left(x\right)}^{g\left(x\right)}\)</span>型（<span class="math inline">\(1^\infty\)</span>、<span class="math inline">\(0^0\)</span>、<span class="math inline">\(\infty^0\)</span>）</p><p>利用对数恒等式 <span class="math inline">\({f\left(x\right)}^{g\left(x\right)}=e^{g\left(x\right)\ln{f\left(x\right)}}\)</span> 转换表达式</p></li></ul><h2 id="连续">连续</h2><p>函数的连续性 (Continuity):</p><blockquote><p><span class="math inline">\(f\left(x\right)\)</span> 在 <span class="math inline">\(x_0\)</span> 处连续 <span class="math inline">\(\Leftrightarrow\displaystyle\lim_{\Delta x\to0}\Delta y=0\)</span> <span class="math inline">\(\displaystyle\Leftrightarrow\lim_{\Delta x\to0}f\left(x_0+\Delta x\right)-f\left(x_0\right)=0\)</span> <span class="math inline">\(\displaystyle\Leftrightarrow\lim_{x\to{x_0}}f\left(x\right)=f\left(x_0\right)\)</span></p></blockquote><h3 id="间断点">间断点</h3><ul><li>第 <span class="math inline">\(\mathrm{I}\)</span> 类间断点：<span class="math inline">\(\displaystyle\lim_{x\tox_0^+}f\left(x\right)\)</span> 与 <span class="math inline">\(\displaystyle\lim_{x\tox_0^-}f\left(x\right)\)</span> 均存在<ul><li><span class="math inline">\(\displaystyle\lim_{x\tox_0^+}f\left(x\right)=\lim_{x\to x_0^-}f\left(x\right)\neqf\left(x_0\right)\)</span>（或 <span class="math inline">\(f\left(x_0\right)\)</span> 不存在），则 <span class="math inline">\(x=x_0\)</span> 为<strong>可去间断点</strong></li><li><span class="math inline">\(\displaystyle\lim_{x\tox_0^+}f\left(x\right)\neq\lim_{x\to x_0^-}f\left(x\right)\)</span>，则<span class="math inline">\(x=x_0\)</span>为<strong>跳跃间断点</strong></li></ul></li><li>第 <span class="math inline">\(\mathrm{II}\)</span> 类间断点：<span class="math inline">\(\displaystyle\lim_{x\tox_0^+}f\left(x\right)\)</span> 与 <span class="math inline">\(\displaystyle\lim_{x\tox_0^-}f\left(x\right)\)</span> 至少有其中之一不存在</li></ul><h3 id="闭区间上连续函数的性质">闭区间上连续函数的性质</h3><h4 id="有界性与最值定理">有界性与最值定理</h4><p>设函数 <span class="math inline">\(f\left(x\right)\)</span> 在闭区间<span class="math inline">\(\left[a,\,b\right]\)</span> 上连续，则 <span class="math inline">\(f\left(x\right)\)</span>在该区间上有界，且必可取到最大值与最 小值。</p><h4 id="零点存在性定理">零点存在性定理</h4><p>设函数 <span class="math inline">\(f\left(x\right)\)</span> 在闭区间<span class="math inline">\(\left[a,\,b\right]\)</span> 上连续，且 <span class="math inline">\(f\left(a\right)\cdot f\left(b\right)\lt0\)</span>，则 <span class="math inline">\(\exists\xi\in\left[a,\,b\right]\)</span> 使得<span class="math inline">\(f\left(\xi\right)=0\)</span></p><h4 id="介值定理">介值定理</h4><p>设函数 <span class="math inline">\(f\left(x\right)\)</span> 在闭区间<span class="math inline">\(\left[a,\,b\right]\)</span> 上连续，<span class="math inline">\(f\left(x\right)_{\mathrm{min}}\leq\mu\leqf\left(x\right)_{\mathrm{max}}\)</span>，则 <span class="math inline">\(\exists\xi\in\left[a,\,b\right]\)</span> 使得<span class="math inline">\(f\left(\xi\right)=\mu\)</span></p><h2 id="两个重要极限">两个重要极限</h2><p><span class="math display">\[\lim_{x\to 0}\frac{\sinx}{x}=1\qquad\lim_{x\to\infty}\left(1+\frac{1}{x}\right)^{x}=e\]</span></p><h1 id="导数">导数</h1><p><span class="math display">\[\displaystylef^\prime\left(x_0\right)=\lim_{x\rightarrowx_0}{\frac{f\left(x\right)-f\left(x_0\right)}{x-x_0}}=\lim_{\Deltax\rightarrow0}{\frac{f\left(x_0+\Deltax\right)-f\left(x_0\right)}{\Delta x}}\]</span></p><p>Derivative</p><h2 id="高阶导数">高阶导数</h2><p><span class="math inline">\(Leibniz\)</span> 公式 <span class="math display">\[\left(uv\right)^{\left(n\right)}=\sum_{k=0}^{n}{C_n^ku^{\left(n-k\right)}v^{\left(k\right)}}\]</span></p><h2 id="参数方程求导">参数方程求导</h2><p><span class="math display">\[\frac{dy}{dx}=\frac{\frac{dy}{dt}}{\frac{dx}{dt}}\qquad\frac{d^2y}{dx^2}=\frac{d\left(\frac{dy}{dx}\right)}{dx}=\frac{\frac{d\left(\frac{dy}{dx}\right)}{dt}}{\frac{dx}{dt}}\]</span></p><h2 id="fermat-引理"><span class="math inline">\(Fermat\)</span>引理</h2><p>可导函数的每一个可导的极值点都是驻点</p><blockquote><p>设函数 <span class="math inline">\(f\left(x\right)\)</span> 在点<span class="math inline">\(x_0\)</span> 的某邻域 <span class="math inline">\(U\left(x_0\right)\)</span> 内有定义，并且在 <span class="math inline">\(x_0\)</span> 处可导，如果对<span class="math inline">\(\forall{x\in{U\left(x_0\right)}}\)</span>，有<span class="math inline">\(f\left(x\right)\leqf\left(x_0\right)\)</span>（或<span class="math inline">\(f\left(x\right)\geqf\left(x_0\right)\)</span>），那么<span class="math inline">\(f^\prime\left(x_0\right)=0\)</span></p></blockquote><h2 id="导数的应用">导数的应用</h2><h1 id="微分">微分</h1><p>Differential</p><h2 id="一元函数微分学">一元函数微分学</h2><h3 id="微分中值定理">微分中值定理</h3><h4 id="rolle-中值定理"><span class="math inline">\(Rolle\)</span>中值定理</h4><ul><li><p>条件</p><ul><li>函数 <span class="math inline">\(f\left(x\right)\)</span> 在 <span class="math inline">\(\left[a,\ b\right]\)</span> 上连续</li><li>函数 <span class="math inline">\(f\left(x\right)\)</span> 在 <span class="math inline">\(\left(a,\ b\right)\)</span> 上可导</li><li><span class="math inline">\(f\left(a\right)=f\left(b\right)\)</span></li></ul></li><li><p>结论</p><p><span class="math inline">\(\exists\xi\in\left(a,\,b\right)\)</span>，使得<span class="math inline">\(f^\prime\left(\xi\right)=0\)</span></p></li></ul><h5 id="bulb-题型一多次使用-rolle-中值定理以证明高阶导数为零"><span class="github-emoji"><span>💡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>题型一：多次使用 <span class="math inline">\(Rolle\)</span>中值定理以证明高阶导数为零</h5><p><strong>原理</strong>：证明 <span class="math inline">\(n\)</span>阶导为零需要 <span class="math inline">\(n+1\)</span>个函数值相等的点，使用 <span class="math inline">\(n\)</span> 次 <span class="math inline">\(Rolle\)</span> 中值定理。</p><h5 id="bulb-题型二找到辅助函数-fleftxright-以证明"><span class="github-emoji"><span>💡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>题型二：找到辅助函数 <span class="math inline">\(F\left(x\right)\)</span> 以证明</h5><p><strong>原理</strong>：还原题目所要证明的函数是找到辅助函数的关键。</p><p>常用的还原公式</p><table><thead><tr class="header"><th style="text-align: center;">形式</th><th style="text-align: center;">还原后</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(u^\prime\left(x\right)\pmv^\prime\left(x\right)\)</span></td><td style="text-align: center;"><span class="math inline">\(u\left(x\right)\pm v\left(x\right)\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(u^\prime\left(x\right) v\left(x\right)\pmu\left(x\right)v^\prime\left(x\right)\)</span></td><td style="text-align: center;"><span class="math inline">\(u\left(x\right)v\left(x\right)\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\displaystyle\frac{u^\prime\left(x\right)v\left(x\right)-u\left(x\right)v^\prime\left(x\right)}{v^2\left(x\right)}\)</span></td><td style="text-align: center;"><span class="math inline">\(\displaystyle\frac{u\left(x\right)}{v\left(x\right)}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\displaystyle\frac{u^\prime\left(x\right)}{u\left(x\right)}\)</span></td><td style="text-align: center;"><span class="math inline">\(\lnu\left(x\right)\)</span></td></tr></tbody></table><p>通常题干中要求证明的式子会约去一个因子，利用还原公式和适当地添加公因子就能得到最终的辅助函数。</p><h4 id="lagrange-中值定理"><span class="math inline">\(Lagrange\)</span>中值定理</h4><ul><li><p>条件</p><ul><li>函数 <span class="math inline">\(f\left(x\right)\)</span> 在 <span class="math inline">\(\left[a,\ b\right]\)</span> 上连续</li><li>函数 <span class="math inline">\(f\left(x\right)\)</span> 在 <span class="math inline">\(\left(a,\ b\right)\)</span> 上可导</li></ul></li><li><p>结论</p><p><span class="math inline">\(\exists\xi\in\left(a,\,b\right)\)</span>，使得<span class="math inline">\(\displaystylef^\prime\left(\xi\right)=\frac{f\left(b\right)-f\left(a\right)}{b-a}\)</span>（或 <span class="math inline">\(f\left(b\right)-f\left(a\right)=\left(b-a\right)f^\prime\left(a+\theta\left(b-a\right)\right)\;\left(0\lt\theta\lt1\right)\)</span>）</p></li><li><p>推论</p><p><span class="math display">\[f\left(x\right)\equiv C\Rightarrowf^\prime\left(x\right)\equiv 0\]</span></p></li><li><p>证明</p><p>利用 <span class="math inline">\(Rolle\)</span>中值定理证明。首先应当找到辅助函数，易得 <span class="math inline">\(F\left(x\right)=\left(f\left(b\right)-f\left(a\right)\right)x-\left(b-a\right)f\left(x\right)\)</span>，并有：<span class="math display">\[\left\{\begin{array}{l}F\left(a\right)=af\left(b\right)-bf\left(a\right)\\F\left(b\right)=af\left(b\right)-bf\left(a\right)\end{array}\right.\RightarrowF\left(a\right)=F\left(b\right)\]</span> 又 <span class="math inline">\(\because F\left(x\right)\inC\left[a,\,b\right]\)</span> 且 <span class="math inline">\(F\left(x\right)\)</span> 在 <span class="math inline">\(\left(a,\,b\right)\)</span> 上可导，<span class="math inline">\(\therefore\exists\xi\in\left(a,\ b\right)\)</span>使得 <span class="math inline">\(F^\prime\left(\xi\right)=0\)</span> 即<span class="math inline">\(f\left(b\right)-f\left(a\right)-\left(b-a\right)f^\prime\left(\xi\right)=0\)</span>，移项后得<span class="math inline">\(\displaystylef^\prime\left(\xi\right)=\frac{f\left(b\right)-f\left(a\right)}{b-a}\)</span>，得证。</p></li><li><p>作用</p><ul><li>升高导数的阶数</li><li>化简求极限的过程<ul><li>例：<span class="math inline">\(\displaystyle\lim_{x\to\infty}n^2\left(\arctan\frac\pin-\arctan\frac\pi{n+1}\right)\)</span> = <span class="math inline">\(\displaystyle\lim_{x\to\infty}\frac{\pin^2}{n\left(n+1\right)}\cdot\frac{1}{1+\xi^2}=\pi\lim_{\xi\to0}\frac{1}{1+\xi^2}=\pi\)</span></li></ul></li><li>证明不等式<ul><li>例：证明 <span class="math inline">\(\displaystyle\forall n\in\mathrm{N^+},\,\frac{1}{n+1}\lt\ln{\left(1+\frac{1}{n}\right)}\lt\frac{1}{n}\)</span><br><span class="math inline">\(\displaystyle\ln{1+\frac{1}{n}}=\ln{\frac{n+1}{n}}=\ln{\left(n+1\right)}-\ln{n}\)</span>。令<span class="math inline">\(f\left(x\right)=\ln{x}\)</span>，在 <span class="math inline">\(\left[n,\,n+1\right]\)</span> 上连续，在 <span class="math inline">\(\left(n,\,n+1\right)\)</span> 上可导。故 <span class="math inline">\(\displaystyle\ln{\left(1+\frac{1}{n}\right)}=\left(n+1-n\right)\cdot\frac{1}{\xi}=\frac{1}{\xi},\;\xi\in\left(n,\,n+1\right)\)</span>，从而<span class="math inline">\(\displaystyle\frac{1}{n+1}\lt\frac{1}{\xi}\lt\frac{1}{n}\)</span></li></ul></li></ul></li></ul><h4 id="cauchy-中值定理"><span class="math inline">\(Cauchy\)</span>中值定理</h4><ul><li><p>条件</p><ul><li>函数 <span class="math inline">\(f\left(x\right),\,g\left(x\right)\)</span> 在<span class="math inline">\(\left[a,\ b\right]\)</span> 上连续</li><li>函数 <span class="math inline">\(f\left(x\right),\,g\left(x\right)\)</span> 在<span class="math inline">\(\left[a,\ b\right]\)</span> 在 <span class="math inline">\(\left(a,\ b\right)\)</span> 上可导</li><li><span class="math inline">\(g^\prime\left(x\right)\neq0\)</span></li></ul></li><li><p>结论</p><p><span class="math inline">\(\exists\xi\in\left(a,\,b\right)\)</span>，使得<span class="math inline">\(\displaystyle\frac{f^\prime\left(\xi\right)}{g^\prime\left(\xi\right)}=\frac{f\left(b\right)-f\left(a\right)}{g\left(b\right)-g\left(a\right)}\)</span></p></li><li><p>作用</p><ul><li>证明多中值问题<ol type="1"><li>分离中值</li><li>分别使用 <span class="math inline">\(Lagrange\)</span> 和 <span class="math inline">\(Cauchy\)</span> 中值定理</li></ol>例：函数 <span class="math inline">\(f\left(x\right)\)</span> 在 <span class="math inline">\(\left[a,\,b\right]\)</span> 上连续、在 <span class="math inline">\(\left(a,\,b\right)\)</span> 上可导，且 <span class="math inline">\(f\left(x\right)\neq 0\)</span>，证明 <span class="math inline">\(\exists\xi,\,\eta\in\left(a,\,b\right)\)</span>使得 <span class="math inline">\(\displaystyle\frac{f^\prime\left(\xi\right)}{f^\prime\left(\eta\right)}=\frac{e^b-e^a}{b-a}e^{\eta}\)</span><br>解：[分离中值] <span class="math inline">\(\displaystyle\begin{array}{c}\underbrace{f^\prime\left(\xi\right)}\\{Lagrange}\end{array}=\frac{e^b-e^a}{b-a}\cdot\begin{array}{c}\underbrace{\frac{f^\prime\left(\eta\right)}{e^\eta}}\\{Cauchy}\end{array}\)</span><br>[使用中值定理] 令 <span class="math inline">\(g\left(x\right)=e^x\)</span>，使用 <span class="math inline">\(Cauchy\)</span> 中值定理：<span class="math inline">\(\displaystyle\frac{f\left(b\right)-f\left(a\right)}{g\left(b\right)-g\left(a\right)}=\frac{f^\prime\left(\eta\right)}{e^\eta}\)</span>；使用<span class="math inline">\(Lagrange\)</span> 中值定理：<span class="math inline">\(\displaystylef^\prime\left(\xi\right)=\frac{f\left(b\right)-f\left(a\right)}{b-a}\)</span>。等式右边<span class="math inline">\(=\displaystyle\frac{e^b-e^a}{b-a}\cdot\frac{f\left(b\right)-f\left(a\right)}{e^b-e^a}=\)</span>等式左边，得证。</li></ul></li></ul><h3 id="taylor-公式"><span class="math inline">\(Taylor\)</span>公式</h3><blockquote><p>设函数 <span class="math inline">\(f\left(x\right)\)</span> 在 <span class="math inline">\(\mathring{U}\left(x_0\right)\)</span> 内具有 <span class="math inline">\(n+1\)</span> 阶导数，则：</p><p><span class="math display">\[\begin{array}{c}\displaystylef\left(x\right)=\sum_{i=0}^{n}\frac{f^{\left(i\right)}\left(x_0\right)}{i!}\left(x-x_0\right)^i+R_n\left(x\right)\\=f\left(x_0\right)+f^\prime\left(x_0\right)\left(x-x_0\right)+\frac{f^{\prime\prime}\left(x_0\right)}{2!}\left(x-x_0\right)^2+\cdots+\frac{f^{\left(n\right)}\left(x_0\right)}{n!}\left(x-x_0\right)^n+R_n\left(x\right)\end{array}\]</span></p><p>其中 <span class="math inline">\(R_n\left(x\right)\)</span>称为余项。<span class="math inline">\(R_n\left(x\right)=\left\{\begin{array}{ll}\frac{f^{\left(n+1\right)}\left(\xi\right)}{\left(n+1\right)!}\left(x-x_0\right)^{n+1}&amp;Lagrange\ 余项\\[0.8em] o\left(\left(x-x_0\right)^n\right)&amp;Peano\余项\end{array}\right.\)</span></p></blockquote><p>若 <span class="math inline">\(x_0=0\)</span>，则称该公式为 <span class="math inline">\(Maclaurin\)</span> 公式。</p><p>常用的 <span class="math inline">\(Maclaurin\)</span> 展开式： -<span class="math inline">\(e^x=1+x+\frac{x^2}{2!}+\cdots+\frac{x^n}{n!}+o\left(x^n\right)\)</span></p><h2 id="多元函数微分学">多元函数微分学</h2><h3 id="多元隐函数求偏导">多元隐函数求偏导</h3><p><span class="math display">\[\frac{\partial z}{\partialx}=-\frac{F_x}{F_z}\]</span></p><h3 id="方向导数与梯度">方向导数与梯度</h3><p><span class="math display">\[\nabla=\left(\frac{\partial f}{\partialx},\,\frac{\partial f}{\partial y},\,\frac{\partial f}{\partialz}\right)\]</span></p><h3 id="应用">应用</h3><h4 id="利用判别式法求解无条件极值">利用判别式法求解无条件极值</h4><p>设函数 <span class="math inline">\(z=f(x,\,y)\)</span> 在点 <span class="math inline">\((x_0,\,y_0)\)</span> 处具有偏导数且有极值，则<span class="math inline">\(\left\{\begin{array}{l}f_x(x_0,\,y_0)=0\\f_y(x_0,\,y_0)=0\end{array}\right.\)</span></p><p>令 <span class="math inline">\(f_{xx}^{\prime\prime}(x_0,\,y_0)=A,\,f_{xy}^{\prime\prime}(x_0,\,y_0)=B,\,f_{yy}^{\prime\prime}(x_0,\,y_0)=C\)</span></p><ul><li><span class="math inline">\(AC-B^2\gt 0\)</span> 时具有极值，且<span class="math inline">\(A\lt 0\)</span> 时取得极大值；<span class="math inline">\(A\gt 0\)</span> 时取得极小值</li><li><span class="math inline">\(AC-B^2\lt 0\)</span> 时没有极值</li><li><span class="math inline">\(AC-B^2=0\)</span> 无法判断</li></ul><h4 id="利用-lagrange-乘数法求解条件极值">利用 <span class="math inline">\(Lagrange\)</span> 乘数法求解条件极值</h4><h1 id="积分">积分</h1><h2 id="定积分">定积分</h2><p>设函数 <span class="math inline">\(f\left(x\right)\)</span> 在 <span class="math inline">\(\left[a,b\right]\)</span> 上有界。</p><ol type="1"><li><p>取 <span class="math inline">\(a=x_0&lt;x_1&lt;\cdots&lt;x_n=b\)</span></p><ul><li><span class="math inline">\(\left[a,b\right]=\left[x_0,x_1\right]\cup\left[x_1,x_2\right]\cup\cdots\cup\left[x_{n-1},x_n\right]\)</span></li><li><span class="math inline">\(\Delta x_i=x_i-x_{i-1}\\left(i\in\left[1,n\right]\right)\)</span></li></ul></li><li><p>任取 <span class="math inline">\(\xi_i\in\left[x_{i-1},x_i\right]\)</span>，求和<span class="math inline">\(\sum_{i=1}^{n}{f\left(\xi_i\right)\Deltax_i}\)</span></p></li><li><p>取 <span class="math inline">\(\displaystyle\lambda=\max_{1\lei\le n}{\left\{\Delta x_i\right\}}\)</span></p></li><li><p>若 <span class="math inline">\(\displaystyle\lim_{\lambda\rightarrow0}{\sum_{i=1}^{n}{f\left(\xi_i\right)\Deltax_i}}\)</span> 存在，则其为 <span class="math inline">\(f\left(x\right)\)</span> 在 <span class="math inline">\(\left[a,b\right]\)</span>上的定积分（Integral），即： <span class="math display">\[\int_{a}^{b}f\left(x\right)dx=\lim_{\lambda\rightarrow0}{\sum_{i=1}^{n}{f\left(\xi_i\right)\Deltax_i}}\]</span></p></li></ol><p>定积分的诸性质：</p><ul><li>若 <span class="math inline">\(f\left(x\right)\geq0\)</span>（<span class="math inline">\(a\le x\le b\)</span>），则 <span class="math inline">\(\displaystyle\int_{a}^{b}f\left(x\right)dx\geq0\)</span></li><li>若 <span class="math inline">\(f\left(x\right)\geqg\left(x\right)\)</span>（<span class="math inline">\(a\le x\leb\)</span>），则 <span class="math inline">\(\displaystyle\int_{a}^{b}f\left(x\right)dx\geq\int_{a}^{b}g\left(x\right)dx\)</span></li><li>若 <span class="math inline">\(f\left(x\right)\)</span>、<span class="math inline">\(\left|f\left(x\right)\right|\)</span> 在 <span class="math inline">\(\left[a,\ \ b\right]\)</span> 上可积，则 <span class="math inline">\(\displaystyle\left|\int_{a}^{b}f\left(x\right)dx\right|\le\int_{a}^{b}\left|f\left(x\right)\right|dx\)</span></li></ul><h3 id="积分中值定理">积分中值定理</h3><blockquote><p>设 <span class="math inline">\(f\left(x\right)\in{C\left[a,\,b\right]}\)</span>，则<span class="math inline">\(\exists\xi\in\left[a,\,b\right]\)</span>，使得<span class="math inline">\(\displaystyle\int_{a}^{b}f\left(x\right)dx=f\left(\xi\right)\left(b-a\right)\)</span></p></blockquote><ul><li><p><em>证明</em></p><p><span class="math inline">\(\becausef\left(x\right)\in{C\left[a,\,b\right]},\,\therefore\exists{M=f(x)_{\max},\,m=f(x)_{\min}}\)</span>，使得<span class="math inline">\(m\leq f(x)\leq M\)</span>。<br>对等式两边取在 <span class="math inline">\(\left[a,\,b\right]\)</span>上的定积分：<span class="math inline">\(\displaystyle\int_{a}^{b}m\leq\int_{a}^{b}f\left(x\right)dx\leq\int_{a}^{b}M\Rightarrow\)</span><br><span class="math inline">\(\displaystylem\leq\frac{1}{b-a}\int_{a}^{b}f\left(x\right)dx\leq M\)</span>。<br>（介值定理）<span class="math inline">\(\therefore\exists\xi\in\left[a,\,b\right]\)</span>，使得<span class="math inline">\(\displaystyle\frac{1}{b-a}\int_{a}^{b}f\left(x\right)dx=f\left(\xi\right)\)</span></p></li><li><p>用途：在被积函数 <strong>连续</strong>的情况下，去掉积分号</p></li></ul><h3 id="积分上限函数">积分上限函数</h3><p>设 <span class="math inline">\(f\left(x\right)\inC\left[a,b\right]\)</span>，<span class="math inline">\(\Phi\left(x\right)=\int_{a}^{x}f\left(t\right)dt\)</span>，则<span class="math inline">\(\frac{d}{dx}\Phi\left(x\right)=f\left(x\right)\)</span>，即<span class="math inline">\(\Phi^\prime\left(x\right)=f\left(x\right)\)</span>。</p><p>积分上限函数的诸性质</p><ul><li><span class="math inline">\(\displaystyle\frac{d}{dx}\int_{a}^{x}{f(t)dt}=f\left(x\right)\)</span></li><li><span class="math inline">\(\displaystyle\frac{d}{dx}\int_{a}^{\varphi\left(x\right)}f\left(t\right)dt=f\left(\varphi\left(x\right)\right)\cdot\varphi^\prime\left(x\right)\)</span></li><li><span class="math inline">\(\displaystyle\frac{d}{dx}\int_{\varphi_1\left(x\right)}^{\varphi_2\left(x\right)}{f(t)dt}=f\left(\varphi_2\left(x\right)\right)\varphi_2^\prime\left(x\right)-f\left(\varphi_1\left(x\right)\right)\varphi_1^\prime\left(x\right)\)</span></li></ul><h3 id="函数的定积分性质">函数的定积分性质</h3><h4 id="周期函数">周期函数</h4><h4 id="三角函数">三角函数</h4><p><span class="math display">\[\int_0^{\frac\pi2}f\left(\sin x,\,\cosx\right)=\int_0^{\frac\pi2}f\left(\cos x,\,\sin x\right)\]</span></p><h5 id="wallis-公式"><span class="math inline">\(Wallis\)</span>公式</h5><p><span class="math display">\[\int_0^{\frac\pi2}\sin^nx=\int_0^{\frac\pi2}\cos^nx=\begin{cases}\frac{n-1}{n}\cdot\frac{n-3}{n-2}\cdots\frac23\cdot1&amp;n\,为奇数\\\frac{n-1}{n}\cdot\frac{n-3}{n-2}\cdots\frac12\cdot\frac\pi2&amp;n\,为偶数\end{cases}\]</span></p><h3 id="定积分的应用">定积分的应用</h3><p>利用微元法求解面积、体积的步骤：</p><ol type="1"><li>确定积分变量及其取值区间</li><li>任取区间 <span class="math inline">\(\left[x,\,x+dx\right]\)</span>，求出该区间对应的微元表达式</li><li>求积分</li></ol><h2 id="多元函数积分学">多元函数积分学</h2><h3 id="二重积分">二重积分</h3><p><span class="math display">\[\iint\limits_{D}{f\left(x,\,y\right)d\sigma}=\lim_{\lambda\to0}{\sum_{i=1}^{n}f\left(\xi_i,\,\eta_i\right)\Delta\sigma_i}\]</span>其中 <span class="math inline">\(f\left(x,\,y\right)\)</span>是被积函数；<span class="math inline">\(f\left(x,\,y\right)d\sigma\)</span>是被积表达式；<span class="math inline">\(d\sigma\)</span>是面积元素；<span class="math inline">\(x,\,y\)</span> 是积分变量；<span class="math inline">\(D\)</span> 是积分区域；<span class="math inline">\(\displaystyle\sum_{i=1}^{n}f\left(\xi_i,\,\eta_i\right)\Delta\sigma_i\)</span>是积分和。</p><p>在直角坐标系下的面积元素 <span class="math inline">\(d\sigma\)</span>可写为 <span class="math inline">\(dxdy\)</span></p><h3 id="三重积分">三重积分</h3><p><span class="math display">\[\iiint\limits_{D}{f\left(x,\,y,\,z\right)dv}\]</span></p><h4 id="计算方法">计算方法</h4><ol type="1"><li><p>直角坐标</p><ol type="1"><li>切片法（先一后二）</li><li>投影法（先二后一）</li></ol></li><li><p>柱坐标</p></li><li><p>球坐标</p><p><span class="math display">\[\left\{\begin{align*}x&amp;=r\sin\varphi\cos\theta,&amp;0\leqr\lt+\infty\\y&amp;=r\sin\varphi\sin\theta,&amp;0\leq\varphi\leq2\pi\\z&amp;=r\cos\varphi,&amp;0\leq\theta\leq2\pi\end{align*}\right.\]</span></p><p><span class="math display">\[dv=r^2 \sin\varphi drd\varphid\theta\]</span></p></li></ol><h4 id="应用-1">应用</h4><ol type="1"><li><p>空间几何体的重心（质心）及形心 设空间几何体 <span class="math inline">\(\Omega\)</span> 体密度为 <span class="math inline">\(\rho(x,\,y,\,z)\)</span>，则其重心（质心）坐标公式为<span class="math display">\[\bar{x}=\dfrac{\iiint\limits_{\Omega}x\rho(x,\,y,\,z)dv}{\iiint\limits_{\Omega}\rho(x,\,y,\,z)dv},\;\bar{y}=\dfrac{\iiint\limits_{\Omega}y\rho(x,\,y,\,z)dv}{\iiint\limits_{\Omega}\rho(x,\,y,\,z)dv},\;\bar{z}=\dfrac{\iiint\limits_{\Omega}z\rho(x,\,y,\,z)dv}{\iiint\limits_{\Omega}\rho(x,\,y,\,z)dv}\]</span>当 <span class="math inline">\(\rho(x,\,y,\,z)\equiv 1\)</span> 时，得到<span class="math inline">\(\Omega\)</span> 的形心坐标公式为 <span class="math display">\[\bar{x}=\dfrac{\iiint\limits_{\Omega}xdv}{\iiint\limits_{\Omega}dv},\;\bar{y}=\dfrac{\iiint\limits_{\Omega}ydv}{\iiint\limits_{\Omega}dv},\;\bar{z}=\dfrac{\iiint\limits_{\Omega}zdv}{\iiint\limits_{\Omega}dv}\]</span></p></li><li><p>空间几何体 <span class="math inline">\(\Omega\)</span> 的转动惯量设空间几何体 <span class="math inline">\(\Omega\)</span> 体密度为 <span class="math inline">\(\rho(x,\,y,\,z)\)</span>，则其对于 <span class="math inline">\(x\)</span> 轴、<span class="math inline">\(y\)</span> 轴、<span class="math inline">\(z\)</span> 轴及原点 <span class="math inline">\(O\)</span> 的转动惯量分别为 <span class="math display">\[I_x=\iiint\limits_{\Omega}\left(y^2+z^2\right)\rho(x,\,y,\,z)dv\]</span></p><p><span class="math display">\[I_y=\iiint\limits_{\Omega}\left(x^2+z^2\right)\rho(x,\,y,\,z)dv\]</span><span class="math display">\[I_z=\iiint\limits_{\Omega}\left(x^2+y^2\right)\rho(x,\,y,\,z)dv\]</span><span class="math display">\[I_O=\iiint\limits_{\Omega}\left(x^2+y^2+z^2\right)\rho(x,\,y,\,z)dv\]</span></p></li></ol><h3 id="曲线积分">曲线积分</h3><h4 id="对弧长的曲线积分第一类">对弧长的曲线积分（第一类）</h4><ol type="1"><li><p>化简</p><ul><li>利用对称性化简</li><li>将曲线 <span class="math inline">\(L\)</span>的方程代入被积函数化简</li><li>利用形心公式化简</li></ul></li><li><p>计算</p><ul><li><span class="math inline">\(L:\, y=y(x),\;x\in\left[a,\,b\right]\)</span> <span class="math display">\[\int_L{\rho(x,\,y)ds}=\int_a^b\rho(x,\,y(x))\sqrt{1+y^\prime(x)^2}dx\]</span></li><li><span class="math inline">\(L:\,\left\{\begin{array}{l}x=x(t)\\y=y(t)\end{array}\right. t\in\left[\alpha,\,\beta\right]\)</span> <span class="math display">\[\int_L{\rho(x,\,y)ds}=\int_\alpha^\beta\rho(x(t),\,y(t))\sqrt{x^\prime(t)^2+y^\prime(t)^2}dt\]</span></li></ul></li></ol><h4 id="对坐标的曲线积分第二类">对坐标的曲线积分（第二类）</h4><p>计算方法：</p><ol type="1"><li><p><span class="math inline">\(\displaystyle\int_{L:\;y=y(x)}P(x,\,y)dx+Q(x,\,y)dy\)</span>其中 <span class="math inline">\(x:\; a\to b\)</span> 则原式 <span class="math inline">\(=\)</span></p><p><span class="math display">\[\int_a^b{P(x,\,y(x))dx+Q(x,\,y(x))y^\prime(x)dx}\]</span></p></li><li><p><span class="math inline">\(\displaystyleL:\,\left\{\begin{array}{l}x=x(t)\\y=y(t)\end{array}\right.\int_{L}P(x,\,y)dx+Q(x,\,y)dy\)</span> 其中<span class="math inline">\(t:\;\alpha\to\beta\)</span> 则原式 <span class="math inline">\(=\)</span></p><p><span class="math display">\[\int_\alpha^\beta{\left[P\left(x\left(t\right),\,y\left(t\right)\right)x^\prime(t)+Q\left(x\left(t\right),\,y\left(t\right)\right)y^\prime(t)\right]dx}\]</span></p></li></ol><p>平面第二型曲线积分与路径无关的理论：</p><p>若 <span class="math inline">\(\dfrac{\partial Q}{\partialx}\equiv\dfrac{\partial P}{\partial y}\)</span>，则有：</p><ol type="1"><li><span class="math inline">\(\displaystyle\int_{L}P(x,\,y)dx+Q(x,\,y)dy\)</span><span class="math inline">\(=\)</span><span class="math inline">\(\displaystyle\int_{\left(x_1,\,y_1\right)}^{\left(x_2,\,y_2\right)}P(x,\,y)dx+Q(x,\,y)dy\)</span><span class="math inline">\(=\)</span><span class="math inline">\(\displaystyle\int_{x_1}^{x_2}P(x,\,y)dx+\int_{y_1}^{y_2}Q(x,\,y)dy\)</span></li></ol><h5 id="green-公式"><span class="math inline">\(Green\)</span> 公式</h5><p><span class="math display">\[\oint_LP(x,y)dx+Q(x,y)dy=\iint\limits_{D}\left(\frac{\partial Q}{\partialx}-\frac{\partial P}{\partial y}\right)d\sigma\]</span> 其中 <span class="math inline">\(D\)</span> 为封闭曲线 <span class="math inline">\(L\)</span>围成的区域（如果出现不可导点则用绕线法）</p><h5 id="stokes-公式"><span class="math inline">\(Stokes\)</span>公式</h5><p><span class="math display">\[\oint_LPdx+Qdy+Rdz=\iint\limits_\Sigma\begin{vmatrix}\cos\alpha&amp;\cos\beta&amp;\cos\theta\\\frac{\partial}{\partialx}&amp;\frac{\partial}{\partial y}&amp;\frac{\partial}{\partialz}\\P&amp;Q&amp;R\end{vmatrix}dS\]</span></p><h3 id="曲面积分">曲面积分</h3><pre><code class=" mermaid">flowchart TB; l(曲线积分)---gr(Green 公式) &amp; st(Stokes 公式) p(曲面积分)---ga(Gauss 公式) st --&gt; |特例|ga st --&gt; |投影|gr</code></pre><h4 id="对面积的曲面积分第一类">对面积的曲面积分（第一类）</h4><p>计算方法：</p><p>投影法（将曲面 <span class="math inline">\(\Sigma\)</span> 向 <span class="math inline">\(xOy\)</span> 投影得到平面区域 <span class="math inline">\(D_{xy}\)</span>）</p><p><span class="math display">\[\iint\limits_{\Sigma:\;z=z(x,y)}{\rho(x,\,y,\,z)dS}=\iint\limits_{D_{xy}}{\rho(x,\,y,\,z(x,\,y))\sqrt{1+{z_x^\prime}^2+{z_y^\prime}^2}dS}\]</span></p><h4 id="对坐标的曲面积分第二类">对坐标的曲面积分（第二类）</h4><p>计算方法：</p><ol type="1"><li><p>转换成第一类曲面积分</p><p><span class="math display">\[\displaystyle\iint_\SigmaPdydz+Qdzdx+Rdxdy=\iint_\Sigma(P\cos\alpha+Q\cos\beta+R\cos\gamma)dS\]</span>其中 <span class="math inline">\(\cos\alpha,\,\cos\beta,\,\cos\gamma\)</span>是曲面 <span class="math inline">\(\Sigma\)</span> 的方向余弦</p></li><li><p>转换成二重积分计算</p><p>设曲面 <span class="math inline">\(\Sigma:\;z=z(x,\,y)\)</span>，<span class="math inline">\(\Sigma\)</span> 在 <span class="math inline">\(xOy\)</span> 平面上的投影区域为 <span class="math inline">\(D_{xy}\)</span>，<span class="math inline">\(\Sigma\)</span> 的法向量与 <span class="math inline">\(z\)</span> 正半轴夹角为 <span class="math inline">\(\varphi\)</span>，则有：</p><p><span class="math display">\[\iint_\SigmaP(x,\,y,\,z)dydz=\pm\iint_{D_{xy}}{P(x,\,y,\,z(x,y))\left(-\dfrac{\partial{z}}{\partial{x}}\right)dxdy}\]</span></p></li><li><p>转换成三重积分计算（<span class="math inline">\(Gauss\)</span>公式）</p></li></ol><h5 id="gauss-公式"><span class="math inline">\(Gauss\)</span> 公式</h5><p><span class="math display">\[\oiint_\SigmaPdydz+Qdzdx+Rdxdy=\iiint_\Omega\left(\frac{\partial P}{\partialx}+\frac{\partial Q}{\partial y}+\frac{\partial R}{\partialz}\right)dv\]</span></p><h1 id="无穷级数">无穷级数</h1><p>Infinite Series</p><h2 id="数项级数">数项级数</h2><p>常见级数的敛散性</p><table><thead><tr class="header"><th style="text-align: center;">名称</th><th style="text-align: center;">表达式</th><th style="text-align: center;">敛散性</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(p-\)</span>级数</td><td style="text-align: center;"><span class="math inline">\(\displaystyle\sum_{i=1}^\infty\dfrac{1}{n^p}\)</span></td><td style="text-align: center;"><span class="math inline">\(\begin{array}{ll}p\gt1&amp;收敛\\p\leq1&amp;发散\end{array}\)</span></td></tr></tbody></table><h3 id="比较审敛法">比较审敛法</h3><p>设级数 <span class="math inline">\(\displaystyle\sum_{i=1}^\inftyu_n\)</span> 和 <span class="math inline">\(\displaystyle\sum_{i=1}^\infty v_n\)</span>都是正项级数，且 <span class="math inline">\(u_n\leqv_n\;\left(n=1,\,2,\,\cdots\right)\)</span></p><ol type="1"><li>若 <span class="math inline">\(\displaystyle\sum_{i=1}^\inftyv_n\)</span> 收敛，则 <span class="math inline">\(\displaystyle\sum_{i=1}^\infty u_n\)</span>收敛</li><li>若 <span class="math inline">\(\displaystyle\sum_{i=1}^\inftyu_n\)</span> 发散，则 <span class="math inline">\(\displaystyle\sum_{i=1}^\infty v_n\)</span>发散</li></ol><p><span class="github-emoji"><span>📓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4d3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 常用放缩，放大求证收敛；缩小求证发散。</p><h3 id="比值审敛法">比值审敛法</h3><p>设级数 <span class="math inline">\(\displaystyle\sum_{i=1}^\inftyu_n\)</span> 是正项级数，若其后项与前项之比值的极限等于 <span class="math inline">\(\rho\)</span>，即 <span class="math inline">\(\displaystyle\lim_{n\to\infty}\dfrac{u_{n+1}}{u_n}=\rho\)</span>，则1. 若 <span class="math inline">\(p\lt1\)</span>，级数收敛； 2. 若 <span class="math inline">\(p\gt1\)</span>，级数发散； 3. 若 <span class="math inline">\(p=1\)</span>，敛散性未知。</p><h3 id="根值审敛法">根值审敛法</h3><p>设级数 <span class="math inline">\(\displaystyle\sum_{i=1}^\inftyu_n\)</span> 是正项级数，若 <span class="math inline">\(\displaystyle\lim_{n\to\infty}\sqrt[n]{u_n}=\rho\)</span>，则1. 若 <span class="math inline">\(p\lt1\)</span>，级数收敛； 2. 若 <span class="math inline">\(p\gt1\)</span>，级数发散； 3. 若 <span class="math inline">\(p=1\)</span>，敛散性未知。</p><h3 id="交错级数及其审敛法">交错级数及其审敛法</h3><h4 id="莱布尼茨定理">莱布尼茨定理</h4><p>如果交错级数满足条件：</p><ol type="1"><li>数列 <span class="math inline">\(\left\{u_n\right\}\)</span>单调减少，即 <span class="math inline">\(u_n\gequ_{n+1}\;\left(n=1,\,2,\,\cdots\right)\)</span></li><li><span class="math inline">\(\displaystyle\lim_{n\to\infty}u_n=0\)</span></li></ol><p>则级数收敛，且其和 <span class="math inline">\(s\lequ_1\)</span>，其余项 <span class="math inline">\(r_n\)</span> 的绝对值<span class="math inline">\(\left|r_n\right|\leq u_{n+1}\)</span></p><h2 id="幂级数">幂级数</h2><p>一般形式：<span class="math inline">\(\displaystyle\sum_{n=0}^\inftya_n \left(x-x_0\right)^n\)</span></p><p>标准形式：<span class="math inline">\(\displaystyle\sum_{n=0}^\inftya_n x^n\)</span></p><h3 id="abel-定理"><span class="math inline">\(Abel\)</span> 定理</h3><ul><li>若当 <span class="math inline">\(x_0\ne 0\)</span> 时，<span class="math inline">\(\displaystyle\sum_{n=0}^\infty a_n x_0^n\)</span>若收敛，则 <span class="math inline">\(\displaystyle\sum_{n=0}^\inftya_n x^n\)</span> 在 <span class="math inline">\(\left(-\left|x_0\right|,\,\left|x_0\right|\right)\)</span>绝对收敛；</li><li>若当 <span class="math inline">\(x_1\ne 0\)</span> 时，<span class="math inline">\(\displaystyle\sum_{n=0}^\infty a_n x_1^n\)</span>若发散，则 <span class="math inline">\(\displaystyle\sum_{n=0}^\inftya_n x^n\)</span> 在 <span class="math inline">\(\left(-\infty,\,-\left|x_0\right|\right)\cup\left(\left|x_0\right|,\,+\infty\right)\)</span>发散；</li></ul><p><span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 必存在 <span class="math inline">\(R\ge 0\)</span>，使得<span class="math inline">\(x\in\left(-R,\,R\right)\)</span> 时，<span class="math inline">\(\displaystyle\sum_{n=0}^\infty a_n x^n\)</span>绝对收敛；<span class="math inline">\(\left(-\infty,\,-R\right)\cup\left(R,\,+\infty\right)\)</span>时，<span class="math inline">\(\displaystyle\sum_{n=0}^\infty a_nx^n\)</span> 发散； <span class="math inline">\(x=\pm R\)</span>时，<strong>需要将端点值代入</strong>到 <span class="math inline">\(\displaystyle\sum_{n=0}^\infty a_n x^n\)</span>中以判别其敛散性。</p><h4 id="求幂级数收敛半径的方法">求幂级数收敛半径的方法</h4><p>方法一（缺有限项时可用）： <span class="math display">\[\left.\begin{array}{r}\displaystyle\lim_{n\to\infty}\left|\dfrac{a_{n+1}}{a_n}\right|=\rho\\[12pt]\displaystyle\lim_{n\to\infty}\sqrt[n]{\left|a_n\right|}=\rho\end{array}\right\}\Rightarrow\begin{cases}0\lt\rho\lt+\infty&amp;R=\dfrac{1}{\rho}\\\rho=0&amp;R=+\infty\\\rho=+\infty&amp;R=0\end{cases}\]</span></p><p>方法二（对于任意形式的幂级数皆可用）： <span class="math display">\[\lim_{n\to\infty}\left|\dfrac{u_{n+1}(x)}{u_{n}(x)}\right|=\rho(x)\overset{\text{令}}{\lt}1\]</span>解得 <span class="math inline">\(x\in(a,\,b)\)</span>，收敛半径即 <span class="math inline">\(R=\dfrac{b-a}{2}\)</span></p><h3 id="幂级数展开">幂级数展开</h3><p>无论是将函数展开成幂级数还是将幂级数求和，都可以有如下方法：</p><ol type="1"><li><p>套用公式（见下表）或经过变形后再套用公式；</p></li><li><p>先导后积或先积后导</p><ul><li><span class="math inline">\(f(x)=\displaystyle\int_{0}^{x}f^\prime(t)dt+f(0)\)</span></li></ul></li></ol><h4 id="常用的幂级数展开公式">常用的幂级数展开公式</h4><table><thead><tr class="header"><th style="text-align: center;">展开式</th><th style="text-align: center;">收敛半径</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\displaystylee^x=\sum_{n=0}^\infty\dfrac{x^n}{n!}\)</span></td><td style="text-align: center;"><span class="math inline">\(-\infty\ltx\lt +\infty\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\displaystyle\dfrac{1}{1+x}=\sum_{n=0}^\infty\left(-1\right)^n x^n\)</span></td><td style="text-align: center;"><span class="math inline">\(-1\lt x\lt1\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\displaystyle\dfrac{1}{1-x}=\sum_{n=0}^\inftyx^n\)</span></td><td style="text-align: center;"><span class="math inline">\(-1\lt x\lt1\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\displaystyle\sin{x}=\sum_{n=0}^\infty\left(-1\right)^n\dfrac{x^{2n+1}}{(2n+1)!}\)</span></td><td style="text-align: center;"><span class="math inline">\(-\infty\ltx\lt +\infty\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\displaystyle\cos{x}=\sum_{n=0}^\infty\left(-1\right)^n\dfrac{x^{2n}}{(2n)!}\)</span></td><td style="text-align: center;"><span class="math inline">\(-\infty\ltx\lt +\infty\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\displaystyle\ln\left(1+x\right)=\sum_{n=1}^\infty\dfrac{\left(-1\right)^{n-1}}{n}x^n\)</span></td><td style="text-align: center;"><span class="math inline">\(-1\lt x\le1\)</span></td></tr></tbody></table><h2 id="fourier-级数"><span class="math inline">\(Fourier\)</span>级数</h2><p><span class="math display">\[f\left(x\right)=\dfrac{a_0}{2}+\sum_{k=1}^\infty\left(a_k\cos\dfrac{k\pix}{l}+b_k\sin \dfrac{k\pi x}{l}\right)\]</span> <span class="math display">\[\begin{align*}a_0&amp;=\dfrac{1}{l}\int_{-l}^{l}f(x)dx\\a_k&amp;=\dfrac{1}{l}\int_{-l}^{l}f\left(x\right)\cos\dfrac{k\pix}{l}dx\quad\left(k=0,\,1,\,2,\,\cdots\right)\\b_k&amp;=\dfrac{1}{l}\int_{-l}^{l}f\left(x\right)\sin\dfrac{k\pix}{l}dx\quad\left(k=1,\,2,\,3,\,\cdots\right)\end{align*}\]</span></p><p>记 <span class="math inline">\(Fourier\)</span> 级数为 <span class="math inline">\(S(x)\)</span>，则</p><ol type="1"><li>若 <span class="math inline">\(x_0\)</span> 为 <span class="math inline">\(f(x)\)</span> 的连续点，则 <span class="math inline">\(S(x_0)=f(x_0)\)</span>；</li><li>若 <span class="math inline">\(x_0\)</span> 为 <span class="math inline">\(f(x)\)</span> 的间断点，则 <span class="math inline">\(S(x_0)=\dfrac{f_-(x_0)+f_+(x_0)}{2}\)</span></li></ol><p>奇偶函数的 <span class="math inline">\(Fourier\)</span> 级数：</p><ul><li><strong>正弦级数</strong>：设 <span class="math inline">\(f(x)\)</span> 是周期为 <span class="math inline">\(2l\)</span> 的奇函数，且满足 <span class="math inline">\(Dirichlet\)</span> 收敛定理，则其 <span class="math inline">\(Fourier\)</span> 级数为 <span class="math inline">\(S(x)=\displaystyle\sum_{n=1}^\inftyb_n\cdot\sin{\dfrac{n\pi x}{l}}\)</span></li><li><strong>余弦级数</strong>：设 <span class="math inline">\(f(x)\)</span> 是周期为 <span class="math inline">\(2l\)</span> 的偶函数，且满足 <span class="math inline">\(Dirichlet\)</span> 收敛定理，则其 <span class="math inline">\(Fourier\)</span> 级数为 <span class="math inline">\(S(x)=\dfrac{a_0}{2}+\displaystyle\sum_{n=1}^\inftya_n\cdot\cos{\dfrac{n\pi x}{l}}\)</span></li></ul><h1 id="向量代数与空间解析几何">向量代数与空间解析几何</h1><h2 id="向量及其线性运算">向量及其线性运算</h2><h3 id="方向角与方向余弦">方向角与方向余弦</h3><p>记向量 <span class="math inline">\(\vec{v}=\left(x,\,y,\,z\right)\)</span>，并记与<span class="math inline">\(x,\,y,\,z\)</span> 正半轴所形成的角分别为<span class="math inline">\(\alpha,\,\beta,\,\gamma\)</span>，则有：<span class="math display">\[\begin{array}{c}\cos\alpha=\displaystyle\frac{x}{\sqrt{x^2+y^2+z^2}} \\[1.5em]\cos\beta=\displaystyle\frac{y}{\sqrt{x^2+y^2+z^2}} \\[1.5em]\cos\gamma=\displaystyle\frac{z}{\sqrt{x^2+y^2+z^2}} \\\end{array}\]</span></p><p><span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 注意： - 若 <span class="math inline">\(\vec{v}\)</span>在第一卦限，则 <span class="math inline">\(\alpha,\,\beta,\,\gamma\)</span> 皆为锐角。 - 向量<span class="math inline">\(\left(\cos\alpha,\,\cos\beta,\,\cos\gamma\right)\)</span>是与向量 <span class="math inline">\(\vec{v}\)</span> 同向的单位向量。 -如果求得单位向量更方便，则可以利用单位向量与方向余弦向量的关系直接求解方向余弦。</p><h3 id="向量在轴上的投影">向量在轴上的投影</h3><p>过 <span class="math inline">\(M\)</span> 点作与 <span class="math inline">\(u\)</span> 轴相垂直的平面 <span class="math inline">\(\pi\)</span>，<span class="math inline">\(\pi\)</span> 与 <span class="math inline">\(u\)</span> 轴交点记为 <span class="math inline">\(M^\prime\)</span>（点 <span class="math inline">\(M\)</span> 在 <span class="math inline">\(u\)</span> 轴上的投影）；<span class="math inline">\(\overrightarrow{OM^\prime}\)</span> 是 <span class="math inline">\(\overrightarrow{OM}\)</span> 在 <span class="math inline">\(u\)</span> 轴上的分向量。由于 <span class="math inline">\(\overrightarrow{OM^\prime}\)</span> 同 <span class="math inline">\(u\)</span> 轴的单位向量 <span class="math inline">\(\hat{e}\)</span> 平行，故 <span class="math inline">\(\overrightarrow{OM^\prime}=\lambda\hat{e}\)</span>，<span class="math inline">\(\lambda\)</span> 就是 <span class="math inline">\(\overrightarrow{OM}\)</span> 在 <span class="math inline">\(u\)</span>轴上的投影（<strong>是一个数而不是向量</strong>），记作： <span class="math display">\[\mathrm{prj}_{u}\overrightarrow{OM}\;或\;\left(\overrightarrow{OM}\right)_u\]</span></p><p>性质： 1. <span class="math inline">\(\mathrm{prj}_{u}\overrightarrow{OM}=\left|\overrightarrow{OM}\right|\cos\varphi\quad\left(\varphi\in\left[0,\,\pi\right]\right)\)</span>2. <span class="math inline">\(\mathrm{prj}_{u}\left(\vec{a}+\vec{b}\right)=\mathrm{prj}_{u}\vec{a}+\mathrm{prj}_{u}\vec{b}\)</span>3. <span class="math inline">\(\mathrm{prj}_{u}\lambda\vec{a}=\lambda\cdot\mathrm{prj}_{u}\vec{a}\)</span></p><h3 id="向量的积">向量的积</h3><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">数量积</th><th style="text-align: center;">向量积</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">定义</td><td style="text-align: center;"><span class="math inline">\(\vec{a}\cdot\vec{b}=\begin{vmatrix}\vec{a}\end{vmatrix}\begin{vmatrix}\vec{b}\end{vmatrix}\cos\theta\)</span></td><td style="text-align: center;"><span class="math inline">\(\vec{a}\times\vec{b}=\begin{vmatrix}\vec{a}\end{vmatrix}\begin{vmatrix}\vec{b}\end{vmatrix}\sin\theta\)</span></td></tr><tr class="even"><td style="text-align: center;">交换律</td><td style="text-align: center;"><span class="math inline">\(\vec{a}\cdot\vec{b}=\vec{b}\cdot\vec{a}\)</span></td><td style="text-align: center;"><span class="math inline">\(a\times\vec{b}=-\vec{b}\times\vec{a}\)</span></td></tr><tr class="odd"><td style="text-align: center;">分配律</td><td style="text-align: center;"><span class="math inline">\(\left(\vec{a}+\vec{b}\right)\cdot\vec{c}=\vec{a}\cdot\vec{c}+\vec{b}\cdot\vec{c}\)</span></td><td style="text-align: center;"><span class="math inline">\(\left(\vec{a}+\vec{b}\right)\times\vec{c}=\vec{a}\times\vec{c}+\vec{b}\times\vec{c}\)</span></td></tr><tr class="even"><td style="text-align: center;">自乘</td><td style="text-align: center;"><span class="math inline">\(\vec{a}\cdot\vec{a}=\begin{vmatrix}\vec{a}\end{vmatrix}^2\)</span></td><td style="text-align: center;"><span class="math inline">\(\vec{a}\times\vec{a}=\vec{0}\)</span></td></tr><tr class="odd"><td style="text-align: center;">零积</td><td style="text-align: center;"><span class="math inline">\(\vec{a}\cdot\vec{b}=0\Leftrightarrow\vec{a}\bot\vec{b}\)</span></td><td style="text-align: center;"><span class="math inline">\(\vec{a}\times\vec{b}=\vec{0}\Leftrightarrow\vec{a}\parallel\vec{b}\)</span></td></tr><tr class="even"><td style="text-align: center;">代数描述</td><td style="text-align: center;"><span class="math inline">\(\vec{a}^T\cdot\vec{b}\)</span></td><td style="text-align: center;"><span class="math inline">\(\begin{vmatrix}\hat{i}&amp;\hat{j}&amp;\hat{k}\\x_1&amp;y_1&amp;z_1\\x_2&amp;y_2&amp;z_2\end{vmatrix}\)</span></td></tr></tbody></table><h4 id="混合积">混合积</h4><p>先叉乘后点乘：<span class="math inline">\(\left(\vec{a}\times\vec{b}\right)\cdot\vec{c}\)</span>，记作 <span class="math inline">\(\begin{bmatrix}\vec{a}&amp;\vec{b}&amp;\vec{c}\end{bmatrix}\)</span>（<strong>最后的结果是一个数，不是向量</strong>）。</p><p>计算： <span class="math display">\[\begin{bmatrix}\vec{a}&amp;\vec{b}&amp;\vec{c}\end{bmatrix}=\begin{vmatrix}x_1&amp;y_1&amp;z_1\\x_2&amp;y_2&amp;z_2\\x_3&amp;y_3&amp;z_3\end{vmatrix}\]</span>几何意义：混合积的绝对值是以 <span class="math inline">\(\vec{a},\,\vec{b},\,\vec{c}\)</span>为邻边的平行六面体体积。</p><p><span class="math inline">\(\vec{a}\times\vec{b}\)</span> 与 <span class="math inline">\(\vec{c}\)</span> 之间的夹角 <span class="math inline">\(\theta\)</span> 与混合积之间的关系： - <span class="math inline">\(\displaystyle0\leq\theta\lt\frac{\pi}{2}\Leftrightarrow\begin{bmatrix}\vec{a}&amp;\vec{b}&amp;\vec{c}\end{bmatrix}\gt0\Leftrightarrow\vec{a}\times\vec{b},\,\vec{c}\)</span> 在 <span class="math inline">\(\vec{a},\,\vec{b}\)</span> 所确定平面的同侧； -<span class="math inline">\(\displaystyle\frac{\pi}{2}\lt\theta\leq\pi\Leftrightarrow\begin{bmatrix}\vec{a}&amp;\vec{b}&amp;\vec{c}\end{bmatrix}\lt0\Leftrightarrow\vec{a}\times\vec{b},\,\vec{c}\)</span> 在 <span class="math inline">\(\vec{a},\,\vec{b}\)</span> 所确定平面的异侧； -<span class="math inline">\(\displaystyle\theta=\frac{\pi}{2}\Leftrightarrow\begin{bmatrix}\vec{a}&amp;\vec{b}&amp;\vec{c}\end{bmatrix}=0\Leftrightarrow\vec{a},\,\vec{b},\,\vec{c}\)</span>共面。</p><p>交换律： <span class="math display">\[\begin{bmatrix}\vec{a}&amp;\vec{b}&amp;\vec{c}\end{bmatrix}=\begin{bmatrix}\vec{b}&amp;\vec{c}&amp;\vec{a}\end{bmatrix}=\begin{bmatrix}\vec{c}&amp;\vec{a}&amp;\vec{b}\end{bmatrix}\]</span></p><pre><code class=" mermaid">flowchart LR;  a --&gt; b --&gt; c --&gt; a</code></pre><h2 id="平面及其方程">平面及其方程</h2><h3 id="平面的点法向式方程">平面的点法向式方程</h3><p><span class="math display">\[A\left(x-x_0\right)+B\left(y-y_0\right)+C\left(z-z_0\right)=0\]</span>其中，该平面的法向量为 <span class="math inline">\(\begin{pmatrix}A&amp;B&amp;C\end{pmatrix}\)</span>，点<span class="math inline">\(P\left(x_0,\,y_0,\,z_0\right)\)</span>是该平面上的一点。</p><p>求法： 1. 找到垂直于平面的一个向量 <span class="math inline">\(\vec\tau\)</span>； 2. 在平面中找一个定点 <span class="math inline">\(P\left(x_0,\,y_0,\,z_0\right)\)</span>，与动点<span class="math inline">\(X\left(x,\,y,\,z\right)\)</span> 构成向量<span class="math inline">\(\overrightarrow{XP}\)</span>； 3. <span class="math inline">\(\overrightarrow{XP}\cdot\vec\tau=0\)</span></p><h3 id="平面的一般式方程">平面的一般式方程</h3><p><span class="math display">\[Ax+By+Cz+D=0\]</span></p><p>特点： - <span class="math inline">\(D=0\)</span> 则平面过坐标原点；- <span class="math inline">\(A=0\)</span> 则平面平行于 <span class="math inline">\(x\)</span> 轴 - <span class="math inline">\(A=B=0\)</span> 则平面平行于 <span class="math inline">\(xOy\)</span> 平面</p><h3 id="平面的截距式方程">平面的截距式方程</h3><p><span class="math display">\[\frac{x}{a}+\frac{y}{b}+\frac{z}{c}=1\]</span></p><h2 id="曲面及其方程">曲面及其方程</h2><h3 id="旋转曲面">旋转曲面</h3><blockquote><p>平面曲线（母线）绕该平面内的某直线（轴）旋转一周所得的曲面即旋转曲面。</p></blockquote><p>设 <span class="math inline">\(yOz\)</span> 平面内有一方程为 <span class="math inline">\(f\left(y,\,z\right)=0\)</span> 的曲线，绕着 <span class="math inline">\(z\)</span> 轴旋转，要求其旋转所得的曲线：</p><ol type="1"><li>设母线上任一点为 <span class="math inline">\(M_1\left(0,\,y_1,\,z_1\right)\)</span>，过该点作垂直于<span class="math inline">\(z\)</span>轴的平面，得到该平面与旋转曲面的截痕，并设截痕上另一点为 <span class="math inline">\(M\left(x,\,y,\,z\right)\)</span></li><li>因为 <span class="math inline">\(M_1\)</span> 在母线上，所以 <span class="math inline">\(f\left(y_1,\,z_1\right)=0\)</span></li><li>曲线围绕 <span class="math inline">\(z\)</span> 轴旋转一周，<span class="math inline">\(M_1\)</span> 到 <span class="math inline">\(z\)</span> 轴的距离并不发生变化，故 <span class="math inline">\(M\)</span>、<span class="math inline">\(M_1\)</span> 两点相对 <span class="math inline">\(z\)</span> 轴的距离相等：<span class="math inline">\(\sqrt{y_1^2+(z_1-z)^2}\)</span>（<span class="math inline">\(M_1\)</span> 到 <span class="math inline">\(z\)</span> 轴的距离）<span class="math inline">\(=\sqrt{x^2+y^2+(z-z)^2}\)</span>（<span class="math inline">\(M\)</span> 到 <span class="math inline">\(z\)</span> 轴的距离）</li><li>联立方程 <span class="math inline">\(\left\{\begin{array}{l}z=z_1\\\sqrt{y_1^2+(z_1-z)^2}=\sqrt{x^2+y^2+(z-z)^2}\\f\left(y_1,\,z_1\right)=0\end{array}\right.\)</span></li><li>得旋转曲面方程 <span class="math inline">\(f\left(\pm\sqrt{x^2+y^2},\,z\right)=0\)</span></li></ol><p><span class="github-emoji"><span>📓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4d3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 注意到 <span class="math inline">\(f\left(y,\,z\right)=0\)</span> 顺时针旋转 <span class="math inline">\(90^\circ\)</span> 得到的 <span class="math inline">\(f\left(x,\,z\right)=0\)</span> 绕 <span class="math inline">\(z\)</span>轴所得的旋转曲面方程不变，故<strong><em>绕哪个轴，哪个轴不动</em></strong></p><h4 id="各类旋转曲面">各类旋转曲面</h4><ul><li><p>球面</p><p>方程：<span class="math inline">\(\displaystyle\frac{x^2}{r^2}+\frac{y^2}{r^2}+\frac{z^2}{r^2}=1\)</span>其中 <span class="math inline">\(r\)</span> 为球的半径</p></li><li><p>椭球面</p><p>方程：<span class="math inline">\(\displaystyle\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}=1\)</span>其中当 <span class="math inline">\(a,\,b,\,c\)</span>其中两个相等时，为旋转椭球面</p></li><li><p>圆锥面</p><p>方程：<span class="math inline">\(\displaystyle\frac{x^2}{a^2}+\frac{y^2}{a^2}=z^2\)</span></p></li></ul><h1 id="常微分方程">常微分方程</h1><h2 id="一阶微分方程">一阶微分方程</h2><h3 id="变量可分离的一阶方程">变量可分离的一阶方程</h3><p>形式：<span class="math inline">\(\dfrac{dy}{dx}=\varphi(x,\,y)=g(x)\cdoth(y)\)</span></p><p>解法：<span class="math inline">\(\displaystyle\dfrac{1}{h(y)}dy=g(x)dx\Rightarrow\int\dfrac{1}{h(y)}dy=\intg(x)dx\)</span></p><p>【例】求方程 <span class="math inline">\(x(1+y^2)dx+(1+x^2)ydy=0\)</span> 的通解<br>【解】关于 <span class="math inline">\(x,\,y\)</span>的式子分别移到等式两边： <span class="math inline">\(\dfrac{x}{1+x^2}dx=-\dfrac{y}{1+y^2}dy\)</span>；对等式两边积分：<span class="math inline">\(\displaystyle\int\dfrac{x}{1+x^2}dx=-\int\dfrac{y}{1+y^2}dy\)</span>得 <span class="math inline">\(\dfrac12\ln(1+x^2)=-\dfrac12\ln(1+y^2)+\dfrac12\lnC\)</span>；化简可得 <span class="math inline">\(1+y^2=\dfrac{C}{1+x^2}\)</span>。</p><h3 id="齐次方程">齐次方程</h3><p>形式：<span class="math inline">\(\dfrac{dy}{dx}=g\left(\dfrac{y}{x}\right)\)</span></p><p>解法：令 <span class="math inline">\(u=\dfrac{y}{x}\)</span> 则 <span class="math inline">\(y=x\cdot u\)</span>，两边对 <span class="math inline">\(x\)</span> 求导：<span class="math inline">\(\dfrac{dy}{dx}=u+x\cdot\dfrac{du}{dx}\)</span>。代入方程得<span class="math inline">\(u+x\cdot\dfrac{du}{dx}=g(u)\)</span>，分离变量可得<span class="math inline">\(\dfrac{u-g(u)}{du}=\dfrac{x}{dx}\)</span>。同时取倒数并积分：<span class="math inline">\(\displaystyle\int\dfrac1{u-g(u)}du=\int\dfrac{1}{x}dx\)</span>，最后把<span class="math inline">\(u=\dfrac{y}{x}\)</span>代回可得最终微分方程的解。</p><h3 id="一阶线性微分方程">一阶线性微分方程</h3><ol type="1"><li><p>齐次方程</p><p>标准形式：<span class="math inline">\(y^\prime+p(x)y=0\)</span></p><p>通解：<span class="math inline">\(y=C\cdot e^{-\intp(x)dx}\)</span></p></li><li><p>非齐次方程</p><p>标准形式：<span class="math inline">\(y^\prime+p(x)y=q(x)\)</span></p><p>通解：<span class="math inline">\(y=\displaystyle\left(\int q(x)\cdote^{\int p(x)dx}dx+C\right)e^{-\int p(x)dx}\)</span></p></li></ol><h2 id="全微分方程">全微分方程</h2><blockquote><p>若 <span class="math inline">\(P\left(x,\,y\right)dx+Q\left(x,\,y\right)dy\)</span>的左端恰好是某个函数 <span class="math inline">\(u\left(x,\,y\right)\)</span>的全微分，那么该方程称为<strong>全微分方程</strong></p></blockquote><p>判定全微分方程的充要条件： <span class="math display">\[\dfrac{\partial P}{\partial y}=\dfrac{\partialQ}{\partial x}\]</span></p><p>求解方法：</p><ol type="1"><li><p>直接积分法</p><p><span class="math inline">\(\dfrac{\partial u}{\partialx}=P,\quad\dfrac{\partial u}{\partial y}=Q\)</span></p></li><li><p>利用第二类曲线积分的路径无关性</p></li><li><p>凑微分法</p></li></ol><h2 id="高阶常系数线性微分方程">高阶常系数线性微分方程</h2><p>二阶线性微分方程的一般形式： ||一般形式| |:--:|:--:| |齐次|<span class="math inline">\(y^{\prime\prime}+p(x)y^\prime+q(x)y=0\)</span>||非齐次|<span class="math inline">\(y^{\prime\prime}+p(x)y^\prime+q(x)y=f(x)\)</span>|</p><p>解的结构：</p><ol type="1"><li>齐次的通解：设 <span class="math inline">\(y_1\)</span> 和 <span class="math inline">\(y_2\)</span> 是两个线性无关解，则 <span class="math display">\[y=c_1y_1+c_2y_2\]</span></li><li>非齐次的通解 <span class="math inline">\(=\)</span> 齐次的通解 <span class="math inline">\(+\)</span> 非齐次的特解</li><li>设 <span class="math inline">\(y_1\)</span> 是 <span class="math inline">\(y^{\prime\prime}+p(x)y^\prime+q(x)y=f_1(x)\)</span>的解；<span class="math inline">\(y_2\)</span> 是 <span class="math inline">\(y^{\prime\prime}+p(x)y^\prime+q(x)y=f_2(x)\)</span>的解，则 <span class="math inline">\(y_1+y_2\)</span> 是 <span class="math display">\[y^{\prime\prime}+p(x)y^\prime+q(x)y=f_1(x)+f_2(x)\]</span>的解。</li></ol><p>求二阶常系数齐次线性微分方程通解的步骤：</p><ol type="1"><li><p>写出微分方程 <span class="math inline">\(y^{\prime\prime}+py^{\prime}+qy=0\)</span>的特征方程 <span class="math inline">\(\lambda^2+p\lambda+q=0\)</span></p></li><li><p>求出特征方程的两个根 <span class="math inline">\(\lambda_1\)</span>, <span class="math inline">\(\lambda_2\)</span>；</p></li><li><p>根据特征根的不同情况，按下表写出方程的通解</p><table><thead><tr class="header"><th style="text-align: center;">特征方程的根</th><th style="text-align: center;">微分方程的通解</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">两个不等实根 <span class="math inline">\(\lambda_1,\,\lambda_2\)</span></td><td style="text-align: center;"><span class="math inline">\(y=C_1e^{r_1x}+C_2e^{r_2x}\)</span></td></tr><tr class="even"><td style="text-align: center;">两个相等实根 <br> <span class="math inline">\(\lambda_1=\lambda_2=-\dfrac{p}{2}\)</span></td><td style="text-align: center;"><span class="math inline">\(y=\left(C_1+C_2x\right)e^{r_1x}\)</span></td></tr><tr class="odd"><td style="text-align: center;">一对共轭复根 <br> <span class="math inline">\(\lambda_{1,2}=\alpha\pm\beta i\)</span></td><td style="text-align: center;"><span class="math inline">\(y=e^{\alphax}\left(C_1\cos\beta x+C_2\sin\beta x\right)\)</span></td></tr></tbody></table></li></ol><p><span class="github-emoji"><span>📓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4d3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 自然常数 <span class="math inline">\(e\)</span> 的指数位上<span class="math inline">\(x\)</span> 的系数一直都是方程根的一部分</p><p>求二阶常系数非齐次线性微分方程通解的步骤：</p><ol type="1"><li><p>先令 <span class="math inline">\(f(x)=0\)</span>求出对应的齐次线性微分方程的通解；</p></li><li><p>用待定系数法求非齐次线性微分方程的特解 <span class="math inline">\(y^\star (x)\)</span>：</p><ul><li>若 <span class="math inline">\(f(x)\)</span> 为多项式 <span class="math inline">\(P(n)\)</span>，则 <span class="math inline">\(y^\star=\begin{cases}R_n(x)&amp;\lambda\ne0\\x\cdot R_n(x)&amp;\lambda=0\,\text{为单根}\\ x^2\cdotR_n(x)&amp;\lambda=0\,\text{为二重根}\end{cases}\)</span></li><li>若 <span class="math inline">\(f(x)=P_n(x)\cdot e^{\alphax}\)</span>，则 <span class="math inline">\(y^\star=\begin{cases}R_n(x)\cdot e^{\alphax}&amp;\lambda\ne\alpha\\ x\cdot R_n(x)\cdot e^{\alphax}&amp;\lambda=\alpha\,\text{为单根}\\ x^2\cdot R_n(x)\cdot e^{\alphax}&amp;\lambda=\alpha\,\text{为二重根}\end{cases}\)</span></li><li>若 <span class="math inline">\(f(x)=e^{\alphax}\left(P_n(x)\cdot\cos\beta x+Q_m(x)\cdot\sin\betax\right)\)</span>，则 <span class="math inline">\(y^\star=\begin{cases}e^{\alphax}\cdot\left(R_k(x)\cdot\cos\beta x+S_k(x)\cdot\sin\betax\right)&amp;\lambda\ne\alpha\pm\beta i\\ x\cdot e^{\alphax}\cdot\left(R_k(x)\cdot\cos\beta x+S_k(x)\cdot\sin\betax\right)&amp;\lambda=\alpha\pm\beta i\end{cases}\)</span> 其中 <span class="math inline">\(k=\max{\left(m,\,n\right)}\)</span></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对于考研数学（数学一）而言，高等数学约占60%，考研数学整张卷子一共10个选择题、6个填空题、6个解答题。&lt;/p&gt;
&lt;h1 id=&quot;极限&quot;&gt;极限&lt;/h1&gt;
&lt;p&gt;极限（Limit）研究函数在 &lt;strong&gt;某一个小区间&lt;/strong&gt;
上的各种性质。&lt;/p&gt;
&lt;bloc</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://devexzh.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数学" scheme="https://devexzh.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>线性代数笔记</title>
    <link href="https://devexzh.github.io/2023/Note_Of_Linear_Algebra/"/>
    <id>https://devexzh.github.io/2023/Note_Of_Linear_Algebra/</id>
    <published>2023-01-27T08:30:00.000Z</published>
    <updated>2023-07-24T06:38:57.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性代数概览">线性代数概览</h1><h2 id="本质线性变换">本质——线性变换</h2><p><span class="math display">\[\begin{matrix}\underbrace{\begin{pmatrix}\alpha_1,\alpha_2,\cdots,\alpha_m\end{pmatrix}}\\A\end{matrix}\cdotK_{m\timesl}=\begin{matrix}\underbrace{\begin{pmatrix}b_1,b_2,\cdots,b_l\end{pmatrix}}\\B\end{matrix}\]</span></p><ul><li>矩阵视角：<span class="math inline">\(B\)</span> 是 <span class="math inline">\(A\)</span> 与 <span class="math inline">\(K\)</span> 的乘积</li><li>方程视角：<span class="math inline">\(K\)</span> 是方程 <span class="math inline">\(AX=B\)</span> 的解</li><li>向量视角：向量组 <span class="math inline">\(B\)</span> 能由向量组<span class="math inline">\(A\)</span> 线性表出</li></ul><p>两条主线：线性方程组、矩阵对角化</p><h2 id="计算矩阵的行变换">计算——矩阵的行变换</h2><ul><li>求逆矩阵：<span class="math inline">\(\displaystyle\begin{pmatrix}\begin{array}{c:c}A&amp;E\end{array}\end{pmatrix}\to\begin{pmatrix}\begin{array}{c:c}E&amp;A^{-1}\end{array}\end{pmatrix}\)</span></li><li>求解线性方程组 <span class="math inline">\(AX=B\)</span>：将伴随矩阵<span class="math inline">\(\displaystyle\begin{pmatrix}\begin{array}{c:c}A&amp;B\end{array}\end{pmatrix}\)</span> 化为行阶梯型</li></ul><h1 id="线性方程组">线性方程组</h1><pre><code class=" mermaid">flowchart LR  线性方程组 --&gt; 齐次 --&gt; 有零解  齐次 --&gt; 有非零解  线性方程组 --&gt; 非齐次 --&gt; 有解  有解 --&gt; 唯一解  有解 --&gt; 无穷多解  非齐次 --&gt; 无解</code></pre><h2 id="非齐次线性方程组">非齐次线性方程组</h2><p><span class="math display">\[\left\{\begin{array}{c}a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_{n}=b_1\\a_{21}x_1+a_{22}x_2+\cdots+a_{2n}x_{n}=b_2\\\vdots\\a_{n1}x_1+a_{n2}x_2+\cdots+a_{nn}x_{n}=b_n\end{array}\right.\]</span></p><h3 id="矩阵形式">矩阵形式</h3><p><span class="math display">\[\begin{matrix}\underbrace{\begin{pmatrix}a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1n}\\a_{21}&amp;a_{22}&amp;\cdots&amp;a_{2n}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_{n1}&amp;a_{n2}&amp;\cdots&amp;a_{nn}\\\end{pmatrix}}\\A\end{matrix}\begin{matrix}\underbrace{\begin{pmatrix}x_1\\x_2\\\vdots\\x_n\\\end{pmatrix}}\\X\end{matrix}=\begin{matrix}\underbrace{\begin{pmatrix}b_1\\b_2\\\vdots\\b_n\\\end{pmatrix}}\\B\end{matrix}\]</span><span class="math display">\[记\,\bar{A}=\begin{pmatrix}\begin{array}{cccc:c}a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1n}&amp;b_1\\a_{21}&amp;a_{22}&amp;\cdots&amp;a_{2n}&amp;b_2\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots\\a_{n1}&amp;a_{n2}&amp;\cdots&amp;a_{nn}&amp;b_n\end{array}\end{pmatrix}\]</span></p><h4 id="有解">有解</h4><p>矩阵与其伴随矩阵秩<strong>相等</strong>：<span class="math inline">\(r\left(A\right)=r\left(\bar{A}\right)\)</span></p><ul><li>唯一解：<span class="math inline">\(r\left(A\right)=r\left(\bar{A}\right)=n\)</span></li><li>无穷多解：<span class="math inline">\(r\left(A\right)=r\left(\bar{A}\right)\ltn\)</span></li></ul><h4 id="无解">无解</h4><p>矩阵与其伴随矩阵秩<strong>不等</strong>：<span class="math inline">\(r\left(A\right)\neqr\left(\bar{A}\right)\)</span></p><h3 id="向量形式">向量形式</h3><p><span class="math display">\[x_1\begin{matrix}\underbrace{\begin{pmatrix}a_{11}\\a_{21}\\\vdots\\a_{n1}\\\end{pmatrix}}\\\vec{\alpha_1}\end{matrix}+x_2\begin{matrix}\underbrace{\begin{pmatrix}a_{12}\\a_{22}\\\vdots\\a_{n2}\\\end{pmatrix}}\\\vec{\alpha_2}\end{matrix}+\cdots+x_n\begin{matrix}\underbrace{\begin{pmatrix}a_{1n}\\a_{2n}\\\vdots\\a_{nn}\\\end{pmatrix}}\\\vec{\alpha_n}\end{matrix}=\begin{matrix}\underbrace{\begin{pmatrix}b_1\\b_2\\\vdots\\b_n\\\end{pmatrix}}\\\vec{b}\end{matrix}\]</span></p><h4 id="有解-1">有解</h4><p><span class="math inline">\(\vec{b}\)</span> 能由<span class="math inline">\(\vec{\alpha_1},\,\vec{\alpha_2},\,\cdots,\,\vec{\alpha_n}\)</span>线性表示</p><h4 id="无解-1">无解</h4><p><span class="math inline">\(\vec{b}\)</span> 不能由<span class="math inline">\(\vec{\alpha_1},\,\vec{\alpha_2},\,\cdots,\,\vec{\alpha_n}\)</span>线性表示</p><h2 id="齐次线性方程组">齐次线性方程组</h2><p><span class="math display">\[\left\{\begin{array}{c}a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_{n}=0\\a_{21}x_1+a_{22}x_2+\cdots+a_{2n}x_{n}=0\\\vdots\\a_{n1}x_1+a_{n2}x_2+\cdots+a_{nn}x_{n}=0\end{array}\right.\]</span></p><h3 id="矩阵形式-1">矩阵形式</h3><p><span class="math display">\[\begin{matrix}\underbrace{\begin{pmatrix}a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1n}\\a_{21}&amp;a_{22}&amp;\cdots&amp;a_{2n}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_{n1}&amp;a_{n2}&amp;\cdots&amp;a_{nn}\\\end{pmatrix}}\\A\end{matrix}\begin{matrix}\underbrace{\begin{pmatrix}x_1\\x_2\\\vdots\\x_n\\\end{pmatrix}}\\X\end{matrix}=0\]</span></p><h4 id="只有零解">只有零解</h4><p>矩阵 <span class="math inline">\(A\)</span> 满秩：<span class="math inline">\(r\left(A\right)=n\)</span><br>行列式不等于零：<span class="math inline">\(\begin{vmatrix}A\end{vmatrix}\neq 0\)</span></p><h4 id="有非零解">有非零解</h4><p>矩阵 <span class="math inline">\(A\)</span> 降秩：<span class="math inline">\(r\left(A\right)&lt;n\)</span><br>行列式等于零：<span class="math inline">\(\begin{vmatrix}A\end{vmatrix}=0\)</span></p><h3 id="向量形式-1">向量形式</h3><p><span class="math display">\[x_1\begin{matrix}\underbrace{\begin{pmatrix}a_{11}\\a_{21}\\\vdots\\a_{n1}\\\end{pmatrix}}\\\vec{\alpha_1}\end{matrix}+x_2\begin{matrix}\underbrace{\begin{pmatrix}a_{12}\\a_{22}\\\vdots\\a_{n2}\\\end{pmatrix}}\\\vec{\alpha_2}\end{matrix}+\cdots+x_n\begin{matrix}\underbrace{\begin{pmatrix}a_{1n}\\a_{2n}\\\vdots\\a_{nn}\\\end{pmatrix}}\\\vec{\alpha_n}\end{matrix}=\vec0\]</span></p><h4 id="只有零解-1">只有零解</h4><p><span class="math inline">\(\vec{\alpha_1},\,\vec{\alpha_2},\,\cdots,\,\vec{\alpha_n}\)</span>线性无关</p><h4 id="有非零解-1">有非零解</h4><p><span class="math inline">\(\vec{\alpha_1},\,\vec{\alpha_2},\,\cdots,\,\vec{\alpha_n}\)</span>线性相关</p><h3 id="基础解系">基础解系</h3><blockquote><p>设矩阵 <span class="math inline">\(A_{m\timesn},\,r\left(A\right)=r\)</span>，对于齐次线性方程组 <span class="math inline">\(AX=0\)</span>：</p><p>若：</p><ol type="1"><li><span class="math inline">\(\xi_1,\,\xi_2,\,\cdots,\,\xi_s\)</span>为 <span class="math inline">\(AX=0\)</span> 的解；</li><li><span class="math inline">\(\xi_1,\,\xi_2,\,\cdots,\,\xi_s\)</span>线性无关；</li><li><span class="math inline">\(s=n-r\)</span></li></ol><p>称 <span class="math inline">\(\xi_1,\,\xi_2,\,\cdots,\,\xi_s\)</span> 为 <span class="math inline">\(AX=0\)</span>的基础解系（也是解向量组的极大无关组）。</p></blockquote><h4 id="找出方程组的通解">找出方程组的通解</h4><p>将矩阵化为行最简形，找到阶梯线后的列作为非自由变量，其它变量为自由变量（个数为变量个数减去矩阵的秩）</p><p>例：求出方程组 <span class="math inline">\(AX=0\)</span> 的通解（其中<span class="math inline">\(A=\left(\begin{smallmatrix}1&amp;2&amp;-1&amp;1\\1&amp;1&amp;3&amp;-1\\2&amp;5&amp;1&amp;1\\\end{smallmatrix}\right)\)</span>）</p><p>解： 1. 将矩阵化为行最简形： <span class="math display">\[A\rightarrow\begin{pmatrix}1&amp;0&amp;7&amp;-3\\0&amp;1&amp;-4&amp;2\\0&amp;0&amp;0&amp;0\end{pmatrix}\]</span></p><p>其表达的意思等同于下列方程组： <span class="math inline">\(\left\{\begin{array}{ll}x_1=-7x_3+3x_4\\x_2=4x_3-2x_4\end{array}\right.\)</span></p><ol start="2" type="1"><li><p>求出矩阵的秩：<span class="math inline">\(r\left(A\right)=2\)</span>，即有两个非自由变量，将矩阵<span class="math inline">\(X\)</span>写成如下形式（向量的个数等于变量的个数减去 <span class="math inline">\(r\left(A\right)\)</span> ）： <span class="math display">\[X=k_1\vec{\alpha_1}+k_2\vec{\alpha_2}\]</span></p></li><li><p>求出向量 <span class="math inline">\(\vec{\alpha_1},\,\vec{\alpha_2}\)</span>：找出自由变量的列数，并用<span class="math inline">\(0,\,1\)</span> 写在向量对应的行数：<span class="math inline">\(x_3,\,x_4\)</span> 是自由变量，<span class="math inline">\(x_1,\,x_2\)</span> 是非自由变量</p><p><span class="math display">\[\vec{\alpha_1}=\begin{pmatrix}\square\\\square\\1\\0\end{pmatrix},\,\vec{\alpha_2}=\begin{pmatrix}\square\\\square\\0\\1\end{pmatrix}\]</span></p><p>其它行则先将自由变量的系数取反后顺序填入： <span class="math display">\[\vec{\alpha_1}=\begin{pmatrix}-7\\4\\1\\0\end{pmatrix},\,\vec{\alpha_2}=\begin{pmatrix}3\\-2\\0\\1\\\end{pmatrix}\]</span></p></li><li><p>写出通解： <span class="math display">\[X=k_1\begin{pmatrix}-7\\4\\1\\0\end{pmatrix}+k_2\begin{pmatrix}3\\-2\\0\\1\end{pmatrix}\]</span></p></li></ol><p>对于非齐次线性方程组则仅需将自由变量对应的行全部取为0，然后其它位置填上<span class="math inline">\(\bar{A}\)</span>的最后一列的非零数即可。</p><h1 id="矩阵">矩阵</h1><h2 id="矩阵的运算">矩阵的运算</h2><p>矩阵的乘法：只有前列后行标相同才可以相乘，如<span class="math inline">\(A_{m\times n}\)</span>和<span class="math inline">\(B_{n\timess}\)</span>，得到的矩阵的行列数为前行后列，即<span class="math inline">\({AB}_{m\times s}\)</span>。</p><ul><li>性质<ul><li><span class="math inline">\(A\neq0,\,B\neq0\nRightarrowAB\neq0\)</span></li><li><span class="math inline">\(A\neq0\nRightarrowA^k\neq0\)</span></li></ul></li></ul><h2 id="矩阵的属性">矩阵的属性</h2><pre><code class=" mermaid">flowchart TB  矩阵 --- 行列式  矩阵 --- 特征值  矩阵 --- 特征向量  矩阵 --- 迹  矩阵 ---- 秩  subgraph 方阵    行列式    特征值 --特征值之积--&gt; 行列式    特征值 --特征值之和--&gt; 迹    特征向量  end</code></pre><h3 id="行列式">行列式</h3><p><span class="math display">\[D=\begin{vmatrix}  a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\  a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\  \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\  a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}\end{vmatrix} = \sum_{j_1j_2\cdotsj_n}{\left(-1\right)^{\tau\left(j_1j_2\cdotsj_n\right)}a_{1j_1}a_{2j_2}\cdots a_{nj_n} }\]</span></p><p><span class="math inline">\(Laplace\)</span> 展开： <span class="math display">\[\begin{vmatrix}D\end{vmatrix} =a_{i1}A_{i1}+a_{i2}A_{i2}+\cdots+a_{in}A_{in} =a_{1j}A_{1j}+a_{2j}A_{2j}+\cdots+a_{nj}A_{nj}\]</span></p><p>特殊的行列式：</p><ul><li><p>上/下三角行列式</p><p><span class="math display">\[\begin{vmatrix}a_{11} &amp; 0 &amp; \cdots &amp; 0 \\a_{21} &amp; a_{22} &amp; \cdots &amp; 0 \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}\end{vmatrix} =\begin{vmatrix}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\0 &amp; a_{22} &amp; \cdots &amp; a_{2n} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\0 &amp; 0 &amp; \cdots &amp; a_{nn}\end{vmatrix} = \sum_{i=1}^{n}a_{ii}\]</span></p></li><li><p>分块行列式 <span class="math display">\[\begin{vmatrix}  \boldsymbol{A} &amp; \boldsymbol{C} \\  \boldsymbol{O} &amp; \boldsymbol{B}\end{vmatrix} =\begin{vmatrix}  \boldsymbol{A} &amp; \boldsymbol{O} \\  \boldsymbol{D} &amp; \boldsymbol{B}\end{vmatrix} = \left|\boldsymbol{A}\right|\left|\boldsymbol{B}\right|\]</span></p></li><li><p><span class="math inline">\(Vandermonde\)</span> 行列式</p><p><span class="math display">\[\begin{vmatrix}1&amp;1&amp;\cdots&amp;1\\a_1&amp;a_2&amp;\cdots&amp;a_n\\a_1^2&amp;a_2^2&amp;\cdots&amp;a_n^2\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_1^{n-1}&amp;a_2^{n-1}&amp;\cdots&amp;a_n^{n-1}\end{vmatrix}=\prod_{n\geqi\gt j\geq 1}\left(a_i-a_j\right)\]</span></p></li><li><p>箭形（爪形）行列式</p><p><span class="math display">\[\begin{vmatrix}a_1&amp;1&amp;1&amp;\cdots&amp;1\\1&amp;a_2&amp;0&amp;\cdots&amp;0\\1&amp;0&amp;a_3&amp;\cdots&amp;0\\\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\1&amp;0&amp;0&amp;\cdots&amp;a_n\end{vmatrix}\;\left(a_2a_3\cdotsa_n\neq0\right)\]</span> <span class="math display">\[\xlongequal{c_1-\frac{1}{a_2}c_2-\frac{1}{a_3}c_3-\cdots-\frac{1}{a_n}c_n}\begin{vmatrix}a_1-\frac{1}{a_2}-\cdots-\frac{1}{a_n}&amp;1&amp;1&amp;\cdots&amp;1\\0&amp;a_2&amp;0&amp;\cdots&amp;0\\0&amp;0&amp;a_3&amp;\cdots&amp;0\\\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\0&amp;0&amp;0&amp;\cdots&amp;a_n\end{vmatrix}\]</span><span class="math display">\[=\prod_{i=2}^{n}a_i\left(a_1-\sum_{j=2}^{n}\frac{1}{a_j}\right)\]</span></p></li></ul><hr><h3 id="特征值与特征向量">特征值与特征向量</h3><blockquote><p>设 <span class="math inline">\(n\)</span> 阶方阵 <span class="math inline">\(A_{n\times n}\)</span>，若存在数 <span class="math inline">\(\lambda\)</span>（不一定是实数）以及非零向量 <span class="math inline">\(\vec\alpha\)</span>，使得 <span class="math inline">\(A\vec\alpha=\lambda\vec\alpha\)</span>，则称 <span class="math inline">\(\lambda\)</span> 为矩阵 <span class="math inline">\(A\)</span> 的<strong>特征值</strong>，<span class="math inline">\(\vec\alpha\)</span> 为 <span class="math inline">\(\vec\lambda\)</span>对应的<strong>特征向量</strong>。</p></blockquote><p>要求解特征向量与特征值，则需把定义的等式转化为其它形式：</p><p><span class="math inline">\(A\alpha=\lambda\alpha\Rightarrow\left(\lambdaE-A\right)\alpha=0\)</span>。</p><p><span class="math inline">\(\because\alpha\neq0\,\,\therefore\left(\lambdaE-A\right)X=0有非零解\Rightarrow\left|\lambdaE-A\right|=0\)</span>。</p><p>最终得到的等式即特征方程。</p><p>性质：</p><ul><li>若 <span class="math inline">\(A\vec\alpha=\lambda\vec\alpha\)</span> 成立，则<span class="math inline">\(f\left(A\right)\vec\alpha=f\left(\lambda\right)\vec\alpha\)</span>同样成立。</li><li>若方阵 <span class="math inline">\(A\)</span> 可逆，则 <span class="math inline">\(\displaystyleA^{-1}\alpha=\frac{1}{\lambda}\alpha,\,A^\ast\alpha=\frac{\left|A\right|}{\lambda}\alpha\)</span></li></ul><hr><h3 id="秩">秩</h3><p>本质上是线性方程组的约束条件个数。</p><blockquote><p>设矩阵 <span class="math inline">\(A_{m\times n}\)</span>，在 <span class="math inline">\(A\)</span> 中任取 <span class="math inline">\(r\)</span> 行 <span class="math inline">\(r\)</span> 列，构成 <span class="math inline">\(r\)</span> 阶行列式，称为 <span class="math inline">\(A\)</span> 的 <span class="math inline">\(r\)</span> 阶子式（个数：<span class="math inline">\(C_m^rC_n^r\)</span>）</p><p>若：</p><ol type="1"><li>存在不为零的 <span class="math inline">\(r\)</span> 阶子式</li><li>任意 <span class="math inline">\(r+1\)</span>阶子式要么不存在要么为零</li></ol><p>则 <span class="math inline">\(r\)</span> 为矩阵 <span class="math inline">\(A\)</span> 的秩 (Rank)，记为 <span class="math inline">\(r\left(A\right)=r\)</span></p></blockquote><p>对于 <span class="math inline">\(n\)</span> 阶可逆矩阵，由于 <span class="math inline">\(\left|A_{n\times n}\right|\neq0\)</span>，故 <span class="math inline">\(r\left(A\right)=n\)</span>。又因为其阶数与其秩相等，故称其为满秩矩阵。同理，如果方阵不可逆则<span class="math inline">\(\left|A\right|=0\)</span>，其最高阶非零子式的阶数必定小于<span class="math inline">\(n\)</span>，称其为降秩矩阵。</p><p>矩阵秩的性质：</p><ol type="1"><li><strong>矩阵秩必小于等于其行标列标的最小值</strong>：<span class="math inline">\(r\left(A_{m\times n}\right)\le\min{\left\{m,\n\right\}}\)</span></li><li><ul><li><span class="math inline">\(r\left(A\right)=0\LeftrightarrowA=0\)</span></li><li><span class="math inline">\(r\left(A\right)\geq1\LeftrightarrowA\neq0\)</span></li><li><span class="math inline">\(r\left(A\right)\geq2\LeftrightarrowA\)</span> 至少有2行不成比例</li></ul></li><li><strong>矩阵与其转置矩阵的秩相等</strong>： <span class="math inline">\(r\left(A\right)=r\left(A^T\right)=r\left(AA^T\right)=r\left(A^TA\right)\)</span></li><li><strong>矩阵作加减运算得到新矩阵的秩必小于等于原矩阵秩的加减</strong>：<span class="math inline">\(r\left(A\pm B\right)\ler\left(A\right)+r\left(B\right)\)</span></li><li><strong>矩阵相乘后秩小于等于原任一矩阵的秩</strong>：<span class="math inline">\(r\left(AB\right)\le r(A)、r\left(AB\right)\ler\left(B\right)、r\left(AB\right)\le\min{\left\{r\left(A\right),r\left(B\right)\right\}}\)</span></li><li><strong>矩阵相乘为零阵，秩之和小于等于内标</strong>：<span class="math inline">\(A_{m\times n},\,B_{n\times s}\)</span>，且 <span class="math inline">\(AB=0\)</span>，则 <span class="math inline">\(r\left(A\right)+r\left(B\right)\le n\)</span></li><li><strong>矩阵与可逆阵相乘，秩不变</strong>：若 <span class="math inline">\(n\)</span> 阶方阵 <span class="math inline">\(P,\,Q\)</span> 可逆，则 <span class="math inline">\(r\left(A\right)=r\left(PA\right)=r\left(AQ\right)=r(PAQ)\)</span></li><li><strong>伴随矩阵的秩与原矩阵秩的关系</strong>：<span class="math inline">\(r\left(A^\ast\right)=\left\{\begin{array}{ll}n&amp;r\left(A\right)=n\\1&amp;r\left(A\right)=n-1\\0&amp;r\left(A\right)\ltn-1\end{array}\right.\)</span></li></ol><h2 id="矩阵的关系">矩阵的关系</h2><pre><code class=" mermaid">flowchart TB  矩阵 --可逆方阵--&gt; 相似 &amp; 合同</code></pre><h3 id="方阵相似">方阵相似</h3><blockquote><p>设 <span class="math inline">\(n\)</span> 阶矩阵 <span class="math inline">\(A,\,B\)</span>，若存在可逆矩阵 <span class="math inline">\(P\)</span> 使得 <span class="math inline">\(P^{-1}AP=B\)</span>，则称 <span class="math inline">\(A\)</span> 与 <span class="math inline">\(B\)</span> 相似，记为 <span class="math inline">\(A~B\)</span>。</p></blockquote><h4 id="方阵的相似对角化">方阵的相似对角化</h4><blockquote><p>设 <span class="math inline">\(n\)</span> 阶方阵，若存在可逆阵 <span class="math inline">\(P\)</span> 使得 <span class="math inline">\(P^{-1}AP\)</span> 为对角阵，则称 <span class="math inline">\(A\)</span> 可对角化（即 <span class="math inline">\(A\)</span> 与某一对角矩阵相似）</p></blockquote><p><strong><span class="math inline">\(n\)</span>阶方阵可对角化的充要条件是存在 <span class="math inline">\(n\)</span>个线性无关的特征向量。</strong></p><p>方阵可对角化的判定</p><ul><li><span class="math inline">\(n\)</span> 阶方阵 <span class="math inline">\(A\)</span> 有 <span class="math inline">\(n\)</span> 个互不相同的特征值 <span class="math inline">\(\to A\)</span> 可对角化</li><li><span class="math inline">\(n\)</span> 阶方阵 <span class="math inline">\(A\)</span> 互异的特征值为 <span class="math inline">\(\lambda_1,\,\lambda_2,\,\cdots,\,\lambda_m\)</span>，重数依次为<span class="math inline">\(r_1,\,r_2,\,\cdots,\,r_m\Leftrightarrow\forall\lambda_i\)</span>，<span class="math inline">\(A\)</span> 有 <span class="math inline">\(r_i\)</span> 个线性无关的特征向量。</li></ul><p>方阵对角化的过程</p><ol type="1"><li><p><span class="math inline">\(\left|\lambdaE-A\right|=0\Rightarrow\lambda_1,\,\lambda_2,\\cdots,\,\lambda_n\)</span></p></li><li><p><span class="math inline">\(\left(\lambda_iE-A\right)X=0\Rightarrow\vec{\alpha_1},\,\vec{\alpha_2},\,\cdots,\,\vec{\alpha_m}\,(m\len)\)</span></p></li><li><p>仅当 <span class="math inline">\(m=n\)</span> 时才可以对角化</p><p>由 <span class="math inline">\(\left(A\vec{\alpha_1},\,A\vec{\alpha_2},\,\cdots,\,A\vec{\alpha_n}\right)=\left(\lambda_1\vec{\alpha_1},\,\lambda_2\vec{\alpha_2},\,\cdots,\,\lambda_n\vec{\alpha_n}\right)\)</span><span class="math inline">\(\require{extpfeil}\Newextarrow{\xRightarrow}{5,5}{0x21D2}\xRightarrow{P=\left(\vec{\alpha_1},\,\vec{\alpha_2},\,\cdots,\,\vec{\alpha_n}\right)}\newcommand\diag[1]{\begin{pmatrix}\begin{smallmatrix}#1_1&amp;&amp;&amp;\\&amp;#1_2&amp;&amp;\\&amp;&amp;\ddots&amp;\\&amp;&amp;&amp;#1_n\end{smallmatrix}\end{pmatrix}}AP=P\diag{\lambda}\RightarrowP^{-1}AP=\diag{\lambda}\)</span></p></li></ol><h2 id="派生矩阵">派生矩阵</h2><pre><code class=" mermaid">flowchart TB  矩阵 --方阵--&gt; 伴随矩阵 &amp; 逆矩阵  矩阵 --&gt; 转置矩阵</code></pre><hr><h3 id="伴随矩阵">伴随矩阵</h3><p><span class="math display">\[A=\begin{pmatrix}a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1n}\\a_{21}&amp;a_{22}&amp;\cdots&amp;a_{2n}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_{n1}&amp;a_{n2}&amp;\cdots&amp;a_{nn}\end{pmatrix}\rightarrowA^\ast=\begin{pmatrix}A_{11}&amp;A_{21}&amp;\cdots&amp;A_{n1}\\A_{12}&amp;A_{22}&amp;\cdots&amp;A_{n2}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\A_{1n}&amp;A_{2n}&amp;\cdots&amp;A_{nn}\end{pmatrix}\]</span>（其中 <span class="math inline">\(A_{ij}\)</span> 为元素 <span class="math inline">\(a_{ij}\)</span> 的代数余子式）</p><p>伴随矩阵的性质：</p><ul><li><span class="math inline">\(AA^\ast=A^\ast A=|A|E\)</span></li><li><span class="math inline">\(\left|A_{n\timesn}^\ast\right|=\left|A_{n\times n}\right|^{n-1}\)</span></li></ul><hr><h3 id="逆矩阵">逆矩阵</h3><p>别名：</p><ul><li>满秩矩阵，<span class="math inline">\(r\left(A_{n\times{n}}\right)=n\)</span></li><li>非奇异矩阵</li></ul><p>求法：</p><ul><li>伴随矩阵法<ul><li>原理：<span class="math inline">\(\displaystyleA^{-1}=\frac{1}{|A|}A^\ast\)</span></li></ul></li><li>矩阵的初等行变换法<ul><li>原理：<span class="math inline">\(\displaystyle\begin{pmatrix}\begin{array}{c:c}A&amp;E\end{array}\end{pmatrix}\to\begin{pmatrix}\begin{array}{c:c}E&amp;A^{-1}\end{array}\end{pmatrix}\)</span></li></ul></li></ul><p>存在的条件：</p><ul><li>矩阵必须为方阵</li><li>（充要条件）<span class="math inline">\(\left|A\right|\neq0\)</span></li></ul><p>逆矩阵的性质：</p><ul><li><span class="math inline">\(\left(A^{-1}\right)^{-1}=A\)</span></li><li><span class="math inline">\(\left(kA\right)^{-1}=\frac{1}{k}A^{-1}\)</span></li><li><span class="math inline">\(\left(AB\right)^{-1}=B^{-1}A^{-1}\)</span></li><li><span class="math inline">\(\left(A^T\right)^{-1}=\left(A^{-1}\right)^T\)</span></li><li><span class="math inline">\(\left|A^{-1}\right|=\left|A\right|^{-1}\)</span></li></ul><hr><h3 id="特殊的矩阵">特殊的矩阵</h3><pre><code class=" mermaid">flowchart TB  矩阵 --方阵--&gt; 实对称矩阵</code></pre><h4 id="实对称矩阵">实对称矩阵</h4><ul><li>不同特征值对应的特征向量是正交的</li><li>特征值都是实数，特征向量都是实向量</li><li>必可相似对角化，且相似对角阵上的元素即为矩阵本身特征值</li></ul><h1 id="向量">向量</h1><p>向量组等价：若两个向量组的向量可以相互线性表示，则两向量组等价</p><p>极大线性无关组：设 <span class="math inline">\(\alpha_1,\,\alpha_2,\,\cdots,\,\alpha_n\)</span>为向量组，若存在 <span class="math inline">\(r\)</span>个向量线性无关；且任取 <span class="math inline">\(r+1\)</span>个向量（不一定有）线性相关，则称这 <span class="math inline">\(r\)</span>个线性无关的向量组为极大无关组（不一定唯一），<span class="math inline">\(r\)</span> 即向量组的秩。</p><p><span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 注意</p><ul><li>向量组与其极大线性无关组等价。</li><li>设 <span class="math inline">\(\alpha_1,\,\alpha_2,\,\cdots,\,\alpha_n\)</span>为向量组，则：<ul><li><span class="math inline">\(\alpha_1,\,\alpha_2,\,\cdots,\,\alpha_n\)</span>线性无关<span class="math inline">\(\Rightarrow\alpha_1,\,\alpha_2,\,\cdots,\,\alpha_n\)</span>为极大线性无关组 <span class="math inline">\(\Rightarrow\)</span>向量组的秩 <span class="math inline">\(=n\)</span>。</li><li><span class="math inline">\(\alpha_1,\,\alpha_2,\,\cdots,\,\alpha_n\)</span>线性相关 <span class="math inline">\(\Rightarrow\)</span> 向量组的秩<span class="math inline">\(\lt n\)</span>。</li></ul></li><li>设向量组 <span class="math inline">\(\mathrm{I}:\,\alpha_1,\,\alpha_2,\,\cdots,\,\alpha_n;\;\mathrm{II}:\,\alpha_1,\,\alpha_2,\,\cdots,\,\alpha_n,\,\beta\)</span>，则：<ul><li><span class="math inline">\(R\left(\mathrm{I}\right)=R\left(\mathrm{II}\right)\Rightarrow\beta\)</span>可以由组 <span class="math inline">\(\mathrm{I}\)</span> 线性表示</li><li><span class="math inline">\(R\left(\mathrm{I}\right)=R\left(\mathrm{II}\right)+1\Rightarrow\beta\)</span>不可由组 <span class="math inline">\(\mathrm{I}\)</span> 线性表示</li></ul></li><li>设矩阵 <span class="math inline">\(A_{m\times n},\,B_{n\timess}=\left(\beta_1,\,\beta_2,\,\cdots,\,\beta_s\right)\)</span>，则 <span class="math inline">\(AB=\left({A\beta}_1,\,{A\beta}_2,\,\cdots,\,{A\beta}_s\right)\)</span><ul><li>例：<span class="math inline">\(A=\begin{pmatrix}\begin{smallmatrix}\alpha_1,\,\alpha_2,\,\alpha_3\end{smallmatrix}\end{pmatrix},\,B=\begin{pmatrix}\begin{smallmatrix}\alpha_1-\alpha_2+\alpha_3,\,2\alpha_1+\alpha_2,\,\alpha_2-4\alpha_3\end{smallmatrix}\end{pmatrix}\)</span>，则<span class="math inline">\(B=A\begin{pmatrix}\begin{smallmatrix}1&amp;2&amp;0\\-1&amp;1&amp;1\\1&amp;0&amp;-4\end{smallmatrix}\end{pmatrix}\)</span>。</li></ul></li></ul><p>向量组秩的诸性质</p><ul><li>设向量组<span class="math inline">\(\mathrm{I}:\,\alpha_1,\,\alpha_2,\,\cdots,\,\alpha_m;\;\mathrm{II}:\,\beta_1,\,\beta_2,\,\cdots,\,\beta_n\)</span>。若组<span class="math inline">\(\mathrm{I}\)</span> 可由组 <span class="math inline">\(\mathrm{II}\)</span> 线性表示，则 <span class="math inline">\(R\left(\mathrm{I}\right)\leqR\left(\mathrm{II}\right)\)</span></li><li>两个等价向量组的秩相等，反之不对。</li></ul><h2 id="向量的正交">向量的正交</h2><p>若 <span class="math inline">\(\left(\alpha,\,\beta\right)=0\)</span>则 <span class="math inline">\(\alpha,\,\beta\)</span> 正交，记为 <span class="math inline">\(\alpha\bot\beta\)</span>。正交的向量一定线性无关。</p><p>性质：</p><ul><li>非零向量 <span class="math inline">\(\alpha_1,\,\alpha_2,\,\cdots,\,\alpha_n\)</span>两两正交，则 <span class="math inline">\(\alpha_1,\,\alpha_2,\,\cdots,\,\alpha_n\)</span>线性无关。</li></ul><h3 id="施密特正交化">施密特正交化</h3><p>设向量组 <span class="math inline">\(\alpha_1,\,\alpha_2,\,\cdots,\,\alpha_n\)</span>，经过施密特正交化（Schmidtorthogonalization）后得到的向量组为：</p><p><span class="math display">\[\left\{\begin{array}{l}\beta_1=\alpha_1\\\beta_2=\alpha_2-\frac{\begin{pmatrix}\alpha_2,\,\beta_1\end{pmatrix}}{\begin{pmatrix}\beta_1,\,\beta_1\end{pmatrix}}\beta_1\\\beta_3=\alpha_3-\frac{\begin{pmatrix}\alpha_3,\,\beta_1\end{pmatrix}}{\begin{pmatrix}\beta_1,\,\beta_1\end{pmatrix}}\beta_1-\frac{\begin{pmatrix}\alpha_3,\,\beta_2\end{pmatrix}}{\begin{pmatrix}\beta_2,\,\beta_2\end{pmatrix}}\beta_2\\\;\,\quad\vdots\\\beta_n=\alpha_n-\frac{\begin{pmatrix}\alpha_n,\,\beta_1\end{pmatrix}}{\begin{pmatrix}\beta_1,\,\beta_1\end{pmatrix}}\beta_1-\cdots-\frac{\begin{pmatrix}\alpha_n,\,\beta_{n-1}\end{pmatrix}}{\begin{pmatrix}\beta_{n-1},\,\beta_{n-1}\end{pmatrix}}\beta_{n-1}\end{array}\right.\]</span></p><h1 id="二次型">二次型</h1><h2 id="标准形">标准形</h2><blockquote><p>只含有平方项的二次型称为二次型的标准形，其<strong>秩等于正负惯性指数之和</strong>（正惯性指数就是标准形中正平方项的个数，负惯性指数同理）</p><blockquote><p>在标准形中，若平方项的系数为<span class="math inline">\(-1,\,1,\,0\)</span>，则称其为二次型的<strong>规范形</strong></p></blockquote></blockquote><h3 id="化二次型为标准型的方法">化二次型为标准型的方法</h3><p><strong>任意实对称矩阵与对角阵合同</strong></p><h4 id="正交变换法">正交变换法</h4><ol type="1"><li>把二次型表示成矩阵形式 <span class="math inline">\(x^T\boldsymbol{A}x\)</span></li><li>求出 <span class="math inline">\(\boldsymbol{A}\)</span>的全部互异特征值 <span class="math inline">\(\lambda_i\)</span>，设<span class="math inline">\(\lambda_i\)</span> 是 <span class="math inline">\(n\)</span> 重根</li><li>对每个特征值 <span class="math inline">\(\lambda_i\)</span>，求解齐次线性方程组 <span class="math inline">\(\left(\lambda_i\boldsymbol{E}-\boldsymbol{A}\right)x=0\)</span>；求得基础解系，即属于<span class="math inline">\(\lambda_i\)</span> 的线性无关的特征向量</li><li>将 <span class="math inline">\(\boldsymbol{A}\)</span>的属于同一个特征值的特征向量正交化</li><li>将全部向量单位化</li><li>将向量作列，按照 <span class="math inline">\(\lambda_i\)</span>在对角矩阵主对角线上的位置构成正交矩阵 <span class="math inline">\(\boldsymbol{Q}\)</span></li><li>令<span class="math inline">\(x=\boldsymbol{Q}y\)</span>，得 <span class="math inline">\(x^T\boldsymbol{A}x=\lambda_1y_1^2+\lambda_2y_2^2+\cdots+\lambda_ny_n^2\)</span></li></ol><h2 id="正定二次型">正定二次型</h2><blockquote><p>若二次型 <span class="math inline">\(f=x^T\boldsymbol{A}x\)</span>对任意 <span class="math inline">\(x\neq0\)</span> 都有 <span class="math inline">\(f\gt0\)</span>，则称 <span class="math inline">\(f\)</span> 为<strong>正定二次型</strong>，矩阵<span class="math inline">\(A\)</span> 称为正定矩阵。</p></blockquote><p>判别法</p><ul><li><span class="math inline">\(f\)</span> 的标准型的 <span class="math inline">\(n\)</span> 个系数全为正</li><li><span class="math inline">\(f\)</span> 的正惯性指数为 <span class="math inline">\(n\)</span></li><li><span class="math inline">\(f\)</span> 的矩阵 <span class="math inline">\(A\)</span> 的特征值全大于零</li><li>存在可逆阵 <span class="math inline">\(P\)</span>，使得 <span class="math inline">\(P^TAP=E\)</span> 或 <span class="math inline">\(A=P^TP\)</span></li><li><span class="math inline">\(f\)</span> 的矩阵 <span class="math inline">\(A\)</span> 的各顺序主子式全大于零<ul><li><p>顺序主子式</p><p>设 <span class="math inline">\(\displaystyleA=\begin{pmatrix}\begin{smallmatrix}a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1n}\\a_{21}&amp;a_{22}&amp;\cdots&amp;a_{2n}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_{n1}&amp;a_{n2}&amp;\cdots&amp;a_{nn}\end{smallmatrix}\end{pmatrix}\)</span>，则<span class="math inline">\(\displaystyle\begin{vmatrix}A_k\end{vmatrix}=\begin{vmatrix}a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1k}\\a_{21}&amp;a_{22}&amp;\cdots&amp;a_{2k}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\a_{k1}&amp;a_{k2}&amp;\cdots&amp;a_{kk}\end{vmatrix}\)</span>称为 <span class="math inline">\(n\)</span> 阶方阵 <span class="math inline">\(A\)</span> 的 <span class="math inline">\(k\)</span> 阶顺序主子式。</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线性代数概览&quot;&gt;线性代数概览&lt;/h1&gt;
&lt;h2 id=&quot;本质线性变换&quot;&gt;本质——线性变换&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[&#92;begin{matrix}&#92;underbrace{&#92;begin{pmatrix}&#92;alpha_1,</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://devexzh.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数学" scheme="https://devexzh.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
</feed>
